Directory structure:
└── nested_form_builder/
    ├── builder/
    │   ├── audit.json
    │   ├── Index.html
    │   ├── vite.config.mjs
    │   └── src/
    │       ├── app/
    │       │   ├── App.jsx
    │       │   ├── main.jsx
    │       │   ├── components/
    │       │   │   ├── AlertDialog.jsx
    │       │   │   ├── AppLayout.jsx
    │       │   │   ├── BaseDialog.jsx
    │       │   │   └── ConfirmDialog.jsx
    │       │   ├── hooks/
    │       │   │   ├── useAlert.js
    │       │   │   └── useBeforeUnloadGuard.js
    │       │   ├── state/
    │       │   │   ├── AlertProvider.jsx
    │       │   │   ├── AppDataProvider.jsx
    │       │   │   ├── authContext.jsx
    │       │   │   ├── cachePolicy.js
    │       │   │   ├── dataStore.js
    │       │   │   ├── dbHelpers.js
    │       │   │   ├── formsCache.js
    │       │   │   └── recordsCache.js
    │       │   └── theme/
    │       │       ├── base.css
    │       │       ├── preview-overrides.css
    │       │       ├── theme.css
    │       │       ├── theme.js
    │       │       ├── tokens.js
    │       │       └── themes/
    │       │           ├── christmas.css
    │       │           ├── dark.css
    │       │           ├── egypt.css
    │       │           ├── forest.css
    │       │           ├── india.css
    │       │           ├── matcha.css
    │       │           ├── ocean.css
    │       │           ├── sakura.css
    │       │           ├── snow.css
    │       │           ├── standard.css
    │       │           └── warm.css
    │       ├── core/
    │       │   ├── collect.js
    │       │   ├── constants.js
    │       │   ├── displayModes.js
    │       │   ├── ids.js
    │       │   ├── schema.js
    │       │   ├── schemaUtils.js
    │       │   ├── selfTests.js
    │       │   ├── storage.js
    │       │   ├── styleSettings.js
    │       │   └── validate.js
    │       ├── features/
    │       │   ├── admin/
    │       │   │   ├── FormBuilderWorkspace.jsx
    │       │   │   └── SearchPreviewPanel.jsx
    │       │   ├── editor/
    │       │   │   ├── EditorPage.jsx
    │       │   │   ├── OptionRow.jsx
    │       │   │   ├── QuestionCard.jsx
    │       │   │   ├── QuestionList.jsx
    │       │   │   └── styles.js
    │       │   ├── export/
    │       │   │   └── SettingsPanel.jsx
    │       │   ├── preview/
    │       │   │   └── PreviewPage.jsx
    │       │   ├── search/
    │       │   │   ├── searchStyles.js
    │       │   │   ├── searchTable.js
    │       │   │   ├── searchTable.test.js
    │       │   │   ├── useEntriesWithCache.js
    │       │   │   └── components/
    │       │   │       ├── SearchPagination.jsx
    │       │   │       ├── SearchSidebar.jsx
    │       │   │       ├── SearchTable.jsx
    │       │   │       └── SearchToolbar.jsx
    │       │   └── settings/
    │       │       ├── settingsSchema.js
    │       │       └── settingsStore.js
    │       ├── pages/
    │       │   ├── AdminDashboardPage.jsx
    │       │   ├── AdminFormEditorPage.jsx
    │       │   ├── AdminSettingsPage.jsx
    │       │   ├── ConfigPage.jsx
    │       │   ├── FormPage.jsx
    │       │   ├── MainPage.jsx
    │       │   ├── NotFoundPage.jsx
    │       │   └── SearchPage.jsx
    │       ├── services/
    │       │   └── gasClient.js
    │       └── utils/
    │           ├── dateTime.js
    │           ├── deepEqual.js
    │           ├── formNormalize.js
    │           ├── formPaths.js
    │           ├── perfLogger.js
    │           ├── responses.js
    │           ├── settings.js
    │           └── spreadsheet.js
    └── gas/
        ├── README.md
        ├── appsscript.json
        ├── Code.gs
        ├── constants.gs
        ├── drive.gs
        ├── errors.gs
        ├── formsCrud.gs
        ├── formsImport.gs
        ├── formsMappingStore.gs
        ├── formsParsing.gs
        ├── formsPublicApi.gs
        ├── formsStorage.gs
        ├── model.gs
        ├── properties.gs
        ├── settings.gs
        ├── sheetsDatetime.gs
        ├── sheetsExport.gs
        ├── sheetsHeaders.gs
        ├── sheetsRecords.gs
        ├── sheetsRowOps.gs
        └── scripts/
            └── bundle.js

================================================
FILE: builder/audit.json
================================================
{
  "auditReportVersion": 2,
  "vulnerabilities": {
    "vite": {
      "name": "vite",
      "severity": "moderate",
      "isDirect": true,
      "via": [
        {
          "source": 1109104,
          "name": "vite",
          "dependency": "vite",
          "title": "vite allows server.fs.deny bypass via backslash on Windows",
          "url": "https://github.com/advisories/GHSA-93m4-6634-74q7",
          "severity": "moderate",
          "cwe": [
            "CWE-22"
          ],
          "cvss": {
            "score": 0,
            "vectorString": null
          },
          "range": ">=7.1.0 <=7.1.10"
        }
      ],
      "effects": [],
      "range": "7.1.0 - 7.1.10",
      "nodes": [
        "node_modules/vite"
      ],
      "fixAvailable": true
    }
  },
  "metadata": {
    "vulnerabilities": {
      "info": 0,
      "low": 0,
      "moderate": 1,
      "high": 0,
      "critical": 0,
      "total": 1
    },
    "dependencies": {
      "prod": 21,
      "dev": 115,
      "optional": 49,
      "peer": 0,
      "peerOptional": 0,
      "total": 135
    }
  }
}



================================================
FILE: builder/Index.html
================================================
<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Nested Form Builder</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/app/main.jsx"></script>
  </body>
</html>



================================================
FILE: builder/vite.config.mjs
================================================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import { viteSingleFile } from "vite-plugin-singlefile";

export default defineConfig({
  plugins: [react(), viteSingleFile()],
  root: "./",
  build: {
    outDir: "../dist",
    emptyOutDir: true,
    assetsInlineLimit: 0,
    cssCodeSplit: false,
    modulePreload: false,
    minify: false, // Completely disable minification to preserve console.log
    rollupOptions: {
      input: './Index.html',  // 明示的にIndex.htmlを指定
      output: {
        inlineDynamicImports: true,
        entryFileNames: '[name].js',
        assetFileNames: '[name].[ext]',
      },
    },
  },
});



================================================
FILE: builder/src/app/App.jsx
================================================
import React from "react";
import { HashRouter, Route, Routes, Navigate } from "react-router-dom";
import { AppDataProvider } from "./state/AppDataProvider.jsx";
import { AlertProvider } from "./state/AlertProvider.jsx";
import { AuthProvider, useAuth } from "./state/authContext.jsx";
import MainPage from "../pages/MainPage.jsx";
import SearchPage from "../pages/SearchPage.jsx";
import FormPage from "../pages/FormPage.jsx";
import AdminDashboardPage from "../pages/AdminDashboardPage.jsx";
import AdminFormEditorPage from "../pages/AdminFormEditorPage.jsx";
import AdminSettingsPage from "../pages/AdminSettingsPage.jsx";
import ConfigPage from "../pages/ConfigPage.jsx";
import NotFoundPage from "../pages/NotFoundPage.jsx";

/**
 * フォーム管理ルートのラッパー
 * scriptモードは管理者のみ、userモードは全ユーザー許可
 */
function FormsRoute({ children }) {
  const { isAdmin, formId, propertyStoreMode } = useAuth();

  if (propertyStoreMode === "user") {
    return children;
  }

  if (!isAdmin) {
    // 一般ユーザーは指定フォームの検索画面へリダイレクト
    if (formId) {
      return <Navigate to={`/search?form=${formId}`} replace />;
    }
    // formIdもない場合はアクセス拒否状態としてトップへ戻す
    return <Navigate to="/" replace />;
  }

  return children;
}

/**
 * 管理者設定ルートのラッパー
 * 管理者設定が有効かつ管理者の場合のみ許可
 */
function AdminSettingsRoute({ children }) {
  const { isAdmin, formId, adminSettingsEnabled } = useAuth();

  if (!adminSettingsEnabled) {
    return <Navigate to="/" replace />;
  }

  if (!isAdmin) {
    if (formId) {
      return <Navigate to={`/search?form=${formId}`} replace />;
    }
    return <Navigate to="/" replace />;
  }

  return children;
}

/**
 * フォームが見つからないエラー画面
 */
function FormNotFoundPage() {
  return (
    <div className="app-root">
      <header className="app-header">
        <div className="app-header-left">
          <h1 className="app-header-title">フォームが見つかりません</h1>
        </div>
      </header>
      <div className="app-container">
        <main className="app-main">
          <div className="nf-card">
            <p>指定されたフォームは存在しません。</p>
            <p className="nf-text-muted nf-text-14 nf-mt-8">
              URLが正しいか確認してください。
            </p>
          </div>
        </main>
      </div>
    </div>
  );
}

/**
 * 一般ユーザー用の初期リダイレクト処理
 */
function UserRedirect() {
  const { authError, formId } = useAuth();

  // 認証エラーがある場合
  if (authError === "form_not_found") {
    return <FormNotFoundPage />;
  }
  if (authError === "access_denied" || authError === "forbidden") {
    return <AccessDeniedPage />;
  }

  if (formId) {
    return <Navigate to={`/search?form=${formId}`} replace />;
  }

  return <MainPage />;
}

/**
 * アクセス拒否ページ
 */
function AccessDeniedPage() {
  return (
    <div className="app-root">
      <header className="app-header">
        <div className="app-header-left">
          <h1 className="app-header-title">アクセスできません</h1>
        </div>
      </header>
      <div className="app-container">
        <main className="app-main">
          <div className="nf-card">
            <p>このページにアクセスする権限がありません。</p>
            <p className="nf-text-muted nf-text-14 nf-mt-8">
              正しいURLでアクセスしているか確認してください。
            </p>
          </div>
        </main>
      </div>
    </div>
  );
}

/**
 * ルーティング本体
 */
function AppRoutes() {
  return (
    <Routes>
      <Route path="/" element={<UserRedirect />} />
      <Route path="/search" element={<SearchPage />} />
      <Route path="/form/:formId/new" element={<FormPage />} />
      <Route path="/form/:formId/entry/:entryId" element={<FormPage />} />
      <Route
        path="/forms"
        element={
          <FormsRoute>
            <AdminDashboardPage />
          </FormsRoute>
        }
      />
      <Route
        path="/forms/new"
        element={
          <FormsRoute>
            <AdminFormEditorPage />
          </FormsRoute>
        }
      />
      <Route
        path="/forms/:formId/edit"
        element={
          <FormsRoute>
            <AdminFormEditorPage />
          </FormsRoute>
        }
      />
      <Route
        path="/config"
        element={<ConfigPage />}
      />
      <Route
        path="/admin-settings"
        element={(
          <AdminSettingsRoute>
            <AdminSettingsPage />
          </AdminSettingsRoute>
        )}
      />
      <Route path="/not-found" element={<NotFoundPage />} />
      <Route path="*" element={<NotFoundPage />} />
    </Routes>
  );
}

export default function App() {
  return (
    <AuthProvider>
      <AppDataProvider>
        <AlertProvider>
        <HashRouter>
          <AppRoutes />
        </HashRouter>
      </AlertProvider>
      </AppDataProvider>
    </AuthProvider>
  );
}



================================================
FILE: builder/src/app/main.jsx
================================================
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.jsx";
import "./theme/theme.css";
import "./theme/base.css";
import "./theme/preview-overrides.css";

// themesフォルダ内のすべてのCSSを自動的に読み込む
import.meta.glob('./theme/themes/*.css', { eager: true });
import { DEFAULT_THEME, initTheme } from "./theme/theme.js";

initTheme(DEFAULT_THEME);

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);



================================================
FILE: builder/src/app/components/AlertDialog.jsx
================================================
import React from "react";
import BaseDialog from "./BaseDialog.jsx";

export default function AlertDialog({ open, title = "通知", message, onClose }) {
  const footer = (
    <button type="button" className="dialog-btn primary" onClick={onClose}>
      OK
    </button>
  );

  return (
    <BaseDialog open={open} title={title} footer={footer}>
      {message && (
        typeof message === "string"
          ? <p className="dialog-message dialog-message-pre">{message}</p>
          : <div className="dialog-message">{message}</div>
      )}
    </BaseDialog>
  );
}



================================================
FILE: builder/src/app/components/AppLayout.jsx
================================================
import React from "react";
import { useNavigate } from "react-router-dom";
import { useEffect } from "react";
import { useBuilderSettings } from "../../features/settings/settingsStore.js";
import { DEFAULT_THEME, applyThemeWithFallback } from "../theme/theme.js";

export default function AppLayout({ themeOverride, title, fallbackPath = "/", onBack, backHidden = false, actions, sidebarActions, badge, children }) {
  const navigate = useNavigate();
  const { settings } = useBuilderSettings();

  useEffect(() => {
    const themeToApply = themeOverride || settings?.theme || DEFAULT_THEME;
    void applyThemeWithFallback(themeToApply, { persist: false });
  }, [themeOverride, settings?.theme]);

  const resolveTarget = (input) => {
    if (!input) return null;
    if (typeof input === "function") return resolveTarget(input());
    if (typeof input === "string") {
      return { to: input, options: { replace: true } };
    }
    if (typeof input === "object") {
      const to = input.to || input.path || input.pathname;
      if (!to) return null;
      const { replace = true, state } = input;
      return { to, options: { replace, state } };
    }
    return null;
  };

  const handleBack = async () => {
    if (onBack) {
      const result = await onBack({ fallbackPath, navigate });
      if (result === false) return;
      const resolved = resolveTarget(result);
      if (resolved) {
        navigate(resolved.to, resolved.options);
        return;
      }
    }
    const fallback = resolveTarget(fallbackPath);
    if (fallback) {
      navigate(fallback.to, fallback.options);
    }
  };

  const backButton = !backHidden && (
    <button type="button" onClick={handleBack} className="app-back-btn">
      <span className="nf-text-14">←</span>
      <span className="nf-ml-4">戻る</span>
    </button>
  );

  const resolvedBadge = typeof badge === "string" ? { label: badge } : badge;

  return (
    <div className="app-root">
      <header className="app-header">
        <div className="app-header-left">
          <h1 className="app-header-title">{title}</h1>
          {resolvedBadge?.label && (
            <span className="app-badge" data-variant={resolvedBadge?.variant || "view"}>
              {resolvedBadge.label}
            </span>
          )}
        </div>
        <div>{actions}</div>
      </header>
      <div className="app-container">
        {(sidebarActions || backButton) && (
          <aside className="app-sidebar">
            {backButton}
            {sidebarActions}
          </aside>
        )}
        <main className="app-main">{children}</main>
      </div>
    </div>
  );
}



================================================
FILE: builder/src/app/components/BaseDialog.jsx
================================================
import React from "react";

export default function BaseDialog({ open, title, children, footer }) {
  if (!open) return null;
  return (
    <div className="dialog-overlay" role="dialog" aria-modal="true" aria-labelledby="dialog-title">
      <div className="dialog-panel">
        {title && <h2 id="dialog-title" className="dialog-title">{title}</h2>}
        {children}
        {footer && <div className="dialog-footer">{footer}</div>}
      </div>
    </div>
  );
}



================================================
FILE: builder/src/app/components/ConfirmDialog.jsx
================================================
import React from "react";
import BaseDialog from "./BaseDialog.jsx";

const getVariantClass = (variant) => {
  if (variant === "primary") return "primary";
  if (variant === "danger") return "danger";
  return "";
};

export default function ConfirmDialog({ open, title, message, options = [] }) {
  const footer = options.map((option) => (
    <button
      key={option.value}
      type="button"
      className={`dialog-btn ${getVariantClass(option.variant)}`}
      onClick={option.onSelect}
    >
      {option.label}
    </button>
  ));

  return (
    <BaseDialog open={open} title={title} footer={footer}>
      {message && <p className="dialog-message">{message}</p>}
    </BaseDialog>
  );
}



================================================
FILE: builder/src/app/hooks/useAlert.js
================================================
import { useContext } from "react";
import { AlertContext } from "../state/AlertProvider.jsx";

export function useAlert() {
  const ctx = useContext(AlertContext);
  if (!ctx) throw new Error("useAlert must be used within AlertProvider");
  return ctx;
}



================================================
FILE: builder/src/app/hooks/useBeforeUnloadGuard.js
================================================
import { useEffect } from "react";

/**
 * isDirty が true のとき、ページ離脱前に確認ダイアログを表示する
 * @param {boolean} isDirty
 */
export function useBeforeUnloadGuard(isDirty) {
  useEffect(() => {
    const handleBeforeUnload = (event) => {
      if (!isDirty) return;
      event.preventDefault();
      event.returnValue = "";
    };
    window.addEventListener("beforeunload", handleBeforeUnload);
    return () => window.removeEventListener("beforeunload", handleBeforeUnload);
  }, [isDirty]);
}



================================================
FILE: builder/src/app/state/AlertProvider.jsx
================================================
import React, { createContext, useCallback, useMemo, useState } from "react";
import AlertDialog from "../components/AlertDialog.jsx";

export const AlertContext = createContext(null);

export function AlertProvider({ children }) {
  const [alertState, setAlertState] = useState({ open: false, title: "", message: "" });

  const showAlert = useCallback((message, title = "通知") => {
    const normalizedMessage =
      message === undefined || message === null
        ? ""
        : typeof message === "string" || typeof message === "number"
          ? String(message)
          : message;
    setAlertState({
      open: true,
      title,
      message: normalizedMessage,
    });
  }, []);

  const closeAlert = useCallback(() => {
    setAlertState({ open: false, title: "", message: "" });
  }, []);

  const value = useMemo(
    () => ({ alertState, showAlert, closeAlert }),
    [alertState, showAlert, closeAlert],
  );

  return (
    <AlertContext.Provider value={value}>
      {children}
      <AlertDialog
        open={alertState.open}
        title={alertState.title}
        message={alertState.message}
        onClose={closeAlert}
      />
    </AlertContext.Provider>
  );
}



================================================
FILE: builder/src/app/state/AppDataProvider.jsx
================================================
import React, { createContext, useCallback, useContext, useEffect, useMemo, useRef, useState } from "react";
import { dataStore } from "./dataStore.js";
import { getFormsFromCache, saveFormsToCache } from "./formsCache.js";
import { useAuth } from "./authContext.jsx";
import {
  evaluateCache,
  FORM_CACHE_MAX_AGE_MS,
  FORM_CACHE_BACKGROUND_REFRESH_MS,
} from "./cachePolicy.js";
import { perfLogger } from "../../utils/perfLogger.js";
import { normalizeFormRecord } from "../../utils/formNormalize.js";

const AppDataContext = createContext(null);

/**
 * Helper to save forms cache with consistent error handling
 */
const saveCacheWithErrorHandling = async (forms, loadFailures, setCacheDisabled, propertyStoreMode, logPrefix = "saveCache") => {
  try {
    await saveFormsToCache(forms, loadFailures, propertyStoreMode);
    console.log(`[${logPrefix}] Cache updated`);
  } catch (err) {
    console.warn(`[${logPrefix}] Failed to update cache:`, err);
    setCacheDisabled(true);
  }
};
export function AppDataProvider({ children }) {
  const { propertyStoreMode } = useAuth();
  const propertyStoreModeRef = useRef(propertyStoreMode);

  const [forms, setForms] = useState([]);
  const [loadingForms, setLoadingForms] = useState(true);
  const [error, setError] = useState(null);
  const [loadFailures, setLoadFailures] = useState([]);
  const [lastSyncedAt, setLastSyncedAt] = useState(null);
  const [cacheDisabled, setCacheDisabled] = useState(false);

  // キャッシュ更新用にformsとloadFailuresの最新値を保持
  const formsRef = useRef(forms);
  const loadFailuresRef = useRef(loadFailures);

  useEffect(() => {
    formsRef.current = forms;
  }, [forms]);

  useEffect(() => {
    loadFailuresRef.current = loadFailures;
  }, [loadFailures]);

  const refreshForms = useCallback(async ({ reason = "unknown", background = false } = {}) => {
    if (!background) {
      setLoadingForms(true);
    }
    setError(null);
    const startedAt = Date.now();
    perfLogger.logVerbose("forms", "refresh start", { reason, background, startedAt });

    try {
      const apiCallStart = Date.now();
      const result = await dataStore.listForms({ includeArchived: true });

      const apiCallEnd = Date.now();
      const apiCallDuration = apiCallEnd - apiCallStart;

      const allForms = result.forms || [];
      const failures = result.loadFailures || [];

      const averagePerForm = allForms.length > 0 ? Math.round(apiCallDuration / allForms.length) : 0;

      perfLogger.logVerbose("forms", "api call done", {
        apiDurationMs: apiCallDuration,
        count: allForms.length,
        avgPerFormMs: averagePerForm,
      });
      perfLogger.logFormGasRead(apiCallDuration, allForms.length);

      setForms(allForms);
      setLoadFailures(failures);
      const syncedAt = Date.now();
      setLastSyncedAt(syncedAt);

      try {
        const cacheStart = Date.now();
        await saveFormsToCache(allForms, failures, propertyStoreModeRef.current);
        const cacheDuration = Date.now() - cacheStart;
        perfLogger.logFormCacheSave(cacheDuration, allForms.length);
        setCacheDisabled(false);
        perfLogger.logVerbose("forms", "saved to cache", { cacheDurationMs: cacheDuration, count: allForms.length });
      } catch (cacheErr) {
        console.warn("[AppDataProvider] Failed to save to cache:", cacheErr);
        setCacheDisabled(true);
      }

      const finishedAt = Date.now();
      const totalDuration = finishedAt - startedAt;

      perfLogger.logVerbose("forms", "refresh timing", {
        totalDurationMs: totalDuration,
        apiSharePct: Math.round(apiCallDuration / totalDuration * 100),
      });
      perfLogger.logVerbose("forms", "refresh success", {
        reason,
        formCount: allForms.length,
        loadFailures: failures.length,
        finishedAt,
      });
    } catch (err) {
      console.error("[AppDataProvider] フォーム取得エラー:", err);
      setError(err.message || "フォームの取得に失敗しました");
      const finishedAt = Date.now();
      perfLogger.logVerbose("forms", "refresh fail", { reason, startedAt, finishedAt, error: err?.message });
    } finally {
      if (!background) {
        setLoadingForms(false);
      }
    }
  }, []);

  useEffect(() => {
    // 起動時の読み込みロジック
    (async () => {
      const startedAt = Date.now();
      console.log("[AppDataProvider] Startup - checking cache...");
      let cacheApplied = false;
      let cachedForms = [];
      let cachedFailures = [];
      let cacheLastSyncedAt = null;

      try {
        // 1. キャッシュから即座に表示
        const cacheResult = await getFormsFromCache();
        cachedForms = cacheResult.forms || [];
        cachedFailures = cacheResult.loadFailures || [];
        cacheLastSyncedAt = cacheResult.lastSyncedAt || cacheResult.cacheTimestamp || null;
        const cachedPropertyStoreMode = cacheResult.propertyStoreMode || "";
        const cacheAge = cacheLastSyncedAt ? Date.now() - cacheLastSyncedAt : null;
        const hasCachedData = cachedForms.length > 0 || cachedFailures.length > 0 || !!cacheLastSyncedAt;

        // プロパティ保存モードが変わった場合はキャッシュを無効化して強制再同期
        if (hasCachedData && cachedPropertyStoreMode !== propertyStoreModeRef.current) {
          console.log("[AppDataProvider] Property store mode changed; forcing fresh sync", {
            cachedMode: cachedPropertyStoreMode,
            currentMode: propertyStoreModeRef.current,
          });
          await refreshForms({ reason: "mode-changed", background: false });
          setLoadingForms(false);
          return;
        }

        if (hasCachedData) {
          console.log("[AppDataProvider] Loaded from cache:", cachedForms.length, "forms (age:", cacheAge, "ms)");
          perfLogger.logFormCacheHit(cacheAge || 0, cachedForms.length);
          setForms(cachedForms);
          setLoadFailures(cachedFailures);
          setLastSyncedAt(cacheLastSyncedAt);
          cacheApplied = true;
        }

        const { age: cacheAgeMs, shouldSync, shouldBackground } = evaluateCache({
          lastSyncedAt: cacheLastSyncedAt,
          hasData: hasCachedData,
          maxAgeMs: FORM_CACHE_MAX_AGE_MS,
          backgroundAgeMs: FORM_CACHE_BACKGROUND_REFRESH_MS,
        });

        perfLogger.logVerbose("forms", "cache check", {
          cacheAgeMs,
          cacheApplied,
          shouldSync,
          shouldBackground,
        });

        if (shouldSync) {
          console.log("[AppDataProvider] Cache stale or missing; fetching synchronously", { cacheAgeMs, cacheLastSyncedAt, hasCachedData });
          await refreshForms({ reason: "startup-sync", background: false });
          setLoadingForms(false);
          return;
        }

        // cache is fresh enough for sync, stop loading spinner
        setLoadingForms(false);

        if (shouldBackground) {
          console.log("[AppDataProvider] Cache is fresh enough; background refresh scheduled");
          refreshForms({ reason: "startup-background", background: true }).catch((err) => {
            console.error("[AppDataProvider] Background refresh error:", err);
            setError(err.message || "フォームの取得に失敗しました");
          });
        }

        const finishedAt = Date.now();
        console.log("[AppDataProvider] Startup complete in", finishedAt - startedAt, "ms");
      } catch (err) {
        console.error("[AppDataProvider] Startup error:", err);
        setError(err.message || "フォームの取得に失敗しました");
        setCacheDisabled(true);
      } finally {
        if (!cacheApplied) {
          setLoadingForms(false);
        }
      }
    })();
  }, []);

  const upsertFormsState = useCallback(async (nextForm) => {
    if (!nextForm || !nextForm.id) return;
    let updatedForms;
    setForms((prev) => {
      const next = prev.slice();
      const index = next.findIndex((form) => form.id === nextForm.id);
      if (index === -1) {
        next.unshift(nextForm);
      } else {
        next[index] = nextForm;
      }
      updatedForms = next;
      return next;
    });

    // キャッシュ更新の完了を待つ
    await saveCacheWithErrorHandling(updatedForms, loadFailuresRef.current, setCacheDisabled, propertyStoreModeRef.current, "upsertFormsState");
  }, []);

  const removeFormsState = useCallback(async (formIds) => {
    if (!Array.isArray(formIds) || formIds.length === 0) return;
    const targetIdSet = new Set(formIds.filter(Boolean));
    if (!targetIdSet.size) return;

    const nextForms = formsRef.current.filter((form) => !targetIdSet.has(form.id));
    const nextLoadFailures = loadFailuresRef.current.filter((failure) => !targetIdSet.has(failure.id));

    setForms(nextForms);
    setLoadFailures(nextLoadFailures);

    formsRef.current = nextForms;
    loadFailuresRef.current = nextLoadFailures;

    // キャッシュ更新の完了を待つ
    await saveCacheWithErrorHandling(nextForms, nextLoadFailures, setCacheDisabled, propertyStoreModeRef.current, "removeFormsState");
  }, []);

  const createForm = useCallback(async (payload, targetUrl, saveMode = "auto") => {
    const optimisticForm = normalizeFormRecord(payload, { preserveUnknownFields: true });
    await upsertFormsState(optimisticForm);

    void dataStore.createForm({ ...payload, id: optimisticForm.id, createdAt: optimisticForm.createdAt }, targetUrl, saveMode)
      .then((savedForm) => upsertFormsState(savedForm))
      .catch((err) => {
        console.error("[AppDataProvider] Background createForm failed:", err);
      });

    return optimisticForm;
  }, [upsertFormsState]);

  const updateForm = useCallback(async (formId, updates, targetUrl, saveMode = "auto") => {
    const existing = formsRef.current.find((form) => form.id === formId) || {};
    const optimisticForm = normalizeFormRecord({
      ...existing,
      ...updates,
      id: formId,
      createdAt: existing.createdAt,
      createdAtUnixMs: existing.createdAtUnixMs,
    }, {
      fallbackId: formId,
      fallbackCreatedAt: existing.createdAt || existing.createdAtUnixMs,
      preserveUnknownFields: true,
    });

    await upsertFormsState(optimisticForm);

    void dataStore.updateForm(formId, updates, targetUrl, saveMode)
      .then((savedForm) => upsertFormsState(savedForm))
      .catch((err) => {
        console.error("[AppDataProvider] Background updateForm failed:", err);
      });

    return optimisticForm;
  }, [upsertFormsState]);

  const archiveForm = useCallback(async (formId) => {
    const existing = formsRef.current.find((form) => form.id === formId) || null;
    const optimisticForm = existing ? { ...existing, archived: true } : null;

    if (optimisticForm) {
      await upsertFormsState(optimisticForm);
    }

    void dataStore.archiveForm(formId)
      .then((result) => {
        if (result) {
          upsertFormsState(result);
        }
      })
      .catch((err) => {
        console.error("[AppDataProvider] Background archiveForm failed:", err);
      });

    return optimisticForm;
  }, [upsertFormsState]);

  const unarchiveForm = useCallback(async (formId) => {
    const existing = formsRef.current.find((form) => form.id === formId) || null;
    const optimisticForm = existing ? { ...existing, archived: false } : null;

    if (optimisticForm) {
      await upsertFormsState(optimisticForm);
    }

    void dataStore.unarchiveForm(formId)
      .then((result) => {
        if (result) {
          upsertFormsState(result);
        }
      })
      .catch((err) => {
        console.error("[AppDataProvider] Background unarchiveForm failed:", err);
      });

    return optimisticForm;
  }, [upsertFormsState]);

  const batchUpdateFormsState = useCallback(async (dataStoreFn, formIds, archived, logPrefix) => {
    const targetIds = Array.isArray(formIds) ? formIds.filter(Boolean) : [formIds].filter(Boolean);
    if (!targetIds.length) return { forms: [], updated: 0, errors: [] };

    const targetIdSet = new Set(targetIds);
    const optimisticForms = formsRef.current
      .filter((form) => targetIdSet.has(form.id))
      .map((form) => ({ ...form, archived }));

    if (optimisticForms.length > 0) {
      let updatedForms;
      setForms((prev) => {
        const next = prev.slice();
        optimisticForms.forEach((form) => {
          const index = next.findIndex((f) => f.id === form.id);
          if (index !== -1) {
            next[index] = form;
          }
        });
        updatedForms = next;
        return next;
      });

      formsRef.current = updatedForms;
      await saveCacheWithErrorHandling(updatedForms, loadFailuresRef.current, setCacheDisabled, propertyStoreModeRef.current, `${logPrefix}:optimistic`);
    }

    void dataStoreFn(targetIds)
      .then(async (result) => {
        if (!result?.forms || !Array.isArray(result.forms) || result.forms.length === 0) return;

        let updatedForms;
        setForms((prev) => {
          const next = prev.slice();
          result.forms.forEach((form) => {
            const index = next.findIndex((f) => f.id === form.id);
            if (index !== -1) {
              next[index] = form;
            }
          });
          updatedForms = next;
          return next;
        });

        formsRef.current = updatedForms;
        await saveCacheWithErrorHandling(updatedForms, loadFailuresRef.current, setCacheDisabled, propertyStoreModeRef.current, `${logPrefix}:background`);
      })
      .catch((err) => {
        console.error(`[AppDataProvider] Background ${logPrefix} failed:`, err);
      });

    return { forms: optimisticForms, updated: optimisticForms.length, errors: [] };
  }, []);

  const archiveForms = useCallback(
    (formIds) => batchUpdateFormsState(dataStore.archiveForms.bind(dataStore), formIds, true, "archiveForms"),
    [batchUpdateFormsState],
  );

  const unarchiveForms = useCallback(
    (formIds) => batchUpdateFormsState(dataStore.unarchiveForms.bind(dataStore), formIds, false, "unarchiveForms"),
    [batchUpdateFormsState],
  );

  const deleteForms = useCallback(async (formIds) => {
    await removeFormsState(formIds);

    void dataStore.deleteForms(formIds).catch((err) => {
      console.error("[AppDataProvider] Background deleteForms failed:", err);
    });
  }, [removeFormsState]);

  const deleteForm = useCallback((formId) => deleteForms([formId]), [deleteForms]);

  const importForms = useCallback(async (jsonList) => {
    const created = await dataStore.importForms(jsonList);
    if (Array.isArray(created)) {
      // 複数フォームを一括追加してキャッシュも1回だけ更新
      setForms((prev) => {
        const next = [...created, ...prev];

        // キャッシュ更新
        saveCacheWithErrorHandling(next, loadFailuresRef.current, setCacheDisabled, propertyStoreModeRef.current, "importForms");

        return next;
      });
    }
    return created;
  }, []);

  const exportForms = useCallback(async (formIds) => dataStore.exportForms(formIds), []);
  const getFormById = useCallback((formId) => forms.find((form) => form.id === formId) || null, [forms]);

  const registerImportedForm = useCallback(async (payload) => {
    const result = await dataStore.registerImportedForm(payload);
    if (result) {
      await upsertFormsState(result);
    }
    return result;
  }, [upsertFormsState]);

  const memoValue = useMemo(
    () => ({
      forms,
      loadFailures,
      loadingForms,
      error,
      lastSyncedAt,
      cacheDisabled,
      refreshForms,
      createForm,
      updateForm,
      archiveForm,
      unarchiveForm,
      archiveForms,
      unarchiveForms,
      deleteForms,
      deleteForm,
      importForms,
      exportForms,
      getFormById,
      registerImportedForm,
    }),
    [forms, loadFailures, loadingForms, error, lastSyncedAt, cacheDisabled, refreshForms, createForm, updateForm, archiveForm, unarchiveForm, archiveForms, unarchiveForms, deleteForms, deleteForm, importForms, exportForms, getFormById, registerImportedForm],
  );

  return <AppDataContext.Provider value={memoValue}>{children}</AppDataContext.Provider>;
}

export function useAppData() {
  const ctx = useContext(AppDataContext);
  if (!ctx) throw new Error("useAppData must be used within AppDataProvider");
  return ctx;
}



================================================
FILE: builder/src/app/state/authContext.jsx
================================================
import React, { createContext, useContext, useMemo } from "react";

/**
 * 認証コンテキスト
 * GASから注入されたグローバル変数を読み取り、管理者判定とフォームIDを提供
 */
const AuthContext = createContext({
  isAdmin: true,
  formId: "",
  authError: "",
  userEmail: "",
  userName: "",
  propertyStoreMode: "script",
  adminSettingsEnabled: true,
});

/**
 * 認証プロバイダー
 * window.__IS_ADMIN__ と window.__FORM_ID__ と window.__AUTH_ERROR__ を読み取る
 */
export function AuthProvider({ children }) {
  const value = useMemo(() => {
    // GASから注入されたグローバル変数を読み取る
    // 未定義の場合はデフォルトで管理者モード（開発環境用）
    const isAdmin = typeof window !== "undefined" && window.__IS_ADMIN__ !== undefined
      ? Boolean(window.__IS_ADMIN__)
      : true;

    const formId = typeof window !== "undefined" && window.__FORM_ID__
      ? String(window.__FORM_ID__)
      : "";

    const authError = typeof window !== "undefined" && window.__AUTH_ERROR__
      ? String(window.__AUTH_ERROR__)
      : "";

    const userEmail = typeof window !== "undefined" && window.__USER_EMAIL__
      ? String(window.__USER_EMAIL__)
      : "";

    const userName = typeof window !== "undefined" && window.__USER_NAME__
      ? String(window.__USER_NAME__)
      : "";

    const propertyStoreMode = typeof window !== "undefined" && window.__PROPERTY_STORE_MODE__
      ? String(window.__PROPERTY_STORE_MODE__)
      : "script";

    const adminSettingsEnabled = typeof window !== "undefined" && window.__ADMIN_SETTINGS_ENABLED__ !== undefined
      ? Boolean(window.__ADMIN_SETTINGS_ENABLED__)
      : true;

    return { isAdmin, formId, authError, userEmail, userName, propertyStoreMode, adminSettingsEnabled };
  }, []);

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

/**
 * 認証情報を取得するフック
 * @returns {{ isAdmin: boolean, formId: string, authError: string, userEmail: string, userName: string, propertyStoreMode: string, adminSettingsEnabled: boolean }}
 */
export function useAuth() {
  return useContext(AuthContext);
}



================================================
FILE: builder/src/app/state/cachePolicy.js
================================================
// Shared cache policy for forms and records
// SWR: show cache immediately, sync when stale, background refresh when older than background threshold

import {
  RECORD_CACHE_MAX_AGE_MS,
  RECORD_CACHE_BACKGROUND_REFRESH_MS,
  FORM_CACHE_MAX_AGE_MS,
  FORM_CACHE_BACKGROUND_REFRESH_MS,
} from "../../core/constants.js";

export {
  RECORD_CACHE_MAX_AGE_MS,
  RECORD_CACHE_BACKGROUND_REFRESH_MS,
  FORM_CACHE_MAX_AGE_MS,
  FORM_CACHE_BACKGROUND_REFRESH_MS,
};

export const evaluateCache = ({
  lastSyncedAt,
  hasData,
  forceSync = false,
  maxAgeMs = RECORD_CACHE_MAX_AGE_MS,
  backgroundAgeMs = RECORD_CACHE_BACKGROUND_REFRESH_MS,
}) => {
  const age = lastSyncedAt ? Date.now() - lastSyncedAt : Infinity;
  const shouldSync = forceSync || !hasData || age >= maxAgeMs;
  const shouldBackground = !shouldSync && age >= backgroundAgeMs;
  return { age, shouldSync, shouldBackground };
};



================================================
FILE: builder/src/app/state/dataStore.js
================================================
import { stripSchemaIDs, deepClone } from "../../core/schema.js";
import { genId } from "../../core/ids.js";
import { collectDisplayFieldSettings } from "../../utils/formPaths.js";
import { normalizeFormRecord } from "../../utils/formNormalize.js";
import {
  getCachedEntryWithIndex,
  saveRecordsToCache,
  upsertRecordInCache,
  updateRecordsMeta,
  deleteRecordFromCache,
} from "./recordsCache.js";
import { getFormsFromCache } from "./formsCache.js";
import {
  evaluateCache,
  RECORD_CACHE_MAX_AGE_MS,
  RECORD_CACHE_BACKGROUND_REFRESH_MS,
} from "./cachePolicy.js";
import {
  deleteEntry as deleteEntryFromGas,
  listEntries as listEntriesFromGas,
  getEntry as getEntryFromGas,
  listForms as listFormsFromGas,
  getForm as getFormFromGas,
  saveForm as saveFormToGas,
  deleteFormFromDrive as deleteFormFromGas,
  deleteFormsFromDrive as deleteFormsFromGas,
  archiveForm as archiveFormInGas,
  unarchiveForm as unarchiveFormInGas,
  archiveForms as archiveFormsInGas,
  unarchiveForms as unarchiveFormsInGas,
  hasScriptRun,
  debugGetMapping,
  registerImportedForm as registerImportedFormInGas,
} from "../../services/gasClient.js";
import { perfLogger } from "../../utils/perfLogger.js";
import { toUnixMs } from "../../utils/dateTime.js";
import { DEFAULT_SHEET_NAME } from "../../core/constants.js";

const nowSerial = () => toUnixMs(Date.now());

const ensureDisplayInfo = (form) => {
  const schema = Array.isArray(form?.schema) ? form.schema : [];
  const displayFieldSettings = collectDisplayFieldSettings(schema);
  return {
    ...form,
    displayFieldSettings,
    importantFields: displayFieldSettings.map((item) => item.path),
  };
};

const getSheetConfig = (form) => {
  const spreadsheetId = form?.settings?.spreadsheetId;
  if (!spreadsheetId) return null;

  return {
    spreadsheetId,
    sheetName: form?.settings?.sheetName || DEFAULT_SHEET_NAME,
  };
};

const mapSheetRecordToEntry = (record, formId) => ({
  id: record.id,
  "No.": record["No."],
  modifiedBy: record.modifiedBy || "",
  createdBy: record.createdBy || "",
  formId,
  createdAt: record.createdAt,
  modifiedAt: record.modifiedAt,
  createdAtUnixMs: record.createdAtUnixMs ?? null,
  modifiedAtUnixMs: record.modifiedAtUnixMs ?? null,
  data: record.data || {},
  dataUnixMs: record.dataUnixMs || {},
  order: Object.keys(record.data || {}),
});

export const dataStore = {
  async listForms({ includeArchived = false } = {}) {
    if (!hasScriptRun()) {
      throw new Error("GAS unavailable");
    }

    const result = await listFormsFromGas({ includeArchived });
    const forms = Array.isArray(result.forms) ? result.forms : [];
    const loadFailures = Array.isArray(result.loadFailures) ? result.loadFailures : [];
    console.log("[dataStore.listForms] Fetched from GAS:", {
      count: forms.length,
      formIds: forms.map((f) => f.id),
      loadFailures: loadFailures.length,
    });
    return {
      forms: forms.map((form) => ensureDisplayInfo(form)),
      loadFailures,
      source: "gas",
    };
  },
  async getForm(formId) {
    try {
      const { forms = [] } = await getFormsFromCache();
      const cachedForm = forms.find((form) => form.id === formId);
      if (cachedForm) {
        return ensureDisplayInfo(cachedForm);
      }
    } catch (error) {
      console.warn("[dataStore.getForm] Cache lookup failed, falling back to GAS:", error);
    }

    if (!hasScriptRun()) {
      throw new Error("GAS unavailable");
    }
    const form = await getFormFromGas(formId);
    return form ? ensureDisplayInfo(form) : null;
  },
  async createForm(payload, targetUrl = null, saveMode = "auto") {
    // normalizeFormRecordにID生成を委ねる（payloadにidがあればそれを使用、なければ生成）
    const record = normalizeFormRecord(payload);
    console.log("[dataStore.createForm] Creating form:", { id: record.id, hasPayloadId: !!payload.id, targetUrl });

    // Try to save to Google Drive via GAS
    if (!hasScriptRun()) {
      throw new Error("GAS unavailable");
    }

    // Debug: 保存前のマッピングを取得
    let beforeMapping = null;
    try {
      beforeMapping = await debugGetMapping();
      console.log("[DEBUG] BEFORE createForm - Mapping:", beforeMapping);
      console.log("[DEBUG] BEFORE createForm - Legacy info:", JSON.stringify(beforeMapping?.legacyInfo, null, 2));
    } catch (debugErr) {
      console.warn("[DEBUG] Failed to get before-mapping:", debugErr);
    }

    const result = await saveFormToGas(record, targetUrl, saveMode);
    console.log("[dataStore.createForm] GAS result:", { formId: result?.form?.id, fileUrl: result?.fileUrl });
    console.log("[dataStore.createForm] GAS debugRawJsonBefore:", result?.debugRawJsonBefore);
    console.log("[dataStore.createForm] GAS debugRawJsonAfter:", result?.debugRawJsonAfter);
    console.log("[dataStore.createForm] GAS debugMappingStr:", result?.debugMappingStr);

    // Debug: 保存後のマッピングを取得
    try {
      const afterMapping = await debugGetMapping();
      console.log("[DEBUG] AFTER createForm - Mapping:", afterMapping);
      console.log("[DEBUG] Mapping changed from", beforeMapping?.totalForms, "to", afterMapping?.totalForms, "forms");
    } catch (debugErr) {
      console.warn("[DEBUG] Failed to get after-mapping:", debugErr);
    }

    const savedForm = result?.form || result;
    const fileUrl = result?.fileUrl;

    // fileUrlをフォームに保存
    const formWithUrl = { ...savedForm, driveFileUrl: fileUrl };
    return formWithUrl ? ensureDisplayInfo(formWithUrl) : record;
  },
  async registerImportedForm(payload) {
    // payload: { form, fileId, fileUrl }
    if (!hasScriptRun()) {
      throw new Error("GAS unavailable");
    }
    const result = await registerImportedFormInGas(payload);
    const form = result?.form;
    const fileUrl = result?.fileUrl || payload.fileUrl;
    return form ? ensureDisplayInfo({ ...form, driveFileUrl: fileUrl }) : null;
  },
  async updateForm(formId, updates, targetUrl = null, saveMode = "auto") {
    // First get the current form. If GAS fetch fails, fallback to provided updates.
    let current = null;
    try {
      current = await this.getForm(formId);
    } catch (error) {
      console.warn("[dataStore.updateForm] Failed to fetch current form, fallback to updates:", error);
    }

    if (!current) {
      if (updates?.id || updates?.schema || updates?.settings) {
        current = {
          id: formId,
          createdAt: updates.createdAt,
          archived: updates.archived,
          schemaVersion: updates.schemaVersion,
          driveFileUrl: updates.driveFileUrl,
          ...updates,
        };
      } else {
        throw new Error("Current form not found");
      }
    }

    const next = normalizeFormRecord({
      ...current,
      ...updates,
      id: current.id,
      createdAt: current.createdAt,
      archived: updates.archived ?? current.archived,
      schemaVersion: updates.schemaVersion ?? current.schemaVersion,
      driveFileUrl: current.driveFileUrl, // 既存のURLを保持
    });

    if (!hasScriptRun()) {
      throw new Error("GAS unavailable");
    }
    const result = await saveFormToGas(next, targetUrl, saveMode);
    const savedForm = result?.form || result;
    const fileUrl = result?.fileUrl;

    // fileUrlをフォームに保存（新しいURLが返された場合は更新）
    const formWithUrl = { ...savedForm, driveFileUrl: fileUrl || next.driveFileUrl };
    return formWithUrl ? ensureDisplayInfo(formWithUrl) : next;
  },
  async setFormArchivedState(formId, archived) {
    if (!hasScriptRun()) {
      throw new Error("GAS unavailable");
    }
    const savedForm = archived ? await archiveFormInGas(formId) : await unarchiveFormInGas(formId);
    return savedForm ? ensureDisplayInfo(savedForm) : null;
  },
  async archiveForm(formId) {
    return this.setFormArchivedState(formId, true);
  },
  async unarchiveForm(formId) {
    return this.setFormArchivedState(formId, false);
  },
  async _batchArchiveAction(formIds, gasFn) {
    const targetIds = Array.isArray(formIds) ? formIds.filter(Boolean) : [formIds].filter(Boolean);
    if (!targetIds.length) return { forms: [], updated: 0 };

    if (!hasScriptRun()) {
      throw new Error("GAS unavailable");
    }

    const result = await gasFn(targetIds);
    return {
      forms: (result.forms || []).map((form) => (form ? ensureDisplayInfo(form) : null)).filter(Boolean),
      updated: result.updated || 0,
      errors: result.errors || [],
    };
  },
  async archiveForms(formIds) {
    return this._batchArchiveAction(formIds, archiveFormsInGas);
  },
  async unarchiveForms(formIds) {
    return this._batchArchiveAction(formIds, unarchiveFormsInGas);
  },
  async deleteForms(formIds) {
    const targetIds = Array.isArray(formIds) ? formIds.filter(Boolean) : [formIds].filter(Boolean);
    if (!targetIds.length) return;

    if (!hasScriptRun()) {
      throw new Error("GAS unavailable");
    }

    await deleteFormsFromGas(targetIds);
  },
  async deleteForm(formId) {
    await this.deleteForms([formId]);
  },
  async upsertEntry(formId, payload) {
    const now = nowSerial();
    const createdAtSerial = Number.isFinite(payload.createdAt)
      ? payload.createdAt
      : (Number.isFinite(payload.createdAtUnixMs) ? payload.createdAtUnixMs : toUnixMs(payload.createdAt));
    const resolvedCreatedAt = Number.isFinite(createdAtSerial) ? createdAtSerial : now;
    const record = {
      id: payload.id || genId(),
      formId,
      createdBy: payload.createdBy || "",
      modifiedBy: payload.modifiedBy || "",
      createdAt: resolvedCreatedAt,
      createdAtUnixMs: resolvedCreatedAt,
      modifiedAt: now,
      modifiedAtUnixMs: now,
      data: payload.data || {},
      dataUnixMs: payload.dataUnixMs || {},
      order: payload.order || Object.keys(payload.data || {}),
    };
    await upsertRecordInCache(formId, record, { headerMatrix: payload.headerMatrix, rowIndex: payload.rowIndex });
    return record;
  },
  async listEntries(formId) {
    const form = await this.getForm(formId);
    const sheetConfig = getSheetConfig(form);
    if (!sheetConfig) {
      throw new Error("Spreadsheet not configured for this form");
    }
    const startedAt = Date.now();
    perfLogger.logVerbose("records", "listEntries start", { formId, sheet: sheetConfig.sheetName, startedAt });
    const gasResult = await listEntriesFromGas({ ...sheetConfig, formId });
    const entries = (gasResult.records || []).map((record) => mapSheetRecordToEntry(record, formId));

    // Sort by ID in ascending order when fetching from spreadsheet
    // (binary search in cache assumes ascending order)
    entries.sort((a, b) => {
      if (a.id < b.id) return -1;
      if (a.id > b.id) return 1;
      return 0;
    });
    const entryIndexMap = {};
    entries.forEach((item, idx) => {
      entryIndexMap[item.id] = idx;
    });

    const lastSyncedAt = Date.now();
    await saveRecordsToCache(formId, entries, gasResult.headerMatrix || [], { schemaHash: form.schemaHash });
    await updateRecordsMeta(formId, { entryIndexMap, lastReloadedAt: lastSyncedAt });
    const finishedAt = Date.now();
    const durationMs = finishedAt - startedAt;
    perfLogger.logVerbose("records", "listEntries done", { formId, count: entries.length, durationMs });
    perfLogger.logRecordGasRead(durationMs, null, "list");
    perfLogger.logRecordList(durationMs, entries.length, false);
    return { entries, headerMatrix: gasResult.headerMatrix || [], entryIndexMap, lastSyncedAt };
  },
  async getEntry(formId, entryId, { forceSync = false, rowIndexHint = undefined } = {}) {
    const form = await this.getForm(formId);
    const sheetConfig = getSheetConfig(form);
    if (!sheetConfig) {
      throw new Error("Spreadsheet not configured for this form");
    }

    const tGetCacheStart = performance.now();
    const { entry: cachedEntry, rowIndex: cachedRowIndex, lastSyncedAt } = await getCachedEntryWithIndex(formId, entryId);
    const tGetCacheEnd = performance.now();
    perfLogger.logVerbose("records", "getEntry cache lookup", {
      durationMs: Number((tGetCacheEnd - tGetCacheStart).toFixed(2)),
      formId,
      entryId,
    });

    // rowIndexHintが明示的に渡された場合はそれを優先、なければキャッシュから取得したものを使用
    const effectiveRowIndex = rowIndexHint !== undefined ? rowIndexHint : cachedRowIndex;

    const { age: cacheAge, shouldSync, shouldBackground } = evaluateCache({
      lastSyncedAt,
      hasData: !!cachedEntry,
      forceSync,
      maxAgeMs: RECORD_CACHE_MAX_AGE_MS,
      backgroundAgeMs: RECORD_CACHE_BACKGROUND_REFRESH_MS,
    });

    if (!shouldSync && cachedEntry) {
      if (shouldBackground) {
        const backgroundStart = Date.now();
        getEntryFromGas({
          ...sheetConfig,
          entryId,
          rowIndexHint: effectiveRowIndex,
        })
          .then((result) => {
            const backgroundDuration = Date.now() - backgroundStart;
            perfLogger.logRecordGasRead(backgroundDuration, entryId, "single-background");
            const mapped = result.record ? mapSheetRecordToEntry(result.record, formId) : null;
            if (!mapped) return;
            const nextRowIndex = typeof result.rowIndex === "number" ? result.rowIndex : effectiveRowIndex;
            upsertRecordInCache(formId, mapped, { rowIndex: nextRowIndex }).catch((err) => {
              console.error("[dataStore.getEntry] background cache update failed", err);
            });
          })
          .catch((error) => {
            console.error("[dataStore.getEntry] background getEntry failed", error);
          });
      }
      perfLogger.logVerbose("records", "getEntry cache hit", {
        formId,
        entryId,
        cacheAge,
        rowIndexHint: effectiveRowIndex,
      });
      perfLogger.logRecordCacheHit(tGetCacheEnd - tGetCacheStart, entryId);
      return cachedEntry;
    }

    const startedAt = Date.now();
    perfLogger.logVerbose("records", "getEntry start", { formId, entryId, rowIndexHint: effectiveRowIndex });

    const tBeforeGas = performance.now();
    const result = await getEntryFromGas({
      ...sheetConfig,
      entryId,
      rowIndexHint: effectiveRowIndex,
    });
    const tAfterGas = performance.now();
    perfLogger.logVerbose("records", "getEntry GAS fetch", {
      durationMs: Number((tAfterGas - tBeforeGas).toFixed(2)),
      formId,
      entryId,
    });

    const tBeforeMap = performance.now();
    const mapped = result.record ? mapSheetRecordToEntry(result.record, formId) : null;
    const tAfterMap = performance.now();
    perfLogger.logVerbose("records", "getEntry map record", {
      durationMs: Number((tAfterMap - tBeforeMap).toFixed(2)),
      formId,
      entryId,
    });

    if (mapped) {
      const nextRowIndex = typeof result.rowIndex === "number" ? result.rowIndex : effectiveRowIndex;
      const tBeforeUpsert = performance.now();
      await upsertRecordInCache(formId, mapped, { rowIndex: nextRowIndex });
      const tAfterUpsert = performance.now();
      perfLogger.logVerbose("records", "getEntry cache upsert", {
        durationMs: Number((tAfterUpsert - tBeforeUpsert).toFixed(2)),
        formId,
        entryId,
        rowIndex: nextRowIndex,
      });

      const finishedAt = Date.now();
      const durationMs = finishedAt - startedAt;
      perfLogger.logVerbose("records", "getEntry done", {
        formId,
        entryId,
        fromCache: false,
        durationMs,
        rowIndex: nextRowIndex,
      });
      perfLogger.logRecordGasRead(tAfterGas - tBeforeGas, entryId, "single-sync");
      perfLogger.logRecordCacheUpdate(tAfterUpsert - tBeforeUpsert, entryId);
      return mapped;
    }

    const finishedAt = Date.now();
    perfLogger.logVerbose("records", "getEntry done", {
      formId,
      entryId,
      fromCache: !!cachedEntry,
      durationMs: finishedAt - startedAt,
      fallbackCache: true,
    });
    if (cachedEntry) {
      perfLogger.logRecordCacheHit(tGetCacheEnd - tGetCacheStart, entryId);
    }
    return cachedEntry;
  },
  async deleteEntry(formId, entryId) {
    await deleteRecordFromCache(formId, entryId);

    const form = await this.getForm(formId);
    const sheetConfig = getSheetConfig(form);
    if (sheetConfig) {
      void deleteEntryFromGas({ ...sheetConfig, entryId }).catch((error) => {
        console.error("[dataStore.deleteEntry] Background GAS delete failed:", error);
      });
    }
  },
  async importForms(jsonList) {
    if (!hasScriptRun()) {
      throw new Error("GAS unavailable");
    }
    const created = [];
    for (const item of jsonList) {
      if (!item) continue;
      const record = normalizeFormRecord({
        ...item,
        createdAt: item.createdAt,
        schemaVersion: item.schemaVersion,
      });
      const result = await saveFormToGas(record);
      const savedForm = result?.form || result;
      created.push(ensureDisplayInfo(savedForm));
    }
    return created;
  },
  async exportForms(formIds) {
    // Get forms from GAS
    const { forms: allForms } = await this.listForms({ includeArchived: true });
    const selected = allForms.filter((form) => formIds.includes(form.id));

    return selected.map((form) => {
      const {
        id,
        schemaHash,
        importantFields,
        displayFieldSettings,
        createdAt,
        modifiedAt,
        archived,
        schemaVersion,
        ...rest
      } = form;
      // スキーマからもIDを除去
      const cleaned = {
        ...rest,
        schema: stripSchemaIDs(rest.schema || []),
      };
      return deepClone(cleaned);
    });
  },
};



================================================
FILE: builder/src/app/state/dbHelpers.js
================================================
/**
 * Shared IndexedDB helpers for formsCache and recordsCache
 */

import { DB_NAME, DB_VERSION, STORE_NAMES } from "../../core/constants.js";
export { STORE_NAMES };

/**
 * Open IndexedDB connection with all required stores
 * @returns {Promise<IDBDatabase>}
 */
export function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);

    request.onupgradeneeded = (event) => {
      const db = event.target.result;

      // Create formsCache store if it doesn't exist
      if (!db.objectStoreNames.contains(STORE_NAMES.forms)) {
        const store = db.createObjectStore(STORE_NAMES.forms, { keyPath: 'id' });
        // Index for quick access by archived status
        store.createIndex('archived', 'archived', { unique: false });
      }

      // Create/refresh recordsCache store with indexes for per-form lookups
      if (db.objectStoreNames.contains(STORE_NAMES.records)) {
        db.deleteObjectStore(STORE_NAMES.records);
      }
      const recordsStore = db.createObjectStore(STORE_NAMES.records, { keyPath: 'compoundId' });
      recordsStore.createIndex('formId', 'formId', { unique: false });
      recordsStore.createIndex('entryId', 'entryId', { unique: false });

      // Metadata store for recordsCache (per form)
      if (db.objectStoreNames.contains(STORE_NAMES.recordsMeta)) {
        db.deleteObjectStore(STORE_NAMES.recordsMeta);
      }
      db.createObjectStore(STORE_NAMES.recordsMeta, { keyPath: 'formId' });

      // Settings store
      if (!db.objectStoreNames.contains(STORE_NAMES.settings)) {
        db.createObjectStore(STORE_NAMES.settings, { keyPath: 'key' });
      }
    };
  });
}

/**
 * Promisify IDBRequest so we can await operations
 * @param {IDBRequest} request
 * @returns {Promise<any>}
 */
export const waitForRequest = (request) =>
  new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });

/**
 * Wait for a transaction to complete
 * @param {IDBTransaction} tx
 * @returns {Promise<void>}
 */
export const waitForTransaction = (tx) =>
  new Promise((resolve, reject) => {
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
    tx.onabort = () => reject(tx.error);
  });



================================================
FILE: builder/src/app/state/formsCache.js
================================================
/**
 * IndexedDB-based cache for forms list
 * Caches all forms to provide instant loading on subsequent visits
 */

import { openDB, waitForRequest, waitForTransaction, STORE_NAMES } from './dbHelpers.js';

const META_KEY = '__metadata__';

/**
 * Save all forms to IndexedDB cache
 * @param {Array} forms - Array of form objects
 * @param {Array} loadFailures - Array of load failure objects
 * @returns {Promise<void>}
 */
export async function saveFormsToCache(forms, loadFailures = [], propertyStoreMode = "") {
  const db = await openDB();
  const tx = db.transaction(STORE_NAMES.forms, 'readwrite');
  const store = tx.objectStore(STORE_NAMES.forms);

  // Clear existing data
  await waitForRequest(store.clear());

  // Insert all forms with cache metadata
  const lastSyncedAt = Date.now();
  for (const form of forms) {
    await waitForRequest(store.put({
      ...form,
      lastSyncedAt,
    }));
  }

  // Store metadata (always) so empty lists still carry timestamp/loadFailures
  await waitForRequest(store.put({
    id: META_KEY,
    lastSyncedAt,
    failures: loadFailures,
    propertyStoreMode,
  }));

  await waitForTransaction(tx);
  db.close();
  console.log('[formsCache] Saved', forms.length, 'forms and', loadFailures.length, 'failures to cache');
}

/**
 * Get all forms from IndexedDB cache
 * @returns {Promise<{forms: Array, loadFailures: Array, lastSyncedAt: number|null}>}
 */
export async function getFormsFromCache() {
  const db = await openDB();
  try {
    const tx = db.transaction(STORE_NAMES.forms, 'readonly');
    const store = tx.objectStore(STORE_NAMES.forms);
    const allRecords = (await waitForRequest(store.getAll())) || [];
    await waitForTransaction(tx);

    const forms = [];
    let loadFailures = [];
    let lastSyncedAt = null;
    let propertyStoreMode = "";

    for (const record of allRecords) {
      if (record.id === META_KEY) {
        loadFailures = record.failures || [];
        lastSyncedAt = record.lastSyncedAt || null;
        propertyStoreMode = record.propertyStoreMode || "";
      } else if (record.id !== undefined) {
        // Remove cache metadata before returning
        const { lastSyncedAt: _, ...form } = record;
        forms.push(form);
      }
    }

    console.log('[formsCache] Retrieved', forms.length, 'forms and', loadFailures.length, 'failures from cache');
    return { forms, loadFailures, lastSyncedAt, propertyStoreMode };
  } finally {
    db.close();
  }
}



================================================
FILE: builder/src/app/state/recordsCache.js
================================================
/**
 * IndexedDB-based cache for records data (per form)
 * - Uses indexes for quick lookup by formId and entryId
 * - Stores header metadata per form
 */

import { openDB, waitForRequest, waitForTransaction, STORE_NAMES } from './dbHelpers.js';

const buildCompoundId = (formId, entryId) => `${formId}::${entryId}`;

const stripMetadata = (record) => {
  if (!record) return null;
  const { compoundId, lastSyncedAt, entryId, ...rest } = record;
  return { ...rest, id: entryId };
};

const deleteEntriesForForm = (store, formId) =>
  new Promise((resolve, reject) => {
    const index = store.index('formId');
    const request = index.openKeyCursor(IDBKeyRange.only(formId));
    request.onsuccess = (event) => {
      const cursor = event.target.result;
      if (cursor) {
        store.delete(cursor.primaryKey);
        cursor.continue();
      } else {
        resolve();
      }
    };
    request.onerror = () => reject(request.error);
  });

const buildCacheRecord = (formId, record, lastSyncedAt, rowIndex) => ({
  ...record,
  compoundId: buildCompoundId(formId, record.id),
  formId,
  entryId: record.id,
  lastSyncedAt,
  rowIndex,
});

const buildEntryIndexMap = (records) => {
  const map = {};
  records.forEach((record, idx) => {
    if (record?.id) map[record.id] = idx;
  });
  return map;
};

/**
 * Build metadata object with defaults from existing metadata
 */
const buildMetadata = (formId, existingMeta, updates = {}) => {
  const now = Date.now();
  return {
    formId,
    lastSyncedAt: updates.lastSyncedAt ?? existingMeta?.lastSyncedAt ?? now,
    headerMatrix: updates.headerMatrix ?? existingMeta?.headerMatrix ?? [],
    schemaHash: updates.schemaHash ?? existingMeta?.schemaHash ?? null,
    entryIndexMap: updates.entryIndexMap ?? existingMeta?.entryIndexMap ?? {},
  };
};

/**
 * Save all records for a form to IndexedDB (replaces existing cache)
 * @param {string} formId
 * @param {Array} records
 * @param {Array} headerMatrix
 * @returns {Promise<void>}
 */
export async function saveRecordsToCache(formId, records, headerMatrix = [], { schemaHash = null } = {}) {
  if (!formId) return;
  const db = await openDB();
  const tx = db.transaction([STORE_NAMES.records, STORE_NAMES.recordsMeta], 'readwrite');
  const store = tx.objectStore(STORE_NAMES.records);
  const metaStore = tx.objectStore(STORE_NAMES.recordsMeta);

  const lastSyncedAt = Date.now();
  const entryIndexMap = buildEntryIndexMap(records || []);
  await deleteEntriesForForm(store, formId);

  for (let idx = 0; idx < records.length; idx++) {
    const record = records[idx];
    await waitForRequest(store.put(buildCacheRecord(formId, record, lastSyncedAt, idx)));
  }

  await waitForRequest(metaStore.put(buildMetadata(formId, null, {
    lastSyncedAt,
    headerMatrix,
    schemaHash,
    entryIndexMap,
  })));

  await waitForTransaction(tx);
  db.close();
}

/**
 * Update metadata only (entry index map / timestamp / schemaHash)
 */
export async function updateRecordsMeta(formId, { entryIndexMap, lastReloadedAt, schemaHash, headerMatrix } = {}) {
  if (!formId) return;
  const db = await openDB();
  const tx = db.transaction(STORE_NAMES.recordsMeta, 'readwrite');
  const metaStore = tx.objectStore(STORE_NAMES.recordsMeta);
  const existingMeta = await waitForRequest(metaStore.get(formId)).catch(() => null);

  await waitForRequest(metaStore.put(buildMetadata(formId, existingMeta, {
    lastSyncedAt: lastReloadedAt,
    headerMatrix,
    schemaHash,
    entryIndexMap,
  })));

  await waitForTransaction(tx);
  db.close();
}

/**
 * Save index map for a single entry id
 */
export async function updateEntryIndex(formId, entryId, rowIndex) {
  if (!formId || !entryId || rowIndex === undefined || rowIndex === null) return;
  const db = await openDB();
  const tx = db.transaction(STORE_NAMES.recordsMeta, 'readwrite');
  const metaStore = tx.objectStore(STORE_NAMES.recordsMeta);
  const existingMeta = await waitForRequest(metaStore.get(formId)).catch(() => null);

  const existingMap = existingMeta?.entryIndexMap || {};
  existingMap[entryId] = rowIndex;

  await waitForRequest(metaStore.put(buildMetadata(formId, existingMeta, {
    entryIndexMap: existingMap,
  })));

  await waitForTransaction(tx);
  db.close();
}

const binarySearchById = (entries, entryId) => {
  // Assumes entries are sorted ascending by id (ensured at fetch time)
  let low = 0;
  let high = entries.length - 1;
  while (low <= high) {
    const mid = Math.floor((low + high) / 2);
    const currentId = entries[mid]?.id;
    if (currentId === entryId) return mid;
    if (currentId < entryId) low = mid + 1;
    else high = mid - 1;
  }
  return -1;
};

/**
 * Get cached entry with row index (fast path using map, fallback to binary search)
 */
export async function getCachedEntryWithIndex(formId, entryId) {
  if (!formId || !entryId) return { entry: null, rowIndex: null };
  const { entries, cacheTimestamp, headerMatrix, schemaHash, lastSyncedAt, entryIndexMap } = await getRecordsFromCache(formId);
  let rowIndex = entryIndexMap?.[entryId];
  let entry = null;

  if (Number.isInteger(rowIndex) && rowIndex >= 0 && rowIndex < entries.length) {
    entry = entries[rowIndex];
    if (entry?.id !== entryId) {
      entry = null;
      rowIndex = null;
    }
  }

  if (!entry) {
    const foundIndex = binarySearchById(entries, entryId);
    if (foundIndex !== -1) {
      entry = entries[foundIndex];
      rowIndex = foundIndex;
      await updateEntryIndex(formId, entryId, foundIndex);
    }
  }

  return { entry, rowIndex, cacheTimestamp, headerMatrix, schemaHash, lastSyncedAt, entryIndexMap };
}

/**
 * Upsert a single record into cache (keeps existing headerMatrix/index map/schemaHash)
 */
export async function upsertRecordInCache(formId, record, { headerMatrix, rowIndex, schemaHash } = {}) {
  if (!formId || !record?.id) return;
  const db = await openDB();
  const tx = db.transaction([STORE_NAMES.records, STORE_NAMES.recordsMeta], 'readwrite');
  const store = tx.objectStore(STORE_NAMES.records);
  const metaStore = tx.objectStore(STORE_NAMES.recordsMeta);

  const lastSyncedAt = Date.now();
  const existingMeta = await waitForRequest(metaStore.get(formId)).catch(() => null);
  const nextRowIndex = Number.isInteger(rowIndex) ? rowIndex : existingMeta?.entryIndexMap?.[record.id];
  await waitForRequest(store.put(buildCacheRecord(formId, record, lastSyncedAt, nextRowIndex)));

  const updatedIndexMap = { ...(existingMeta?.entryIndexMap || {}) };
  if (Number.isInteger(nextRowIndex)) {
    updatedIndexMap[record.id] = nextRowIndex;
  }

  await waitForRequest(metaStore.put(buildMetadata(formId, existingMeta, {
    lastSyncedAt,
    headerMatrix,
    schemaHash,
    entryIndexMap: updatedIndexMap,
  })));

  await waitForTransaction(tx);
  db.close();
}

/**
 * Get all records for a form from IndexedDB
 * @param {string} formId
 * @returns {Promise<{entries: Array, headerMatrix: Array, cacheTimestamp: number|null, lastSyncedAt: number|null}>}
 */
export async function getRecordsFromCache(formId) {
  if (!formId) return { entries: [], headerMatrix: [], cacheTimestamp: null, schemaHash: null, lastSyncedAt: null, entryIndexMap: {} };
  const db = await openDB();
  const tx = db.transaction([STORE_NAMES.records, STORE_NAMES.recordsMeta], 'readonly');
  const store = tx.objectStore(STORE_NAMES.records);
  const metaStore = tx.objectStore(STORE_NAMES.recordsMeta);

  const entriesRequest = store.index('formId').getAll(IDBKeyRange.only(formId));
  const metaRequest = metaStore.get(formId);

  const [rawEntries, meta] = await Promise.all([
    waitForRequest(entriesRequest),
    waitForRequest(metaRequest).catch(() => null),
  ]);

  await waitForTransaction(tx);
  db.close();

  const entries = (rawEntries || []).map(stripMetadata);
  entries.sort((a, b) => {
    if (a?.id < b?.id) return -1;
    if (a?.id > b?.id) return 1;
    return 0;
  });
  return {
    entries,
    headerMatrix: meta?.headerMatrix || [],
    cacheTimestamp: meta?.lastSyncedAt || null,
    lastSyncedAt: meta?.lastSyncedAt || null,
    schemaHash: meta?.schemaHash || null,
    entryIndexMap: meta?.entryIndexMap || {},
  };
}

/**
 * Remove a single record from cache (removes only the deleted entry from index map)
 */
export async function deleteRecordFromCache(formId, entryId) {
  if (!formId || !entryId) return;
  const db = await openDB();
  const tx = db.transaction([STORE_NAMES.records, STORE_NAMES.recordsMeta], 'readwrite');
  const store = tx.objectStore(STORE_NAMES.records);
  const metaStore = tx.objectStore(STORE_NAMES.recordsMeta);

  await waitForRequest(store.delete(buildCompoundId(formId, entryId)));
  const existingMeta = await waitForRequest(metaStore.get(formId)).catch(() => null);

  // 削除対象のentryIdのみをindexMapから除去（他のエントリは保持）
  const updatedIndexMap = { ...(existingMeta?.entryIndexMap || {}) };
  delete updatedIndexMap[entryId];

  await waitForRequest(metaStore.put(buildMetadata(formId, existingMeta, {
    lastSyncedAt: Date.now(),
    entryIndexMap: updatedIndexMap,
  })));

  await waitForTransaction(tx);
  db.close();
}



================================================
FILE: builder/src/app/theme/base.css
================================================
/* Base styles: system + components */
* {
  box-sizing: border-box;
  font-family: var(--font-sans);
}

body {
  margin: 0;
  color: var(--text);
  background: var(--app-bg);
}

button,
input,
select,
textarea {
  font: inherit;
  color: inherit;
}

input:focus,
select:focus,
textarea:focus {
  border-color: var(--input-border-focus);
  box-shadow: 0 0 0 4px var(--input-focus-ring);
  outline: none;
}

button:disabled {
  cursor: not-allowed;
  opacity: 0.6;
}

/* Optional utility classes matching the balanced preview */
.header-bar {
  position: sticky;
  top: 0;
  z-index: 50;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  padding: 14px 18px;
  border-bottom: 1px solid var(--border);
  background: var(--app-header-bg);
  backdrop-filter: blur(10px);
}

.brand {
  display: flex;
  align-items: center;
  gap: 10px;
  min-width: 0;
}

.logo {
  width: 34px;
  height: 34px;
  border-radius: 12px;
  background: var(--logo-gradient);
  box-shadow: var(--logo-shadow);
}

.brand-title {
  font-size: 16px;
  margin: 0;
  font-weight: 750;
  letter-spacing: -0.01em;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.brand-sub {
  font-size: 12px;
  color: var(--text-muted);
  margin-top: 2px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.actions {
  display: flex;
  align-items: center;
  gap: 10px;
}

.btn {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 9px 12px;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: var(--surface);
  box-shadow: var(--shadow-sm);
  font-size: 12px;
  color: var(--text);
  user-select: none;
}

.btn.primary {
  border-color: var(--primary-border-soft);
  background: var(--btn-primary-bg);
}

.panel {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-sm);
  overflow: hidden;
}

.panel-h {
  padding: 14px 14px 10px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  background: var(--panel-header-bg);
  border-bottom: 1px solid var(--border);
}

.panel-h .title {
  font-weight: 750;
  font-size: 13px;
}

.panel-b {
  padding: 14px;
}

.card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-sm);
  padding: 16px;
  margin-bottom: 14px;
  position: relative;
  transition: transform 0.16s ease, box-shadow 0.16s ease, border-color 0.16s ease;
}

.card:hover {
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
  border-color: var(--card-hover-border);
}

.badge {
  flex: 0 0 auto;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 10px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 850;
  letter-spacing: 0.01em;
  color: var(--badge-text);
  background: var(--badge-primary-bg);
}

.badge.warm {
  background: var(--badge-warm-bg);
}

.badge.ghost {
  background: var(--badge-ghost-bg);
  color: var(--primary);
  border: 1px solid var(--badge-ghost-border);
  font-weight: 750;
}

.if-box {
  margin-top: 12px;
  border-radius: 14px;
  border: 1px solid var(--if-box-border);
  background: var(--if-box-bg);
  padding: 10px 12px;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}

.if-chip {
  padding: 3px 8px;
  border-radius: 999px;
  background: var(--if-chip-bg);
  border: 1px solid var(--if-chip-border);
  font-size: 11px;
  font-weight: 900;
  color: var(--warm-ink);
}

.if-badge {
  padding: 4px 10px;
  border-radius: 999px;
  background: var(--success-weak);
  border: 1px solid var(--if-badge-border);
  font-size: 11px;
  font-weight: 900;
  color: var(--success-ink);
  flex: 0 0 auto;
}

.small-note {
  margin-top: 10px;
  font-size: 12px;
  color: var(--text-muted);
}
/* Theme-driven component styles */

.app-root {
  min-height: 100vh;
  background: var(--app-bg);
  color: var(--text);
}

.app-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border);
  background: var(--app-header-bg);
}

.app-header-left {
  display: flex;
  align-items: center;
  gap: 12px;
}

.app-header-title {
  margin: 0;
  font-size: 18px;
}

.app-container {
  display: flex;
  height: calc(100vh - 49px);
}

.app-sidebar {
  width: 200px;
  background: var(--surface);
  border-right: 1px solid var(--border);
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.app-main {
  flex: 1;
  padding: 24px 16px;
  overflow-y: auto;
}

.app-back-btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border-radius: 8px;
  border: 1px solid var(--border-strong);
  background: var(--surface);
  cursor: pointer;
  width: 100%;
  text-align: left;
}

.app-badge {
  font-size: 11px;
  padding: 4px 8px;
  border-radius: 6px;
  background: var(--primary-soft);
  color: var(--primary-ink);
  font-weight: 600;
  margin-left: 8px;
}

.app-badge[data-variant="edit"] {
  background: var(--warning-weak);
  color: var(--warning-ink);
}

.app-badge[data-variant="loading"] {
  background: var(--primary-soft-strong);
  color: var(--primary-ink-strong);
}

.nf-card {
  border: 1px solid var(--question-card-border, var(--border));
  border-radius: var(--card-radius, var(--radius-md));
  padding: var(--card-padding, 12px);
  margin-bottom: 12px;
  background: var(--question-card-bg, var(--surface));
  box-shadow: none;
}

.nf-card[data-depth]:not([data-depth="0"]) {
  box-shadow: var(--question-card-shadow, var(--shadow-sm));
}

.nf-card[data-selected="true"] {
  border: 2px solid var(--question-card-selected-border, var(--primary));
}

.nf-option-row {
  border: 1px solid var(--option-row-border, var(--border));
  border-radius: var(--radius-sm);
  padding: 8px;
  margin-bottom: 8px;
  background: var(--option-row-bg, transparent);
}

.nf-option-row[data-selected="true"] {
  border: 2px solid var(--option-row-selected-border, var(--primary));
}

.nf-input {
  width: 100%;
  box-sizing: border-box;
  border: 1px solid var(--input-border, var(--border-strong));
  border-radius: var(--input-radius, var(--radius-sm));
  padding: 8px;
  background: var(--input-bg, var(--surface));
  color: var(--input-text, var(--text));
}

.nf-input--readonly {
  cursor: not-allowed;
}

.nf-input--error {
  border-color: var(--input-error-border, var(--danger-bright));
}

.nf-textarea-readonly {
  max-height: 120px;
  overflow-y: auto;
  white-space: pre-wrap;
  word-break: break-word;
}

.nf-btn {
  border: 1px solid var(--button-border, var(--border-strong));
  background: var(--button-bg, var(--surface-subtle));
  padding: 8px 12px;
  border-radius: var(--button-radius, var(--radius-sm));
  cursor: pointer;
  color: var(--button-text, var(--text));
}

.nf-btn-danger {
  border-color: var(--button-danger-border, var(--danger-border-strong));
  background: var(--button-danger-bg, var(--danger-weak-strong));
  color: var(--button-danger-text, var(--text));
}

.nf-btn-compact {
  padding: 4px 8px;
  font-size: 12px;
}

.nf-child {
  border-left: 2px solid var(--child-border, var(--border));
  padding-left: 12px;
  margin-top: 8px;
}

/* Utilities */
.nf-row {
  display: flex;
  align-items: center;
}

.nf-row-between {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.nf-row-center {
  display: flex;
  align-items: center;
  justify-content: center;
}

.nf-justify-end {
  justify-content: flex-end;
}

.nf-col {
  display: flex;
  flex-direction: column;
}

.nf-wrap {
  flex-wrap: wrap;
}

.nf-gap-4 {
  gap: 4px;
}

.nf-gap-6 {
  gap: 6px;
}

.nf-gap-8 {
  gap: 8px;
}

.nf-gap-10 {
  gap: 10px;
}

.nf-gap-12 {
  gap: 12px;
}

.nf-gap-16 {
  gap: 16px;
}

.nf-m-0 {
  margin: 0;
}

.nf-mt-4 {
  margin-top: 4px;
}

.nf-mt-6 {
  margin-top: 6px;
}

.nf-mt-8 {
  margin-top: 8px;
}

.nf-mt-12 {
  margin-top: 12px;
}

.nf-mt-16 {
  margin-top: 16px;
}

.nf-mt-24 {
  margin-top: 24px;
}

.nf-mb-4 {
  margin-bottom: 4px;
}

.nf-mb-2 {
  margin-bottom: 2px;
}

.nf-mb-6 {
  margin-bottom: 6px;
}

.nf-mb-8 {
  margin-bottom: 8px;
}

.nf-mb-12 {
  margin-bottom: 12px;
}

.nf-mb-16 {
  margin-bottom: 16px;
}

.nf-mb-24 {
  margin-bottom: 24px;
}

.nf-mb-0 {
  margin-bottom: 0;
}

.nf-pad-4-8 {
  padding: 4px 8px;
}

.nf-ml-4 {
  margin-left: 4px;
}

.nf-text-11 {
  font-size: 11px;
}

.nf-text-12 {
  font-size: 12px;
}

.nf-text-13 {
  font-size: 13px;
}

.nf-text-14 {
  font-size: 14px;
}

.nf-text-16 {
  font-size: 16px;
}

.nf-text-18 {
  font-size: 18px;
}

.nf-fw-400 {
  font-weight: 400;
}

.nf-fw-500 {
  font-weight: 500;
}

.nf-fw-600 {
  font-weight: 600;
}

.nf-fw-700 {
  font-weight: 700;
}

.nf-fw-750 {
  font-weight: 750;
}

.nf-text-subtle {
  color: var(--text-subtle);
}

.nf-text-muted {
  color: var(--text-muted);
}

.nf-text-faded {
  color: var(--text-faded);
}

.nf-text-ink {
  color: var(--text-ink);
}

.nf-text-strong {
  color: var(--text-strong);
}

.nf-text-danger {
  color: var(--danger);
}

.nf-text-danger-strong {
  color: var(--danger-strong);
}

.nf-text-danger-ink {
  color: var(--danger-ink);
}

.nf-text-danger-ink-strong {
  color: var(--danger-ink-strong);
}

.nf-text-primary-strong {
  color: var(--primary-strong);
}

.nf-text-success {
  color: var(--success);
}

.nf-text-warning {
  color: var(--warning);
}

.nf-w-full {
  width: 100%;
}

.nf-w-auto {
  width: auto;
}
.nf-text-left {
  text-align: left;
}

.nf-text-center {
  text-align: center;
}

.nf-min-w-0 {
  min-width: 0;
}

.nf-flex-1 {
  flex: 1;
}

.nf-flex-1-1-200 {
  flex: 1 1 200px;
}

.nf-flex-1-0-220 {
  flex: 1 0 220px;
}

.nf-flex-0-1-auto {
  flex: 0 1 auto;
}

.nf-min-w-150 {
  min-width: 150px;
}

.nf-shrink-0 {
  flex-shrink: 0;
}

.nf-nowrap {
  white-space: nowrap;
}

.nf-text-underline {
  text-decoration: underline;
}

.nf-block {
  display: block;
}

.nf-cursor-pointer {
  cursor: pointer;
}

.nf-word-break {
  word-break: break-word;
}

.nf-spacer-16 {
  height: 16px;
}

.nf-h-96 {
  height: 96px;
}

.nf-h-200 {
  height: 200px;
}

.nf-min-h-80 {
  min-height: 80px;
}

.nf-min-h-96 {
  min-height: 96px;
}

.nf-ml-6 {
  margin-left: 6px;
}

/* Preview */
.preview-label {
  display: block;
  font-weight: 600;
  margin-bottom: 6px;
  font-size: calc(var(--label-font-size-base, 14px) + var(--label-font-size-offset, 0px));
  color: var(--label-color, inherit);
}

.preview-field {
  margin-bottom: 16px;
}

.preview-title {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 8px;
}

.preview-json {
  height: 200px;
  font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 12px;
}

/* Admin editor */
.admin-input {
  padding: 10px 12px;
  font-size: 14px;
}

.admin-move-btn:disabled {
  background: var(--surface-alt);
  color: var(--text-faded);
  cursor: not-allowed;
}

.admin-info-btn {
  background: var(--info-weak);
  border-color: var(--info);
}

/* Form builder */
.form-builder {
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  background: var(--surface);
  padding: 16px;
}

.form-builder-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  flex-wrap: wrap;
  gap: 8px;
}

.form-builder-title {
  font-size: 16px;
  font-weight: 600;
}

.form-builder-tabs {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
}

.form-builder-tab {
  border: 1px solid var(--border-strong);
  background: var(--surface-subtle);
  padding: 8px 12px;
  border-radius: var(--radius-sm);
  cursor: pointer;
  font-weight: 500;
}

.form-builder-tab[data-active="true"] {
  background: var(--primary-soft);
  font-weight: 600;
}

/* Search preview */
.search-preview-table {
  width: 100%;
  border-collapse: collapse;
}

.search-preview-th {
  text-align: left;
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
  background: var(--surface-subtle);
  font-size: 12px;
  font-weight: 600;
}

.search-preview-td {
  padding: 8px 12px;
  border-bottom: 1px solid var(--border-subtle);
  font-size: 12px;
  color: var(--text-strong);
}

/* Admin dashboard */
.admin-row {
  cursor: pointer;
}

.admin-row[data-clickable="false"] {
  cursor: default;
}

.admin-row[data-error="true"] {
  background: var(--danger-weak);
}

.admin-link {
  color: var(--primary-strong);
  text-decoration: underline;
  font-size: 12px;
}

.admin-danger-btn {
  border-color: var(--danger-border);
  background: var(--danger-weak);
}

.admin-refresh-btn {
  background: var(--warning-weak);
  border-color: var(--warning);
}

.admin-copy-btn {
  padding: 2px 6px;
  border: 1px solid var(--border-strong);
  border-radius: var(--radius-sm);
  background: var(--surface);
  cursor: pointer;
  font-size: 12px;
  transition: background 0.15s ease;
}

.admin-copy-btn:hover {
  background: var(--surface-subtle);
}

.admin-form-id {
  font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 12px;
  color: var(--text-ink);
}

.admin-import-overlay {
  position: fixed;
  inset: 0;
  background: var(--overlay-strong);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.admin-import-panel {
  background: var(--surface);
  border-radius: var(--radius-md);
  padding: 24px;
  width: min(520px, 90vw);
  box-shadow: var(--shadow-lg);
}

.admin-import-input {
  padding: 8px 10px;
  font-size: 14px;
}

.admin-import-btn {
  padding: 8px 16px;
  border-radius: var(--radius-sm);
  border: 1px solid var(--button-border, var(--border-strong));
  background: var(--button-bg, var(--surface));
  color: var(--button-text, var(--text));
}

.admin-import-btn-primary {
  border-color: var(--primary-border-soft, var(--primary-strong, var(--primary, #2563eb)));
  background: var(--primary-strong, var(--primary, #2563eb));
  color: var(--button-solid-text, #fff);
}

/* Search page */
.search-empty,
.search-loading {
  color: var(--text-subtle);
}

.search-bar {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  flex-wrap: wrap;
  align-items: center;
}

.search-input {
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid var(--border-strong);
  background: var(--surface);
  font-size: 14px;
  color: var(--text);
}

.search-sidebar-btn {
  width: 100%;
  text-align: left;
  cursor: pointer;
}

.search-sidebar-btn-danger {
  border-color: var(--danger-border);
  background: var(--danger-weak);
}

.search-sidebar-btn-warning {
  border-color: var(--warning);
  background: var(--warning-weak);
}

.search-table-wrap {
  overflow-x: auto;
  width: 100%;
}

.search-table {
  width: var(--table-width, 100%);
  border-collapse: collapse;
  background: var(--surface);
  border-radius: var(--radius-md);
  overflow: hidden;
}

.search-th {
  text-align: left;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border);
  background: var(--surface-subtle);
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  white-space: nowrap;
}

.search-th[data-sortable="false"] {
  cursor: default;
}

.search-td {
  padding: 12px 16px;
  border-bottom: 1px solid var(--border-subtle);
  font-size: 13px;
  color: var(--text-strong);
  vertical-align: top;
  white-space: nowrap;
}

.search-td-narrow {
  width: 50px;
}

.search-row {
  cursor: pointer;
}

.search-pagination {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 16px;
}

.search-pagination-info {
  color: var(--text-subtle);
  font-size: 13px;
}

.search-pagination-nav {
  display: flex;
  gap: 8px;
}

.search-pagination-page {
  line-height: 32px;
}

/* Main page */
.main-list {
  display: grid;
  gap: 16px;
}

.main-card {
  background: var(--surface);
  border-radius: var(--radius-md);
  border: 1px solid var(--border-muted);
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  cursor: pointer;
}

.main-title {
  font-size: 16px;
  font-weight: 600;
  margin: 0;
}

.main-meta {
  font-size: 12px;
  color: var(--text-subtle);
}

/* Not found */
.nf-btn-outline {
  padding: 8px 14px;
  border-radius: var(--radius-sm);
  border: 1px solid var(--button-border, var(--border-strong));
  background: var(--button-bg, var(--surface));
  color: var(--button-text, var(--text));
  cursor: pointer;
}

.nf-btn-sidebar {
  width: 100%;
  text-align: left;
}

/* Dialogs */
.dialog-overlay {
  position: fixed;
  inset: 0;
  background: var(--overlay);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.dialog-panel {
  width: min(420px, 90vw);
  background: var(--surface);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-lg);
  padding: 24px 24px 16px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.dialog-title {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
}

.dialog-message {
  margin: 0;
  font-size: 14px;
  color: var(--text-muted);
  line-height: 1.6;
}

.dialog-message-pre {
  white-space: pre-wrap;
}

.dialog-footer {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
}

.dialog-btn {
  border-radius: var(--radius-sm);
  padding: 8px 14px;
  font-size: 14px;
  cursor: pointer;
  border: 1px solid var(--button-border, var(--border-strong));
  background: var(--button-bg, var(--surface));
  color: var(--button-text, var(--text));
}

.dialog-btn.primary {
  background: var(--primary-strong, var(--primary, #2563eb));
  border-color: var(--primary-border-soft, var(--primary-strong, var(--primary, #2563eb)));
  color: var(--button-solid-text, #fff);
}

.dialog-btn.danger {
  background: var(--danger-strong, var(--danger, #dc2626));
  border-color: var(--danger-border-strong, var(--danger-strong, var(--danger, #dc2626)));
  color: var(--button-solid-text, #fff);
}

/* Link style for URL fields */
.nf-link {
  color: var(--primary-strong);
  text-decoration: underline;
  cursor: pointer;
}

.nf-link:hover {
  color: var(--primary);
  text-decoration: none;
}

.nf-settings-group-title {
  font-size: 15px;
  font-weight: 700;
  color: var(--nf-color-text, var(--text));
}



================================================
FILE: builder/src/app/theme/preview-overrides.css
================================================
/* preview-overrides.css
   Purpose: match ui_preview_balanced.html look & feel (buttons, cards, rails) */

/* 1) Minor tuning: preview uses radius-sm ~ 10px */
:root,
:root[data-theme="balanced"] {
  --radius-sm: 10px;
  /* Slightly round cards compared to existing radius-md */
  --radius-md: 14px;
}

/* 2) Header: transparent + blur + spacing (override inline AppLayout styles) */
header {
  position: sticky;
  top: 0;
  z-index: 50;

  padding: 14px 18px;
  border-bottom: 1px solid var(--border);

  background: var(--app-header-bg);
  backdrop-filter: blur(10px);
}

/* 3) Buttons: pill shape + shadow + hover (strong override for inline styles) */
button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;

  padding: 9px 12px;
  border-radius: 999px;

  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--button-text, var(--text, #1f2937));
  box-shadow: var(--shadow-sm);

  font-size: 13px;
  line-height: 1;
  cursor: pointer;
  user-select: none;

  transition:
    transform 0.16s ease,
    box-shadow 0.16s ease,
    border-color 0.16s ease,
    background 0.16s ease,
    filter 0.16s ease;
}

button:hover:not(:disabled) {
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
  border-color: var(--card-hover-border);
}

button:active:not(:disabled) {
  transform: translateY(0);
  box-shadow: var(--shadow-sm);
}

button:focus-visible {
  outline: none;
  box-shadow: 0 0 0 4px var(--input-focus-ring), var(--shadow-sm);
}

/* 3-1) primaryStrong-style buttons (inline background: var(--primary-strong)) */
button[style*="background: var(--primary-strong)"],
button[style*="background:var(--primary-strong)"] {
  background: linear-gradient(135deg, var(--primary, #2f6fed), var(--primary-strong, var(--primary, #2563eb)));
  border-color: var(--primary-border-soft, rgba(47, 111, 237, 0.22));
  color: rgba(255, 255, 255, 0.96);
  filter: saturate(1.02);
}

/* 3-2) dangerStrong buttons */
button[style*="background: var(--danger-strong)"],
button[style*="background:var(--danger-strong)"] {
  background: linear-gradient(135deg, var(--danger-bright, #ef4444), var(--danger-strong, var(--danger, #dc2626)));
  border-color: var(--danger-border-strong, rgba(225, 29, 72, 0.35));
  color: rgba(255, 255, 255, 0.96);
}

/* 3-2b) dialog button variants (avoid global button override) */
.dialog-btn.primary {
  background: linear-gradient(135deg, var(--primary, #2f6fed), var(--primary-strong, var(--primary, #2563eb)));
  border-color: var(--primary-border-soft, rgba(47, 111, 237, 0.22));
  color: var(--button-solid-text, #fff);
}

.dialog-btn.danger {
  background: linear-gradient(135deg, var(--danger-bright, #ef4444), var(--danger-strong, var(--danger, #dc2626)));
  border-color: var(--danger-border-strong, rgba(225, 29, 72, 0.35));
  color: var(--button-solid-text, #fff);
}

.admin-import-btn-primary {
  background: linear-gradient(135deg, var(--primary, #2f6fed), var(--primary-strong, var(--primary, #2563eb)));
  border-color: var(--primary-border-soft, rgba(47, 111, 237, 0.22));
  color: var(--button-solid-text, #fff);
}

/* 3-3) Optional .btn class (preview primary button look) */
.btn {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 9px 12px;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: var(--surface);
  box-shadow: var(--shadow-sm);
  font-size: 12px;
  color: var(--text);
  user-select: none;
}

.btn.primary {
  border-color: var(--primary-border-soft);
  background: var(--btn-primary-bg);
}

/* 4) Inputs: keep simple radius, reduce heavy shadows (override inline styles) */
input,
select,
textarea {
  border-radius: var(--radius-sm);
  border: 1px solid var(--border-strong);
  background: var(--surface);
  color: var(--text);
}

/* 5) Cards: add shadow + hover for bordered blocks (inline style detection) */
div[style*="border: 1px solid var(--border)"][style*="border-radius: var(--radius-md)"],
div[style*="border: 1px solid var(--border)"][style*="border-radius: var(--radius-lg)"] {
  box-shadow: var(--shadow-sm);
  transition: transform 0.16s ease, box-shadow 0.16s ease, border-color 0.16s ease;
}

div[style*="border: 1px solid var(--border)"][style*="border-radius: var(--radius-md)"]:hover,
div[style*="border: 1px solid var(--border)"][style*="border-radius: var(--radius-lg)"]:hover {
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
  border-color: var(--card-hover-border);
}

/* 6) Hierarchy rails (override editor child border-left) */
div[style*="border-left: 2px solid var(--border)"] {
  position: relative;
  border-left: none;
  padding-left: 18px;
}

div[style*="border-left: 2px solid var(--border)"]::before {
  content: "";
  position: absolute;
  left: 6px;
  top: 10px;
  bottom: 10px;
  width: 2px;
  background: var(--rail-gradient);
}

div[style*="border-left: 2px solid var(--border)"]::after {
  content: "";
  position: absolute;
  left: 2px;
  top: 14px;
  width: 10px;
  height: 10px;
  border-radius: 999px;
  background: var(--rail-dot-bg);
  box-shadow: var(--rail-dot-shadow);
}

/* 7) Text tone: slightly tighter tracking for headings */
h1,
h2,
h3 {
  letter-spacing: -0.01em;
}



================================================
FILE: builder/src/app/theme/theme.css
================================================
:root {
  --font-sans: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;

  --label-font-size-base: 14px;
  --label-size-offset-xs: -4px;
  --label-size-offset-sm: -2px;
  --label-size-offset-lg: 2px;
  --label-size-offset-xl: 4px;

  --bg: #f6f7fb;
  --surface: #ffffff;
  --surface-elevated: #ffffff;
  --surface-muted: #f9fafb;
  --surface-subtle: #f8fafc;
  --surface-alt: #f3f4f6;

  --border: #e6e8f0;
  --border-muted: #e2e8f0;
  --border-subtle: #f1f5f9;
  --border-strong: #cbd5e1;

  --text: #0f172a;
  --text-strong: #1f2937;
  --text-ink: #374151;
  --text-muted: #64748b;
  --text-subtle: #6b7280;
  --text-faded: #9ca3af;

  --primary: #2f6fed;
  --primary-strong: #2563eb;
  --primary-ink: #1e40af;
  --primary-ink-strong: #1e3a8a;
  --primary-soft: #dbeafe;
  --primary-soft-strong: #bfdbfe;
  --primary-weak: rgba(47, 111, 237, 0.1);
  --primary-weak-soft: rgba(47, 111, 237, 0.06);
  --primary-border-soft: rgba(47, 111, 237, 0.22);

  --warm: #ff7a59;
  --warm-weak: rgba(255, 122, 89, 0.1);
  --warm-ink: #9a3412;

  --success: #16a34a;
  --success-ink: #166534;
  --success-weak: rgba(22, 163, 74, 0.1);

  --danger: #e11d48;
  --danger-bright: #ef4444;
  --danger-strong: #dc2626;
  --danger-ink: #b91c1c;
  --danger-ink-strong: #991b1b;
  --danger-weak: #fef2f2;
  --danger-weak-strong: #fee2e2;
  --danger-border: #fca5a5;
  --danger-border-strong: #fecaca;

  --warning: #f59e0b;
  --warning-weak: #fef3c7;
  --warning-ink: #92400e;

  --info: #38bdf8;
  --info-weak: #e0f2fe;

  --radius-sm: 8px;
  --radius-md: 12px;
  --radius-lg: 16px;

  --shadow-sm: 0 2px 10px rgba(15, 23, 42, 0.06);
  --shadow-md: 0 16px 36px rgba(15, 23, 42, 0.14);
  --shadow-lg: 0 20px 45px rgba(15, 23, 42, 0.25);

  --overlay: rgba(15, 23, 42, 0.35);
  --overlay-strong: rgba(15, 23, 42, 0.55);

  --app-bg:
    radial-gradient(900px 520px at 12% -10%, var(--primary-weak), transparent 60%),
    radial-gradient(900px 520px at 92% 0%, var(--warm-weak), transparent 62%),
    var(--bg);
  --app-header-bg: rgba(246, 247, 251, 0.78);

  --input-border-focus: rgba(47, 111, 237, 0.35);
  --input-focus-ring: rgba(47, 111, 237, 0.1);

  --badge-primary-bg: linear-gradient(135deg, rgba(47, 111, 237, 0.95), rgba(47, 111, 237, 0.78));
  --badge-warm-bg: linear-gradient(135deg, rgba(255, 122, 89, 0.92), rgba(255, 122, 89, 0.75));
  --badge-ghost-bg: rgba(47, 111, 237, 0.08);
  --badge-ghost-border: rgba(47, 111, 237, 0.18);
  --badge-text: rgba(255, 255, 255, 0.94);

  --logo-gradient: linear-gradient(135deg, rgba(47, 111, 237, 0.95), rgba(255, 122, 89, 0.85));
  --logo-shadow: 0 10px 26px rgba(47, 111, 237, 0.16), 0 10px 24px rgba(255, 122, 89, 0.1);
  --panel-header-bg: linear-gradient(180deg, rgba(47, 111, 237, 0.06), transparent);
  --card-hover-border: rgba(15, 23, 42, 0.16);
  --btn-primary-bg: linear-gradient(180deg, var(--primary-weak), var(--primary-weak-soft));
  --rail-gradient: linear-gradient(180deg, rgba(47, 111, 237, 0), rgba(47, 111, 237, 0.45), rgba(47, 111, 237, 0.1), rgba(47, 111, 237, 0));
  --rail-dot-bg: linear-gradient(135deg, rgba(47, 111, 237, 0.95), rgba(255, 122, 89, 0.85));
  --rail-dot-shadow: 0 10px 18px rgba(255, 122, 89, 0.1);
  --if-box-border: rgba(255, 122, 89, 0.2);
  --if-box-bg: linear-gradient(135deg, rgba(255, 122, 89, 0.1), rgba(47, 111, 237, 0.05));
  --if-chip-bg: rgba(255, 122, 89, 0.12);
  --if-chip-border: rgba(255, 122, 89, 0.18);
  --if-badge-border: rgba(22, 163, 74, 0.18);

  --question-card-bg: var(--surface);
  --question-card-border: var(--border);
  --question-card-selected-border: var(--primary);
  --question-card-shadow: var(--shadow-sm);
  --card-radius: var(--radius-md);
  --card-padding: 12px;

  --option-row-bg: transparent;
  --option-row-border: var(--border);
  --option-row-selected-border: var(--primary);

  --input-bg: var(--surface);
  --input-text: var(--text);
  --input-border: var(--border-strong);
  --input-radius: var(--radius-sm);
  --input-readonly-bg: var(--surface-subtle);
  --input-readonly-text: var(--text-ink);
  --input-error-border: var(--danger-bright);

  --button-bg: var(--surface-subtle);
  --button-text: var(--text);
  --button-border: var(--border-strong);
  --button-radius: var(--radius-sm);
  --button-solid-text: rgba(255, 255, 255, 0.96);
  --button-danger-bg: var(--danger-weak-strong);
  --button-danger-text: var(--text);
  --button-danger-border: var(--danger-border-strong);

  --child-border: var(--border);
}



================================================
FILE: builder/src/app/theme/theme.js
================================================
import { readSettingsValue, writeSettingsValue } from "../../core/storage.js";

const THEME_STORAGE_KEY = "nested_form_builder_theme";
export const DEFAULT_THEME = "standard";
export const THEME_OPTIONS = [
  { value: "standard", label: "Standard" },
  { value: "matcha", label: "Matcha" },
  { value: "sakura", label: "Sakura" },
  { value: "warm", label: "Warm" },
  { value: "ocean", label: "Ocean" },
  { value: "dark", label: "Dark" },
  { value: "egypt", label: "Egypt" },
  { value: "india", label: "India" },
  { value: "snow", label: "Snow" },
  { value: "christmas", label: "Christmas" },
  { value: "forest", label: "Forest" },
];

const CUSTOM_THEME_STYLE_ID = "nfb-custom-themes";
const CUSTOM_THEMES_KEY = "nested_form_builder_theme_custom_list_v1";
const CUSTOM_THEME_PREFIX = "drive-";
const BUILT_IN_THEME_IDS = new Set(THEME_OPTIONS.map((option) => option.value));

const ensureCustomThemeStyle = (themes) => {
  if (typeof document === "undefined") return;
  const styleId = CUSTOM_THEME_STYLE_ID;
  const css = (themes || [])
    .map((theme) => theme.css)
    .filter(Boolean)
    .join("\n");
  let style = document.getElementById(styleId);
  if (!css) {
    if (style && style.parentNode) {
      style.parentNode.removeChild(style);
    }
    return;
  }
  if (!style) {
    style = document.createElement("style");
    style.id = styleId;
    document.head.appendChild(style);
  }
  style.textContent = css;
};

const normalizeCustomThemeCss = (css, themeId) => {
  if (!css) return "";
  let normalized = String(css).trim();
  if (!normalized) return "";
  const themeSelector = `:root[data-theme="${themeId}"]`;

  const dataThemeRegex = /data-theme=(["'])(.*?)\1/;
  if (dataThemeRegex.test(normalized)) {
    return normalized.replace(
      /data-theme=(["'])(.*?)\1/g,
      `data-theme="${themeId}"`,
    );
  }

  const rootRegex = /:root(?!\[data-theme\])/;
  if (rootRegex.test(normalized)) {
    return normalized.replace(/:root(?!\[data-theme\])/g, themeSelector);
  }

  return `${themeSelector} {\n${normalized}\n}\n`;
};

const normalizeCustomThemes = (input) => {
  if (!input) return [];
  let parsed = input;
  if (typeof parsed === "string") {
    try {
      parsed = JSON.parse(parsed);
    } catch {
      return [];
    }
  }
  if (!Array.isArray(parsed)) return [];
  return parsed
    .filter(
      (theme) =>
        theme && typeof theme.id === "string" && typeof theme.css === "string",
    )
    .map((theme) => ({
      id: theme.id,
      name: theme.name || "",
      css: theme.css || "",
    }))
    .filter((theme) => theme.id && theme.css);
};

const readCustomThemes = async () => {
  const stored = await readSettingsValue(CUSTOM_THEMES_KEY);
  return normalizeCustomThemes(stored);
};

const writeCustomThemes = async (themes) => {
  await writeSettingsValue(CUSTOM_THEMES_KEY, themes || []);
};

const readThemeFromStorage = async () => {
  const stored = await readSettingsValue(THEME_STORAGE_KEY);
  const theme = typeof stored === "string" ? stored : "";
  return theme || null;
};

const normalizeThemeName = (name) => {
  const normalized = String(name || "")
    .trim()
    .toLowerCase();
  const slug = normalized.replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
  return slug || "custom";
};

const createThemeId = (name, existingIds) => {
  const base = `${CUSTOM_THEME_PREFIX}${normalizeThemeName(name)}`;
  let id = base;
  let index = 2;
  const reservedIds = BUILT_IN_THEME_IDS;
  while (existingIds.has(id) || reservedIds.has(id)) {
    id = `${base}-${index}`;
    index += 1;
  }
  return id;
};

export const resolveThemeName = (name, customThemes = []) => {
  const candidate = String(name || "").trim();
  if (!candidate) return DEFAULT_THEME;
  if (BUILT_IN_THEME_IDS.has(candidate)) return candidate;
  const customIds = new Set(
    (customThemes || []).map((theme) => theme?.id).filter(Boolean),
  );
  return customIds.has(candidate) ? candidate : DEFAULT_THEME;
};

export const getCustomThemes = async () => readCustomThemes();

export const setCustomTheme = async ({ css, name } = {}) => {
  const themes = await readCustomThemes();
  const existingIds = new Set(themes.map((theme) => theme.id));
  const themeId = createThemeId(name || "custom", existingIds);
  const normalized = normalizeCustomThemeCss(css, themeId);
  if (!normalized) return null;
  const theme = {
    id: themeId,
    name: name || "",
    css: normalized,
  };
  const next = [...themes, theme];
  await writeCustomThemes(next);
  ensureCustomThemeStyle(next);
  return theme;
};

export const removeCustomTheme = async (themeId) => {
  const themes = await readCustomThemes();
  const next = themes.filter((theme) => theme.id !== themeId);
  await writeCustomThemes(next);
  ensureCustomThemeStyle(next);
  return next;
};

export const restoreCustomThemes = async () => {
  const themes = await readCustomThemes();
  ensureCustomThemeStyle(themes);
  return themes;
};

export const applyTheme = (name) => {
  if (typeof document === "undefined") return;
  document.documentElement.dataset.theme = name;
};

export const applyThemeWithFallback = async (name, options = {}) => {
  const { persist = false } = options;
  const customThemes = await readCustomThemes();
  ensureCustomThemeStyle(customThemes);
  const resolved = resolveThemeName(name, customThemes);
  applyTheme(resolved);
  if (persist) {
    await writeSettingsValue(THEME_STORAGE_KEY, resolved);
  }
  return resolved;
};

export const initTheme = (fallback = DEFAULT_THEME) => {
  const initialTheme = fallback || DEFAULT_THEME;
  applyTheme(initialTheme);
  void (async () => {
    try {
      const saved = await readThemeFromStorage();
      const preferred =
        saved === "default" ? DEFAULT_THEME : saved || initialTheme;
      await applyThemeWithFallback(preferred, { persist: true });
    } catch (error) {
      console.warn("[theme] failed to load theme from IndexedDB", error);
    }
  })();
  return initialTheme;
};

export const setTheme = (name, options = {}) => {
  const { persist = true } = options;
  const resolved = name || DEFAULT_THEME;
  applyTheme(resolved);
  if (!persist) return;
  void writeSettingsValue(THEME_STORAGE_KEY, resolved);
};



================================================
FILE: builder/src/app/theme/tokens.js
================================================
export const theme = {
  fontSans: "var(--font-sans)",

  bg: "var(--bg)",
  surface: "var(--surface)",
  surfaceElevated: "var(--surface-elevated)",
  surfaceMuted: "var(--surface-muted)",
  surfaceSubtle: "var(--surface-subtle)",
  surfaceAlt: "var(--surface-alt)",

  border: "var(--border)",
  borderMuted: "var(--border-muted)",
  borderSubtle: "var(--border-subtle)",
  borderStrong: "var(--border-strong)",

  text: "var(--text)",
  textStrong: "var(--text-strong)",
  textInk: "var(--text-ink)",
  textMuted: "var(--text-muted)",
  textSubtle: "var(--text-subtle)",
  textFaded: "var(--text-faded)",

  primary: "var(--primary)",
  primaryStrong: "var(--primary-strong)",
  primaryInk: "var(--primary-ink)",
  primaryInkStrong: "var(--primary-ink-strong)",
  primarySoft: "var(--primary-soft)",
  primarySoftStrong: "var(--primary-soft-strong)",
  primaryWeak: "var(--primary-weak)",

  warm: "var(--warm)",
  warmWeak: "var(--warm-weak)",
  warmInk: "var(--warm-ink)",

  success: "var(--success)",
  successInk: "var(--success-ink)",
  successWeak: "var(--success-weak)",

  danger: "var(--danger)",
  dangerBright: "var(--danger-bright)",
  dangerStrong: "var(--danger-strong)",
  dangerInk: "var(--danger-ink)",
  dangerInkStrong: "var(--danger-ink-strong)",
  dangerWeak: "var(--danger-weak)",
  dangerWeakStrong: "var(--danger-weak-strong)",
  dangerBorder: "var(--danger-border)",
  dangerBorderStrong: "var(--danger-border-strong)",

  warning: "var(--warning)",
  warningWeak: "var(--warning-weak)",
  warningInk: "var(--warning-ink)",

  info: "var(--info)",
  infoWeak: "var(--info-weak)",

  radiusSm: "var(--radius-sm)",
  radiusMd: "var(--radius-md)",
  radiusLg: "var(--radius-lg)",

  shadowSm: "var(--shadow-sm)",
  shadowMd: "var(--shadow-md)",
  shadowLg: "var(--shadow-lg)",

  overlay: "var(--overlay)",
  overlayStrong: "var(--overlay-strong)",
  appBg: "var(--app-bg)",
  appHeaderBg: "var(--app-header-bg)",
  inputBorderFocus: "var(--input-border-focus)",
  inputFocusRing: "var(--input-focus-ring)",
};



================================================
FILE: builder/src/app/theme/themes/christmas.css
================================================
/* christmas theme overrides */
:root[data-theme="christmas"] {
    --font-sans:
        "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;

    --label-font-size-base: 14px;
    --label-size-offset-xs: -4px;
    --label-size-offset-sm: -2px;
    --label-size-offset-lg: 2px;
    --label-size-offset-xl: 4px;

    /* warm ivory base */
    --bg: #fff7ed;
    --surface: #ffffff;
    --surface-elevated: #ffffff;
    --surface-muted: #fff1df;
    --surface-subtle: #fffbf5;
    --surface-alt: #ffe7d0;

    --border: #f2d6c2;
    --border-muted: #f6e3d4;
    --border-subtle: #fff2e8;
    --border-strong: #e9c2a6;

    --text: #1f2937;
    --text-strong: #111827;
    --text-ink: #334155;
    --text-muted: #6b7280;
    --text-subtle: #7b8190;
    --text-faded: #9ca3af;

    /* holly red */
    --primary: #dc2626;
    --primary-strong: #b91c1c;
    --primary-ink: #7f1d1d;
    --primary-ink-strong: #450a0a;
    --primary-soft: #fee2e2;
    --primary-soft-strong: #fecaca;
    --primary-weak: rgba(220, 38, 38, 0.1);
    --primary-weak-soft: rgba(220, 38, 38, 0.06);
    --primary-border-soft: rgba(220, 38, 38, 0.22);

    /* evergreen */
    --success: #16a34a;
    --success-ink: #166534;
    --success-weak: rgba(22, 163, 74, 0.1);

    --warm: #f59e0b;
    --warm-weak: rgba(245, 158, 11, 0.12);
    --warm-ink: #92400e;

    --danger: #dc2626;
    --danger-bright: #ef4444;
    --danger-strong: #991b1b;
    --danger-ink: #7f1d1d;
    --danger-ink-strong: #450a0a;
    --danger-weak: #fef2f2;
    --danger-weak-strong: #fee2e2;
    --danger-border: #fecaca;
    --danger-border-strong: #fca5a5;

    --warning: #f59e0b;
    --warning-weak: #fef3c7;
    --warning-ink: #92400e;

    --info: #38bdf8;
    --info-weak: #e0f2fe;

    --radius-sm: 10px;
    --radius-md: 14px;
    --radius-lg: 18px;

    --shadow-sm: 0 2px 10px rgba(31, 41, 55, 0.07);
    --shadow-md: 0 16px 36px rgba(31, 41, 55, 0.14);
    --shadow-lg: 0 20px 45px rgba(31, 41, 55, 0.2);

    --overlay: rgba(17, 24, 39, 0.3);
    --overlay-strong: rgba(17, 24, 39, 0.5);

    --app-bg:
        radial-gradient(
            900px 520px at 10% -10%,
            rgba(220, 38, 38, 0.14),
            transparent 60%
        ),
        radial-gradient(
            900px 520px at 92% 0%,
            rgba(22, 163, 74, 0.12),
            transparent 62%
        ),
        radial-gradient(
            900px 520px at 56% 120%,
            rgba(245, 158, 11, 0.1),
            transparent 60%
        ),
        var(--bg);
    --app-header-bg: rgba(255, 247, 237, 0.84);

    --input-border-focus: rgba(220, 38, 38, 0.35);
    --input-focus-ring: rgba(220, 38, 38, 0.12);

    --badge-primary-bg: linear-gradient(
        135deg,
        rgba(220, 38, 38, 0.95),
        rgba(22, 163, 74, 0.86)
    );
    --badge-warm-bg: linear-gradient(
        135deg,
        rgba(245, 158, 11, 0.92),
        rgba(220, 38, 38, 0.84)
    );
    --badge-ghost-bg: rgba(220, 38, 38, 0.08);
    --badge-ghost-border: rgba(220, 38, 38, 0.18);
    --badge-text: rgba(255, 255, 255, 0.94);

    --logo-gradient: linear-gradient(
        135deg,
        rgba(22, 163, 74, 0.92),
        rgba(220, 38, 38, 0.9)
    );
    --logo-shadow:
        0 10px 26px rgba(22, 163, 74, 0.12), 0 10px 24px rgba(220, 38, 38, 0.1);

    --panel-header-bg: linear-gradient(
        180deg,
        rgba(22, 163, 74, 0.06),
        transparent
    );
    --card-hover-border: rgba(22, 163, 74, 0.18);
    --btn-primary-bg: linear-gradient(
        180deg,
        var(--primary-weak),
        var(--primary-weak-soft)
    );

    --rail-gradient: linear-gradient(
        180deg,
        rgba(22, 163, 74, 0),
        rgba(22, 163, 74, 0.35),
        rgba(220, 38, 38, 0.18),
        rgba(22, 163, 74, 0)
    );
    --rail-dot-bg: linear-gradient(
        135deg,
        rgba(220, 38, 38, 0.92),
        rgba(22, 163, 74, 0.86)
    );
    --rail-dot-shadow: 0 10px 18px rgba(220, 38, 38, 0.1);

    --if-box-border: rgba(22, 163, 74, 0.18);
    --if-box-bg: linear-gradient(
        135deg,
        rgba(22, 163, 74, 0.08),
        rgba(220, 38, 38, 0.06)
    );
    --if-chip-bg: rgba(22, 163, 74, 0.1);
    --if-chip-border: rgba(22, 163, 74, 0.16);
    --if-badge-border: rgba(245, 158, 11, 0.16);
}



================================================
FILE: builder/src/app/theme/themes/dark.css
================================================
/* dark theme overrides */
:root[data-theme="dark"] {
    --font-sans:
        "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;

    --label-font-size-base: 14px;
    --label-size-offset-xs: -4px;
    --label-size-offset-sm: -2px;
    --label-size-offset-lg: 2px;
    --label-size-offset-xl: 4px;

    --bg: #0b1020;
    --surface: rgba(255, 255, 255, 0.07);
    --surface-elevated: rgba(255, 255, 255, 0.1);
    --surface-muted: rgba(255, 255, 255, 0.055);
    --surface-subtle: rgba(255, 255, 255, 0.04);
    --surface-alt: rgba(255, 255, 255, 0.12);

    --border: rgba(255, 255, 255, 0.14);
    --border-muted: rgba(255, 255, 255, 0.12);
    --border-subtle: rgba(255, 255, 255, 0.08);
    --border-strong: rgba(255, 255, 255, 0.18);

    --text: #e5e7eb;
    --text-strong: #f8fafc;
    --text-ink: #cbd5e1;
    --text-muted: rgba(203, 213, 225, 0.78);
    --text-subtle: rgba(203, 213, 225, 0.7);
    --text-faded: rgba(203, 213, 225, 0.58);

    --primary: #60a5fa;
    --primary-strong: #3b82f6;
    --primary-ink: #bfdbfe;
    --primary-ink-strong: #dbeafe;
    --primary-soft: rgba(96, 165, 250, 0.22);
    --primary-soft-strong: rgba(96, 165, 250, 0.32);
    --primary-weak: rgba(96, 165, 250, 0.18);
    --primary-weak-soft: rgba(96, 165, 250, 0.12);
    --primary-border-soft: rgba(96, 165, 250, 0.38);

    --warm: #f97316;
    --warm-weak: rgba(249, 115, 22, 0.18);
    --warm-ink: #fed7aa;

    --success: #34d399;
    --success-ink: #d1fae5;
    --success-weak: rgba(52, 211, 153, 0.14);

    --danger: #fb7185;
    --danger-bright: #fb7185;
    --danger-strong: #f43f5e;
    --danger-ink: #fecdd3;
    --danger-ink-strong: #fda4af;
    --danger-weak: rgba(251, 113, 133, 0.16);
    --danger-weak-strong: rgba(251, 113, 133, 0.22);
    --danger-border: rgba(251, 113, 133, 0.3);
    --danger-border-strong: rgba(251, 113, 133, 0.38);

    --warning: #fbbf24;
    --warning-weak: rgba(251, 191, 36, 0.16);
    --warning-ink: #fde68a;

    --info: #22d3ee;
    --info-weak: rgba(34, 211, 238, 0.16);

    --radius-sm: 10px;
    --radius-md: 14px;
    --radius-lg: 16px;

    --shadow-sm: 0 2px 10px rgba(0, 0, 0, 0.22);
    --shadow-md: 0 18px 45px rgba(0, 0, 0, 0.44);
    --shadow-lg: 0 26px 60px rgba(0, 0, 0, 0.52);

    --overlay: rgba(5, 8, 16, 0.62);
    --overlay-strong: rgba(5, 8, 16, 0.78);

    --app-bg:
        radial-gradient(
            900px 520px at 14% -10%,
            rgba(96, 165, 250, 0.42),
            transparent 60%
        ),
        radial-gradient(
            900px 520px at 92% 6%,
            rgba(249, 115, 22, 0.3),
            transparent 62%
        ),
        radial-gradient(
            700px 420px at 60% 120%,
            rgba(34, 211, 238, 0.14),
            transparent 60%
        ),
        var(--bg);
    --app-header-bg: rgba(8, 12, 20, 0.72);

    --input-border-focus: rgba(96, 165, 250, 0.48);
    --input-focus-ring: rgba(96, 165, 250, 0.22);

    --badge-primary-bg: linear-gradient(
        135deg,
        rgba(96, 165, 250, 0.95),
        rgba(249, 115, 22, 0.9)
    );
    --badge-warm-bg: linear-gradient(
        135deg,
        rgba(249, 115, 22, 0.95),
        rgba(251, 191, 36, 0.86)
    );
    --badge-ghost-bg: rgba(255, 255, 255, 0.08);
    --badge-ghost-border: rgba(255, 255, 255, 0.16);
    --badge-text: rgba(255, 255, 255, 0.92);

    --logo-gradient: linear-gradient(
        135deg,
        rgba(96, 165, 250, 0.95),
        rgba(249, 115, 22, 0.9)
    );
    --logo-shadow:
        0 8px 24px rgba(96, 165, 250, 0.22),
        0 10px 28px rgba(249, 115, 22, 0.16);

    --panel-header-bg: linear-gradient(
        180deg,
        rgba(255, 255, 255, 0.06),
        transparent
    );
    --card-hover-border: rgba(255, 255, 255, 0.22);
    --btn-primary-bg: linear-gradient(
        135deg,
        rgba(96, 165, 250, 0.22),
        rgba(249, 115, 22, 0.18)
    );

    --rail-gradient: linear-gradient(
        180deg,
        rgba(96, 165, 250, 0),
        rgba(96, 165, 250, 0.55),
        rgba(249, 115, 22, 0.4),
        rgba(96, 165, 250, 0)
    );
    --rail-dot-bg: linear-gradient(
        135deg,
        rgba(96, 165, 250, 0.95),
        rgba(249, 115, 22, 0.9)
    );
    --rail-dot-shadow:
        0 10px 22px rgba(96, 165, 250, 0.18),
        0 12px 26px rgba(249, 115, 22, 0.14);

    --if-box-border: rgba(255, 255, 255, 0.12);
    --if-box-bg: linear-gradient(
        135deg,
        rgba(96, 165, 250, 0.16),
        rgba(249, 115, 22, 0.12)
    );
    --if-chip-bg: rgba(255, 255, 255, 0.1);
    --if-chip-border: rgba(255, 255, 255, 0.14);
    --if-badge-border: rgba(52, 211, 153, 0.22);
}

/* nfb:select-popup-contrast:dark */
:root[data-theme="dark"] {
    color-scheme: dark;
}

/* Fallback: some browsers style the popup via option/optgroup */
:root[data-theme="dark"] select {
    color-scheme: dark;
}
:root[data-theme="dark"] select option,
:root[data-theme="dark"] select optgroup {
    background-color: var(--bg);
    color: var(--text);
}



================================================
FILE: builder/src/app/theme/themes/egypt.css
================================================
/* egypt theme overrides */
:root[data-theme="egypt"] {
    --font-sans:
        "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;

    --label-font-size-base: 14px;
    --label-size-offset-xs: -4px;
    --label-size-offset-sm: -2px;
    --label-size-offset-lg: 2px;
    --label-size-offset-xl: 4px;

    /* Papyrus + sand */
    --bg: #fff6dd;
    --surface: #ffffff;
    --surface-elevated: #ffffff;
    --surface-muted: #fff0c9;
    --surface-subtle: #fffaf0;
    --surface-alt: #fde9b6;

    --border: #ead9b0;
    --border-muted: #f1e6c8;
    --border-subtle: #faf3df;
    --border-strong: #d6c08e;

    /* Warm ink (not pure black) */
    --text: #2a2116;
    --text-strong: #1b140c;
    --text-ink: #3a2c1b;
    --text-muted: #6b5b4b;
    --text-subtle: #7a6a5a;
    --text-faded: #a19282;

    /* Nile turquoise */
    --primary: #0891b2;
    --primary-strong: #0e7490;
    --primary-ink: #164e63;
    --primary-ink-strong: #083344;
    --primary-soft: #cffafe;
    --primary-soft-strong: #a5f3fc;
    --primary-weak: rgba(8, 145, 178, 0.12);
    --primary-weak-soft: rgba(8, 145, 178, 0.06);
    --primary-border-soft: rgba(8, 145, 178, 0.24);

    /* Desert gold */
    --warm: #d97706;
    --warm-weak: rgba(217, 119, 6, 0.12);
    --warm-ink: #92400e;

    --success: #16a34a;
    --success-ink: #166534;
    --success-weak: rgba(22, 163, 74, 0.1);

    --danger: #dc2626;
    --danger-bright: #ef4444;
    --danger-strong: #b91c1c;
    --danger-ink: #991b1b;
    --danger-ink-strong: #7f1d1d;
    --danger-weak: #fef2f2;
    --danger-weak-strong: #fee2e2;
    --danger-border: #fecaca;
    --danger-border-strong: #fca5a5;

    --warning: #f59e0b;
    --warning-weak: #fef3c7;
    --warning-ink: #92400e;

    --info: #38bdf8;
    --info-weak: #e0f2fe;

    --radius-sm: 10px;
    --radius-md: 14px;
    --radius-lg: 18px;

    --shadow-sm: 0 2px 10px rgba(42, 33, 22, 0.06);
    --shadow-md: 0 16px 36px rgba(42, 33, 22, 0.13);
    --shadow-lg: 0 20px 45px rgba(42, 33, 22, 0.22);

    --overlay: rgba(42, 33, 22, 0.3);
    --overlay-strong: rgba(42, 33, 22, 0.48);

    --app-bg:
        radial-gradient(
            900px 520px at 12% -10%,
            var(--primary-weak),
            transparent 60%
        ),
        radial-gradient(
            900px 520px at 92% 0%,
            var(--warm-weak),
            transparent 62%
        ),
        var(--bg);
    --app-header-bg: rgba(255, 246, 221, 0.82);

    --input-border-focus: rgba(8, 145, 178, 0.35);
    --input-focus-ring: rgba(8, 145, 178, 0.12);

    --badge-primary-bg: linear-gradient(
        135deg,
        rgba(8, 145, 178, 0.92),
        rgba(217, 119, 6, 0.86)
    );
    --badge-warm-bg: linear-gradient(
        135deg,
        rgba(217, 119, 6, 0.92),
        rgba(245, 158, 11, 0.8)
    );
    --badge-ghost-bg: rgba(8, 145, 178, 0.08);
    --badge-ghost-border: rgba(8, 145, 178, 0.18);
    --badge-text: rgba(255, 255, 255, 0.94);

    --logo-gradient: linear-gradient(
        135deg,
        rgba(8, 145, 178, 0.92),
        rgba(217, 119, 6, 0.86)
    );
    --logo-shadow:
        0 10px 26px rgba(8, 145, 178, 0.14), 0 10px 24px rgba(217, 119, 6, 0.12);

    --panel-header-bg: linear-gradient(
        180deg,
        rgba(8, 145, 178, 0.06),
        transparent
    );
    --card-hover-border: rgba(8, 145, 178, 0.24);
    --btn-primary-bg: linear-gradient(
        180deg,
        var(--primary-weak),
        var(--primary-weak-soft)
    );

    --rail-gradient: linear-gradient(
        180deg,
        rgba(8, 145, 178, 0),
        rgba(8, 145, 178, 0.4),
        rgba(217, 119, 6, 0.12),
        rgba(8, 145, 178, 0)
    );
    --rail-dot-bg: linear-gradient(
        135deg,
        rgba(8, 145, 178, 0.92),
        rgba(217, 119, 6, 0.86)
    );
    --rail-dot-shadow: 0 10px 18px rgba(217, 119, 6, 0.1);

    --if-box-border: rgba(217, 119, 6, 0.2);
    --if-box-bg: linear-gradient(
        135deg,
        rgba(217, 119, 6, 0.1),
        rgba(8, 145, 178, 0.06)
    );
    --if-chip-bg: rgba(217, 119, 6, 0.12);
    --if-chip-border: rgba(217, 119, 6, 0.18);
    --if-badge-border: rgba(22, 163, 74, 0.18);
}



================================================
FILE: builder/src/app/theme/themes/forest.css
================================================
/* forest theme overrides */
:root[data-theme="forest"] {
    --font-sans:
        "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;

    --label-font-size-base: 14px;
    --label-size-offset-xs: -4px;
    --label-size-offset-sm: -2px;
    --label-size-offset-lg: 2px;
    --label-size-offset-xl: 4px;

    /* forest floor */
    --bg: #f2f7f0;
    --surface: #ffffff;
    --surface-elevated: #ffffff;
    --surface-muted: #eaf3e6;
    --surface-subtle: #f7fbf5;
    --surface-alt: #dff0d7;

    --border: #cfe2c7;
    --border-muted: #dcecdf;
    --border-subtle: #eef6ee;
    --border-strong: #b6d1ad;

    --text: #0f172a;
    --text-strong: #0b1324;
    --text-ink: #1f2937;
    --text-muted: #64748b;
    --text-subtle: #6b7280;
    --text-faded: #94a3b8;

    /* deep green */
    --primary: #14532d;
    --primary-strong: #0a3d22;
    --primary-ink: #031a0f;
    --primary-ink-strong: #010e07;
    --primary-soft: #dcfce7;
    --primary-soft-strong: #bbf7d0;
    --primary-weak: rgba(20, 83, 45, 0.1);
    --primary-weak-soft: rgba(20, 83, 45, 0.06);
    --primary-border-soft: rgba(20, 83, 45, 0.22);

    /* earthy amber */
    --warm: #a16207;
    --warm-weak: rgba(161, 98, 7, 0.12);
    --warm-ink: #78350f;

    --success: #16a34a;
    --success-ink: #166534;
    --success-weak: rgba(22, 163, 74, 0.1);

    --danger: #e11d48;
    --danger-bright: #ef4444;
    --danger-strong: #dc2626;
    --danger-ink: #b91c1c;
    --danger-ink-strong: #991b1b;
    --danger-weak: #fef2f2;
    --danger-weak-strong: #fee2e2;
    --danger-border: #fecaca;
    --danger-border-strong: #fca5a5;

    --warning: #f59e0b;
    --warning-weak: #fef3c7;
    --warning-ink: #92400e;

    --info: #38bdf8;
    --info-weak: #e0f2fe;

    --radius-sm: 10px;
    --radius-md: 14px;
    --radius-lg: 18px;

    --shadow-sm: 0 2px 10px rgba(15, 23, 42, 0.06);
    --shadow-md: 0 16px 36px rgba(15, 23, 42, 0.12);
    --shadow-lg: 0 20px 45px rgba(15, 23, 42, 0.18);

    --overlay: rgba(15, 23, 42, 0.3);
    --overlay-strong: rgba(15, 23, 42, 0.52);

    --app-bg:
        radial-gradient(
            900px 520px at 12% -10%,
            rgba(20, 83, 45, 0.16),
            transparent 60%
        ),
        radial-gradient(
            900px 520px at 92% 0%,
            rgba(161, 98, 7, 0.1),
            transparent 62%
        ),
        radial-gradient(
            900px 520px at 52% 110%,
            rgba(187, 247, 208, 0.65),
            transparent 60%
        ),
        var(--bg);
    --app-header-bg: rgba(242, 247, 240, 0.84);

    --input-border-focus: rgba(20, 83, 45, 0.32);
    --input-focus-ring: rgba(20, 83, 45, 0.12);

    --badge-primary-bg: linear-gradient(
        135deg,
        rgba(20, 83, 45, 0.95),
        rgba(161, 98, 7, 0.84)
    );
    --badge-warm-bg: linear-gradient(
        135deg,
        rgba(161, 98, 7, 0.92),
        rgba(245, 158, 11, 0.78)
    );
    --badge-ghost-bg: rgba(20, 83, 45, 0.08);
    --badge-ghost-border: rgba(20, 83, 45, 0.18);
    --badge-text: rgba(255, 255, 255, 0.94);

    --logo-gradient: linear-gradient(
        135deg,
        rgba(20, 83, 45, 0.92),
        rgba(161, 98, 7, 0.86)
    );
    --logo-shadow:
        0 10px 26px rgba(20, 83, 45, 0.14), 0 10px 24px rgba(161, 98, 7, 0.1);

    --panel-header-bg: linear-gradient(
        180deg,
        rgba(20, 83, 45, 0.06),
        transparent
    );
    --card-hover-border: rgba(20, 83, 45, 0.18);
    --btn-primary-bg: linear-gradient(
        180deg,
        var(--primary-weak),
        var(--primary-weak-soft)
    );

    --rail-gradient: linear-gradient(
        180deg,
        rgba(20, 83, 45, 0),
        rgba(20, 83, 45, 0.38),
        rgba(161, 98, 7, 0.12),
        rgba(20, 83, 45, 0)
    );
    --rail-dot-bg: linear-gradient(
        135deg,
        rgba(20, 83, 45, 0.92),
        rgba(161, 98, 7, 0.86)
    );
    --rail-dot-shadow: 0 10px 18px rgba(20, 83, 45, 0.1);

    --if-box-border: rgba(20, 83, 45, 0.18);
    --if-box-bg: linear-gradient(
        135deg,
        rgba(20, 83, 45, 0.1),
        rgba(161, 98, 7, 0.06)
    );
    --if-chip-bg: rgba(20, 83, 45, 0.1);
    --if-chip-border: rgba(20, 83, 45, 0.16);
    --if-badge-border: rgba(245, 158, 11, 0.16);
}



================================================
FILE: builder/src/app/theme/themes/india.css
================================================
/* india theme overrides */
:root[data-theme="india"] {
    --font-sans:
        "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;

    --label-font-size-base: 14px;
    --label-size-offset-xs: -4px;
    --label-size-offset-sm: -2px;
    --label-size-offset-lg: 2px;
    --label-size-offset-xl: 4px;

    /* Bright base */
    --bg: #f8fafc;
    --surface: #ffffff;
    --surface-elevated: #ffffff;
    --surface-muted: #fff7ed; /* saffron-tint */
    --surface-subtle: #f0fdf4; /* green-tint */
    --surface-alt: #eff6ff; /* blue-tint */

    --border: #e2e8f0;
    --border-muted: #e5e7eb;
    --border-subtle: #f1f5f9;
    --border-strong: #cbd5e1;

    --text: #0f172a;
    --text-strong: #111827;
    --text-ink: #334155;
    --text-muted: #64748b;
    --text-subtle: #6b7280;
    --text-faded: #94a3b8;

    /* Ashoka navy */
    --primary: #1d4ed8;
    --primary-strong: #1e40af;
    --primary-ink: #1e3a8a;
    --primary-ink-strong: #172554;
    --primary-soft: #dbeafe;
    --primary-soft-strong: #bfdbfe;
    --primary-weak: rgba(29, 78, 216, 0.1);
    --primary-weak-soft: rgba(29, 78, 216, 0.06);
    --primary-border-soft: rgba(29, 78, 216, 0.22);

    /* Saffron */
    --warm: #f97316;
    --warm-weak: rgba(249, 115, 22, 0.12);
    --warm-ink: #9a3412;

    /* Green */
    --success: #16a34a;
    --success-ink: #166534;
    --success-weak: rgba(22, 163, 74, 0.1);

    --danger: #e11d48;
    --danger-bright: #ef4444;
    --danger-strong: #dc2626;
    --danger-ink: #b91c1c;
    --danger-ink-strong: #991b1b;
    --danger-weak: #fef2f2;
    --danger-weak-strong: #fee2e2;
    --danger-border: #fca5a5;
    --danger-border-strong: #fecaca;

    --warning: #f59e0b;
    --warning-weak: #fef3c7;
    --warning-ink: #92400e;

    --info: #38bdf8;
    --info-weak: #e0f2fe;

    --radius-sm: 10px;
    --radius-md: 14px;
    --radius-lg: 18px;

    --shadow-sm: 0 2px 10px rgba(15, 23, 42, 0.06);
    --shadow-md: 0 16px 36px rgba(15, 23, 42, 0.13);
    --shadow-lg: 0 20px 45px rgba(15, 23, 42, 0.22);

    --overlay: rgba(15, 23, 42, 0.35);
    --overlay-strong: rgba(15, 23, 42, 0.55);

    --app-bg:
        radial-gradient(
            900px 520px at 12% -10%,
            var(--warm-weak),
            transparent 60%
        ),
        radial-gradient(
            900px 520px at 92% 0%,
            rgba(22, 163, 74, 0.1),
            transparent 62%
        ),
        radial-gradient(
            900px 520px at 52% 110%,
            var(--primary-weak),
            transparent 60%
        ),
        var(--bg);
    --app-header-bg: rgba(248, 250, 252, 0.82);

    --input-border-focus: rgba(29, 78, 216, 0.35);
    --input-focus-ring: rgba(29, 78, 216, 0.12);

    --badge-primary-bg: linear-gradient(
        135deg,
        rgba(29, 78, 216, 0.95),
        rgba(249, 115, 22, 0.86)
    );
    --badge-warm-bg: linear-gradient(
        135deg,
        rgba(249, 115, 22, 0.92),
        rgba(245, 158, 11, 0.78)
    );
    --badge-ghost-bg: rgba(29, 78, 216, 0.08);
    --badge-ghost-border: rgba(29, 78, 216, 0.18);
    --badge-text: rgba(255, 255, 255, 0.94);

    --logo-gradient: linear-gradient(
        135deg,
        rgba(249, 115, 22, 0.92),
        rgba(29, 78, 216, 0.9)
    );
    --logo-shadow:
        0 10px 26px rgba(29, 78, 216, 0.16), 0 10px 24px rgba(249, 115, 22, 0.1);

    --panel-header-bg: linear-gradient(
        180deg,
        rgba(29, 78, 216, 0.06),
        transparent
    );
    --card-hover-border: rgba(29, 78, 216, 0.22);
    --btn-primary-bg: linear-gradient(
        180deg,
        var(--primary-weak),
        var(--primary-weak-soft)
    );

    --rail-gradient: linear-gradient(
        180deg,
        rgba(29, 78, 216, 0),
        rgba(29, 78, 216, 0.45),
        rgba(249, 115, 22, 0.12),
        rgba(29, 78, 216, 0)
    );
    --rail-dot-bg: linear-gradient(
        135deg,
        rgba(249, 115, 22, 0.92),
        rgba(29, 78, 216, 0.9)
    );
    --rail-dot-shadow: 0 10px 18px rgba(29, 78, 216, 0.12);

    --if-box-border: rgba(249, 115, 22, 0.2);
    --if-box-bg: linear-gradient(
        135deg,
        rgba(249, 115, 22, 0.1),
        rgba(29, 78, 216, 0.06)
    );
    --if-chip-bg: rgba(249, 115, 22, 0.12);
    --if-chip-border: rgba(249, 115, 22, 0.18);
    --if-badge-border: rgba(22, 163, 74, 0.18);
}



================================================
FILE: builder/src/app/theme/themes/matcha.css
================================================
/* matcha theme overrides */
:root[data-theme="matcha"] {
  --font-sans: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;

  --label-font-size-base: 14px;
  --label-size-offset-xs: -4px;
  --label-size-offset-sm: -2px;
  --label-size-offset-lg: 2px;
  --label-size-offset-xl: 4px;

  /* Surfaces (soft mint) */
  --bg: #f4fbf6;
  --surface: #ffffff;
  --surface-elevated: #ffffff;
  --surface-muted: #eaf7ef;
  --surface-subtle: #f8fffb;
  --surface-alt: #dff3e8;

  /* Borders */
  --border: #cfe8d7;
  --border-muted: #d9efe1;
  --border-subtle: #edf8f2;
  --border-strong: #a7d7bc;

  /* Text */
  --text: #0f172a;
  --text-strong: #111827;
  --text-ink: #334155;
  --text-muted: #64748b;
  --text-subtle: #6b7280;
  --text-faded: #94a3b8;

  /* Primary (matcha green) */
  --primary: #16a34a;
  --primary-strong: #15803d;
  --primary-ink: #14532d;
  --primary-ink-strong: #052e16;
  --primary-soft: #dcfce7;
  --primary-soft-strong: #bbf7d0;
  --primary-weak: rgba(22, 163, 74, 0.12);
  --primary-weak-soft: rgba(22, 163, 74, 0.06);
  --primary-border-soft: rgba(22, 163, 74, 0.24);

  /* Warm accent (yuzu amber) */
  --warm: #f59e0b;
  --warm-weak: rgba(245, 158, 11, 0.12);
  --warm-ink: #92400e;

  /* Status */
  --success: #10b981;
  --success-ink: #065f46;
  --success-weak: rgba(16, 185, 129, 0.10);

  --danger: #dc2626;
  --danger-bright: #ef4444;
  --danger-strong: #b91c1c;
  --danger-ink: #991b1b;
  --danger-ink-strong: #7f1d1d;
  --danger-weak: #fef2f2;
  --danger-weak-strong: #fee2e2;
  --danger-border: #fecaca;
  --danger-border-strong: #fca5a5;

  --warning: #f59e0b;
  --warning-weak: #fef3c7;
  --warning-ink: #92400e;

  --info: #38bdf8;
  --info-weak: #e0f2fe;

  /* Shape + shadows (same “soft” profile as sakura) */
  --radius-sm: 10px;
  --radius-md: 14px;
  --radius-lg: 18px;

  --shadow-sm: 0 2px 10px rgba(15, 23, 42, 0.06);
  --shadow-md: 0 16px 36px rgba(15, 23, 42, 0.13);
  --shadow-lg: 0 20px 45px rgba(15, 23, 42, 0.22);

  --overlay: rgba(15, 23, 42, 0.35);
  --overlay-strong: rgba(15, 23, 42, 0.55);

  /* App chrome */
  --app-bg:
    radial-gradient(900px 520px at 12% -10%, var(--primary-weak), transparent 60%),
    radial-gradient(900px 520px at 92% 0%, var(--warm-weak), transparent 62%),
    var(--bg);
  --app-header-bg: rgba(244, 251, 246, 0.78);

  /* Focus ring */

  /* Badges / logo / panels */
  --badge-primary-bg: linear-gradient(135deg, rgba(22, 163, 74, 0.92), rgba(22, 163, 74, 0.76));
  --badge-warm-bg: linear-gradient(135deg, rgba(245, 158, 11, 0.90), rgba(245, 158, 11, 0.76));
  --badge-ghost-bg: rgba(22, 163, 74, 0.08);
  --badge-ghost-border: rgba(22, 163, 74, 0.18);
  --badge-text: rgba(255, 255, 255, 0.94);

  --logo-gradient: linear-gradient(135deg, rgba(22, 163, 74, 0.92), rgba(245, 158, 11, 0.85));
  --logo-shadow: 0 10px 26px rgba(22, 163, 74, 0.14), 0 10px 24px rgba(245, 158, 11, 0.10);

  --panel-header-bg: linear-gradient(180deg, rgba(22, 163, 74, 0.06), transparent);
  --btn-primary-bg: linear-gradient(180deg, var(--primary-weak), var(--primary-weak-soft));

  /* Hierarchy rails (used by preview-overrides.css) */
  --rail-gradient: linear-gradient(
    180deg,
    rgba(22, 163, 74, 0),
    rgba(22, 163, 74, 0.45),
    rgba(245, 158, 11, 0.12),
    rgba(22, 163, 74, 0)
  );
  --rail-dot-bg: linear-gradient(135deg, rgba(22, 163, 74, 0.95), rgba(245, 158, 11, 0.85));
  --rail-dot-shadow: 0 10px 18px rgba(22, 163, 74, 0.14), 0 12px 26px rgba(245, 158, 11, 0.12);

  /* If box / chips */
  --if-box-border: rgba(22, 163, 74, 0.18);
  --if-box-bg: linear-gradient(135deg, rgba(22, 163, 74, 0.08), rgba(245, 158, 11, 0.10));
  --if-chip-bg: rgba(245, 158, 11, 0.12);
  --if-chip-border: rgba(245, 158, 11, 0.18);
  --if-badge-border: rgba(16, 185, 129, 0.18);





}



================================================
FILE: builder/src/app/theme/themes/ocean.css
================================================
/* ocean theme overrides */
:root[data-theme="ocean"] {
    --font-sans:
        "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;

    --label-font-size-base: 14px;
    --label-size-offset-xs: -4px;
    --label-size-offset-sm: -2px;
    --label-size-offset-lg: 2px;
    --label-size-offset-xl: 4px;

    /* Base background + surfaces (deep ocean) */
    --bg: #071421;
    --surface: rgba(255, 255, 255, 0.08);
    --surface-elevated: rgba(255, 255, 255, 0.1);
    --surface-muted: rgba(255, 255, 255, 0.06);
    --surface-subtle: rgba(255, 255, 255, 0.04);
    --surface-alt: rgba(255, 255, 255, 0.12);

    /* Borders */
    --border: rgba(255, 255, 255, 0.14);
    --border-muted: rgba(255, 255, 255, 0.12);
    --border-subtle: rgba(255, 255, 255, 0.08);
    --border-strong: rgba(255, 255, 255, 0.18);

    /* Text */
    --text: #e6f3ff;
    --text-strong: #f1f7ff;
    --text-ink: #cfe6ff;
    --text-muted: rgba(207, 230, 255, 0.78);
    --text-subtle: rgba(207, 230, 255, 0.7);
    --text-faded: rgba(207, 230, 255, 0.58);

    /* Primary (cyan) */
    --primary: #22d3ee;
    --primary-strong: #06b6d4;
    --primary-ink: #a5f3fc;
    --primary-ink-strong: #cffafe;
    --primary-soft: rgba(34, 211, 238, 0.22);
    --primary-soft-strong: rgba(34, 211, 238, 0.32);
    --primary-weak: rgba(34, 211, 238, 0.18);
    --primary-weak-soft: rgba(34, 211, 238, 0.12);
    --primary-border-soft: rgba(34, 211, 238, 0.35);

    /* Warm accent (violet) */
    --warm: #a78bfa;
    --warm-weak: rgba(167, 139, 250, 0.18);
    --warm-ink: #ddd6fe;

    /* Status */
    --success: #34d399;
    --success-ink: #d1fae5;
    --success-weak: rgba(52, 211, 153, 0.14);

    --danger: #fb7185;
    --danger-bright: #fb7185;
    --danger-strong: #f43f5e;
    --danger-ink: #fecdd3;
    --danger-ink-strong: #fda4af;
    --danger-weak: rgba(251, 113, 133, 0.16);
    --danger-weak-strong: rgba(251, 113, 133, 0.22);
    --danger-border: rgba(251, 113, 133, 0.3);
    --danger-border-strong: rgba(251, 113, 133, 0.38);

    --warning: #fbbf24;
    --warning-weak: rgba(251, 191, 36, 0.16);
    --warning-ink: #fcd34d;

    --info: #38bdf8;
    --info-weak: rgba(56, 189, 248, 0.16);

    /* Radius + shadows */
    --radius-sm: 10px;
    --radius-md: 14px;
    --radius-lg: 16px;

    --shadow-sm: 0 2px 10px rgba(0, 0, 0, 0.22);
    --shadow-md: 0 18px 45px rgba(0, 0, 0, 0.42);
    --shadow-lg: 0 26px 60px rgba(0, 0, 0, 0.52);

    /* Overlays */
    --overlay: rgba(3, 8, 14, 0.6);
    --overlay-strong: rgba(3, 8, 14, 0.78);

    /* App chrome */
    --app-bg:
        radial-gradient(
            900px 520px at 14% -10%,
            rgba(34, 211, 238, 0.42),
            transparent 60%
        ),
        radial-gradient(
            900px 520px at 92% 6%,
            rgba(167, 139, 250, 0.35),
            transparent 62%
        ),
        radial-gradient(
            700px 420px at 60% 120%,
            rgba(52, 211, 153, 0.16),
            transparent 60%
        ),
        var(--bg);
    --app-header-bg: rgba(6, 14, 24, 0.68);

    /* Focus ring */

    /* Badges / logo / panels */
    --badge-primary-bg: linear-gradient(
        135deg,
        rgba(34, 211, 238, 0.95),
        rgba(167, 139, 250, 0.92)
    );
    --badge-warm-bg: linear-gradient(
        135deg,
        rgba(167, 139, 250, 0.95),
        rgba(251, 191, 36, 0.86)
    );
    --badge-ghost-bg: rgba(255, 255, 255, 0.08);
    --badge-ghost-border: rgba(255, 255, 255, 0.16);
    --badge-text: rgba(255, 255, 255, 0.92);

    --logo-gradient: linear-gradient(
        135deg,
        rgba(34, 211, 238, 0.95),
        rgba(167, 139, 250, 0.92)
    );
    --logo-shadow:
        0 8px 24px rgba(34, 211, 238, 0.22),
        0 10px 28px rgba(167, 139, 250, 0.18);

    --panel-header-bg: linear-gradient(
        180deg,
        rgba(255, 255, 255, 0.06),
        transparent
    );
    --btn-primary-bg: linear-gradient(
        135deg,
        rgba(34, 211, 238, 0.22),
        rgba(167, 139, 250, 0.18)
    );

    /* Hierarchy rails (used by preview-overrides.css) */
    --rail-gradient: linear-gradient(
        180deg,
        rgba(34, 211, 238, 0),
        rgba(34, 211, 238, 0.55),
        rgba(167, 139, 250, 0.45),
        rgba(167, 139, 250, 0)
    );
    --rail-dot-bg: linear-gradient(
        135deg,
        rgba(34, 211, 238, 0.95),
        rgba(167, 139, 250, 0.92)
    );

    /* IF box */
    --if-box-border: rgba(255, 255, 255, 0.12);
    --if-box-bg: linear-gradient(
        135deg,
        rgba(34, 211, 238, 0.16),
        rgba(167, 139, 250, 0.12)
    );
    --if-chip-bg: rgba(255, 255, 255, 0.1);
    --if-chip-border: rgba(255, 255, 255, 0.14);
    --if-badge-border: rgba(52, 211, 153, 0.22);
}
/* nfb:select-popup-contrast:ocean */
:root[data-theme="ocean"] {
  color-scheme: dark;
}

/* Fallback: some browsers style the popup via option/optgroup */
:root[data-theme="ocean"] select {
  color-scheme: dark;
}
:root[data-theme="ocean"] select option,
:root[data-theme="ocean"] select optgroup {
  background-color: var(--bg);
  color: var(--text);
}



================================================
FILE: builder/src/app/theme/themes/sakura.css
================================================
/* sakura theme overrides */
:root[data-theme="sakura"] {
  --font-sans: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  --label-font-size-base: 14px;
  --label-size-offset-xs: -4px;
  --label-size-offset-sm: -2px;
  --label-size-offset-lg: 2px;
  --label-size-offset-xl: 4px;

  --bg: #fff7fb;
  --surface: #ffffff;
  --surface-elevated: #ffffff;
  --surface-muted: #fff1f7;
  --surface-subtle: #fffbfd;
  --surface-alt: #fde7f3;

  --border: #f2dbe7;
  --border-muted: #f6e6ee;
  --border-subtle: #faeff4;
  --border-strong: #d8b4c9;

  --text: #0f172a;
  --text-strong: #111827;
  --text-ink: #334155;
  --text-muted: #64748b;
  --text-subtle: #6b7280;
  --text-faded: #94a3b8;

  --primary: #db2777;
  --primary-strong: #be185d;
  --primary-ink: #831843;
  --primary-ink-strong: #500724;
  --primary-soft: #fce7f3;
  --primary-soft-strong: #fbcfe8;
  --primary-weak: rgba(219, 39, 119, 0.12);
  --primary-weak-soft: rgba(219, 39, 119, 0.06);
  --primary-border-soft: rgba(219, 39, 119, 0.24);

  --warm: #f59e0b;
  --warm-weak: rgba(245, 158, 11, 0.12);
  --warm-ink: #92400e;

  --success: #16a34a;
  --success-ink: #166534;
  --success-weak: rgba(22, 163, 74, 0.10);

  --danger: #dc2626;
  --danger-bright: #ef4444;
  --danger-strong: #b91c1c;
  --danger-ink: #991b1b;
  --danger-ink-strong: #7f1d1d;
  --danger-weak: #fef2f2;
  --danger-weak-strong: #fee2e2;
  --danger-border: #fecaca;
  --danger-border-strong: #fca5a5;

  --warning: #f59e0b;
  --warning-weak: #fef3c7;
  --warning-ink: #92400e;

  --info: #38bdf8;
  --info-weak: #e0f2fe;

  --radius-sm: 10px;
  --radius-md: 14px;
  --radius-lg: 18px;

  --shadow-sm: 0 2px 10px rgba(15, 23, 42, 0.06);
  --shadow-md: 0 16px 36px rgba(15, 23, 42, 0.13);
  --shadow-lg: 0 20px 45px rgba(15, 23, 42, 0.22);

  --overlay: rgba(15, 23, 42, 0.35);
  --overlay-strong: rgba(15, 23, 42, 0.55);

  --logo-gradient: linear-gradient(135deg, rgba(219, 39, 119, 0.92), rgba(245, 158, 11, 0.85));
  --logo-shadow: 0 10px 26px rgba(219, 39, 119, 0.14), 0 10px 24px rgba(245, 158, 11, 0.10);

  --app-bg: radial-gradient(900px 520px at 12% -10%, var(--primary-weak), transparent 60%),
    radial-gradient(900px 520px at 92% 0%, var(--warm-weak), transparent 62%),
    var(--bg);
  --app-header-bg: rgba(255, 247, 251, 0.78);

  --panel-header-bg: linear-gradient(180deg, rgba(219, 39, 119, 0.06), transparent);

  --btn-primary-bg: linear-gradient(180deg, var(--primary-weak), var(--primary-weak-soft));

  --badge-primary-bg: linear-gradient(135deg, rgba(219, 39, 119, 0.92), rgba(219, 39, 119, 0.76));
  --badge-warm-bg: linear-gradient(135deg, rgba(245, 158, 11, 0.90), rgba(245, 158, 11, 0.76));
  --badge-ghost-bg: rgba(219, 39, 119, 0.08);
  --badge-ghost-border: rgba(219, 39, 119, 0.18);
  --badge-text: rgba(255, 255, 255, 0.94);

  --if-box-border: rgba(219, 39, 119, 0.18);
  --if-box-bg: linear-gradient(135deg, rgba(219, 39, 119, 0.08), rgba(245, 158, 11, 0.10));
  --if-chip-bg: rgba(245, 158, 11, 0.12);
  --if-chip-border: rgba(245, 158, 11, 0.18);
  --if-badge-border: rgba(22, 163, 74, 0.18);





}



================================================
FILE: builder/src/app/theme/themes/snow.css
================================================
/* snow theme overrides */
:root[data-theme="snow"] {
    --font-sans:
        "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;

    --label-font-size-base: 14px;
    --label-size-offset-xs: -4px;
    --label-size-offset-sm: -2px;
    --label-size-offset-lg: 2px;
    --label-size-offset-xl: 4px;

    --bg: #f6fbff;
    --surface: #ffffff;
    --surface-elevated: #ffffff;
    --surface-muted: #eef6ff;
    --surface-subtle: #f9fcff;
    --surface-alt: #e6f1ff;

    --border: #d7e6ff;
    --border-muted: #e3efff;
    --border-subtle: #f1f7ff;
    --border-strong: #c0d6ff;

    --text: #0f172a;
    --text-strong: #0b1324;
    --text-ink: #1f2a44;
    --text-muted: #5b6b86;
    --text-subtle: #6a7a94;
    --text-faded: #94a3b8;

    /* icy blue */
    --primary: #2563eb;
    --primary-strong: #1d4ed8;
    --primary-ink: #1e3a8a;
    --primary-ink-strong: #172554;
    --primary-soft: #dbeafe;
    --primary-soft-strong: #bfdbfe;
    --primary-weak: rgba(37, 99, 235, 0.1);
    --primary-weak-soft: rgba(37, 99, 235, 0.06);
    --primary-border-soft: rgba(37, 99, 235, 0.22);

    --warm: #0ea5e9;
    --warm-weak: rgba(14, 165, 233, 0.1);
    --warm-ink: #075985;

    --success: #16a34a;
    --success-ink: #166534;
    --success-weak: rgba(22, 163, 74, 0.1);

    --danger: #e11d48;
    --danger-bright: #ef4444;
    --danger-strong: #dc2626;
    --danger-ink: #b91c1c;
    --danger-ink-strong: #991b1b;
    --danger-weak: #fef2f2;
    --danger-weak-strong: #fee2e2;
    --danger-border: #fecaca;
    --danger-border-strong: #fca5a5;

    --warning: #f59e0b;
    --warning-weak: #fef3c7;
    --warning-ink: #92400e;

    --info: #38bdf8;
    --info-weak: #e0f2fe;

    --radius-sm: 10px;
    --radius-md: 14px;
    --radius-lg: 18px;

    --shadow-sm: 0 2px 10px rgba(15, 23, 42, 0.06);
    --shadow-md: 0 16px 36px rgba(15, 23, 42, 0.12);
    --shadow-lg: 0 20px 45px rgba(15, 23, 42, 0.18);

    --overlay: rgba(15, 23, 42, 0.28);
    --overlay-strong: rgba(15, 23, 42, 0.46);

    --app-bg:
        radial-gradient(
            900px 520px at 12% -10%,
            rgba(37, 99, 235, 0.16),
            transparent 60%
        ),
        radial-gradient(
            900px 520px at 92% 0%,
            rgba(14, 165, 233, 0.12),
            transparent 62%
        ),
        radial-gradient(
            900px 520px at 52% 110%,
            rgba(191, 219, 254, 0.6),
            transparent 60%
        ),
        var(--bg);
    --app-header-bg: rgba(246, 251, 255, 0.84);

    --input-border-focus: rgba(37, 99, 235, 0.35);
    --input-focus-ring: rgba(37, 99, 235, 0.12);

    --badge-primary-bg: linear-gradient(
        135deg,
        rgba(37, 99, 235, 0.95),
        rgba(14, 165, 233, 0.86)
    );
    --badge-warm-bg: linear-gradient(
        135deg,
        rgba(14, 165, 233, 0.92),
        rgba(56, 189, 248, 0.8)
    );
    --badge-ghost-bg: rgba(37, 99, 235, 0.08);
    --badge-ghost-border: rgba(37, 99, 235, 0.18);
    --badge-text: rgba(255, 255, 255, 0.94);

    --logo-gradient: linear-gradient(
        135deg,
        rgba(37, 99, 235, 0.92),
        rgba(14, 165, 233, 0.9)
    );
    --logo-shadow:
        0 10px 26px rgba(37, 99, 235, 0.14), 0 10px 24px rgba(14, 165, 233, 0.1);

    --panel-header-bg: linear-gradient(
        180deg,
        rgba(37, 99, 235, 0.06),
        transparent
    );
    --card-hover-border: rgba(37, 99, 235, 0.2);
    --btn-primary-bg: linear-gradient(
        180deg,
        var(--primary-weak),
        var(--primary-weak-soft)
    );

    --rail-gradient: linear-gradient(
        180deg,
        rgba(37, 99, 235, 0),
        rgba(37, 99, 235, 0.4),
        rgba(14, 165, 233, 0.14),
        rgba(37, 99, 235, 0)
    );
    --rail-dot-bg: linear-gradient(
        135deg,
        rgba(37, 99, 235, 0.92),
        rgba(14, 165, 233, 0.86)
    );
    --rail-dot-shadow: 0 10px 18px rgba(37, 99, 235, 0.1);

    --if-box-border: rgba(37, 99, 235, 0.18);
    --if-box-bg: linear-gradient(
        135deg,
        rgba(37, 99, 235, 0.1),
        rgba(14, 165, 233, 0.06)
    );
    --if-chip-bg: rgba(37, 99, 235, 0.1);
    --if-chip-border: rgba(37, 99, 235, 0.16);
    --if-badge-border: rgba(22, 163, 74, 0.16);
}



================================================
FILE: builder/src/app/theme/themes/standard.css
================================================
/* balanced theme overrides (standard tokens are defined in theme.css) */
:root[data-theme="standard"] {
}



================================================
FILE: builder/src/app/theme/themes/warm.css
================================================
/* warm theme overrides */
:root[data-theme="warm"] {
  --font-sans: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;

  --label-font-size-base: 14px;
  --label-size-offset-xs: -4px;
  --label-size-offset-sm: -2px;
  --label-size-offset-lg: 2px;
  --label-size-offset-xl: 4px;

  --bg: #0b1020;
  --surface: rgba(255, 255, 255, 0.08);
  --surface-elevated: rgba(255, 255, 255, 0.1);
  --surface-muted: rgba(255, 255, 255, 0.06);
  --surface-subtle: rgba(255, 255, 255, 0.04);
  --surface-alt: rgba(255, 255, 255, 0.12);

  --border: rgba(255, 255, 255, 0.14);
  --border-muted: rgba(255, 255, 255, 0.12);
  --border-subtle: rgba(255, 255, 255, 0.08);
  --border-strong: rgba(255, 255, 255, 0.18);

  --text: #eef2ff;
  --text-strong: #f8fafc;
  --text-ink: #e2e8f0;
  --text-muted: rgba(226, 232, 240, 0.78);
  --text-subtle: rgba(226, 232, 240, 0.72);
  --text-faded: rgba(226, 232, 240, 0.6);

  --primary: #5b8cff;
  --primary-strong: #4f7ef8;
  --primary-ink: #c7d2fe;
  --primary-ink-strong: #e0e7ff;
  --primary-soft: rgba(91, 140, 255, 0.22);
  --primary-soft-strong: rgba(91, 140, 255, 0.32);
  --primary-weak: rgba(91, 140, 255, 0.18);
  --primary-weak-soft: rgba(91, 140, 255, 0.12);
  --primary-border-soft: rgba(91, 140, 255, 0.35);

  --warm: #ff7a59;
  --warm-weak: rgba(255, 122, 89, 0.18);
  --warm-ink: #fed7aa;

  --success: #34d399;
  --success-ink: #d1fae5;
  --success-weak: rgba(52, 211, 153, 0.14);

  --danger: #fb7185;
  --danger-bright: #fb7185;
  --danger-strong: #f43f5e;
  --danger-ink: #fecdd3;
  --danger-ink-strong: #fda4af;
  --danger-weak: rgba(251, 113, 133, 0.16);
  --danger-weak-strong: rgba(251, 113, 133, 0.22);
  --danger-border: rgba(251, 113, 133, 0.3);
  --danger-border-strong: rgba(251, 113, 133, 0.38);

  --warning: #fbbf24;
  --warning-weak: rgba(251, 191, 36, 0.16);
  --warning-ink: #fcd34d;

  --info: #38bdf8;
  --info-weak: rgba(56, 189, 248, 0.16);

  --radius-sm: 10px;
  --radius-md: 14px;
  --radius-lg: 16px;

  --shadow-sm: 0 2px 10px rgba(0, 0, 0, 0.22);
  --shadow-md: 0 18px 45px rgba(0, 0, 0, 0.42);
  --shadow-lg: 0 26px 60px rgba(0, 0, 0, 0.5);

  --overlay: rgba(5, 8, 16, 0.6);
  --overlay-strong: rgba(5, 8, 16, 0.75);

  --app-bg:
    radial-gradient(900px 500px at 15% -10%, rgba(91, 140, 255, 0.45), transparent 60%),
    radial-gradient(900px 500px at 90% 10%, rgba(255, 122, 89, 0.38), transparent 62%),
    radial-gradient(700px 420px at 60% 120%, rgba(52, 211, 153, 0.18), transparent 60%),
    var(--bg);
  --app-header-bg: rgba(9, 12, 24, 0.65);


  --badge-primary-bg: linear-gradient(135deg, rgba(91, 140, 255, 0.95), rgba(255, 122, 89, 0.92));
  --badge-warm-bg: linear-gradient(135deg, rgba(255, 122, 89, 0.96), rgba(250, 204, 21, 0.86));
  --badge-ghost-bg: rgba(255, 255, 255, 0.08);
  --badge-ghost-border: rgba(255, 255, 255, 0.16);
  --badge-text: rgba(255, 255, 255, 0.92);

  --logo-gradient: linear-gradient(135deg, rgba(91, 140, 255, 0.95), rgba(255, 122, 89, 0.92));
  --logo-shadow: 0 8px 24px rgba(91, 140, 255, 0.24), 0 10px 28px rgba(255, 122, 89, 0.18);
  --panel-header-bg: linear-gradient(180deg, rgba(255, 255, 255, 0.06), transparent);
  --btn-primary-bg: linear-gradient(135deg, rgba(91, 140, 255, 0.25), rgba(255, 122, 89, 0.22));
  --rail-gradient: linear-gradient(
    180deg,
    rgba(91, 140, 255, 0),
    rgba(91, 140, 255, 0.55),
    rgba(255, 122, 89, 0.45),
    rgba(255, 122, 89, 0)
  );
  --rail-dot-bg: linear-gradient(135deg, rgba(91, 140, 255, 0.95), rgba(255, 122, 89, 0.92));
  --rail-dot-shadow: 0 10px 22px rgba(91, 140, 255, 0.22), 0 12px 26px rgba(255, 122, 89, 0.16);
  --if-box-border: rgba(255, 255, 255, 0.12);
  --if-box-bg: linear-gradient(135deg, rgba(91, 140, 255, 0.16), rgba(255, 122, 89, 0.12));
  --if-chip-bg: rgba(255, 255, 255, 0.1);
  --if-chip-border: rgba(255, 255, 255, 0.14);
  --if-badge-border: rgba(52, 211, 153, 0.22);





}
/* nfb:select-popup-contrast:warm */
:root[data-theme="warm"] {
  color-scheme: dark;
}

/* Fallback: some browsers style the popup via option/optgroup */
:root[data-theme="warm"] select {
  color-scheme: dark;
}
:root[data-theme="warm"] select option,
:root[data-theme="warm"] select optgroup {
  background-color: var(--bg);
  color: var(--text);
}



================================================
FILE: builder/src/core/collect.js
================================================
import { traverseSchema } from "./schemaUtils.js";

export const collectResponses = (fields, responses) => {
  const out = {};
  const orderList = [];

  traverseSchema(fields, (field, context) => {
    const value = responses?.[field.id];
    const base = context.pathSegments.join("|");

    if (field.type === "checkboxes" && Array.isArray(value)) {
      value.forEach((lbl) => {
        const key = `${base}|${lbl}`;
        out[key] = "●";
        orderList.push(key);
      });
    } else if (["radio", "select"].includes(field.type) && typeof value === "string" && value) {
      const key = `${base}|${value}`;
      out[key] = "●";
      orderList.push(key);
    } else if (["text", "textarea", "number", "regex", "date", "time", "url", "userName", "email"].includes(field.type) && value != null && value !== "") {
      out[base] = value;
      orderList.push(base);
    }
  }, { responses });

  return out;
};

export const collectAllPossiblePaths = (fields) => {
  const paths = [];

  traverseSchema(fields, (field, context) => {
    const base = context.pathSegments.join("|");

    if (["checkboxes", "radio", "select"].includes(field.type) && Array.isArray(field.options)) {
      field.options.forEach((option) => {
        const optionLabel = option.label || "";
        paths.push(`${base}|${optionLabel}`);
      });
    } else if (["text", "textarea", "number", "regex", "date", "time", "url", "userName", "email"].includes(field.type)) {
      paths.push(base);
    }
  });

  return paths;
};

export const sortResponses = (responses, schema = null) => {
  const source = responses || {};

  if (schema) {
    const allPaths = collectAllPossiblePaths(schema);
    const sorted = {};
    allPaths.forEach((key) => {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        sorted[key] = source[key];
      }
    });
    return { map: sorted, keys: allPaths };
  }

  const keys = Object.keys(source).sort((a, b) => String(a).localeCompare(String(b), "ja"));
  const sorted = {};
  keys.forEach((key) => {
    sorted[key] = source[key];
  });
  return { map: sorted, keys };
};



================================================
FILE: builder/src/core/constants.js
================================================
// UI・動作関連
export const MAX_DEPTH = 11;
export const DEFAULT_PAGE_SIZE = 20;
export const DEFAULT_SHEET_NAME = "Data";

// IndexedDB ストレージ関連
export const DB_NAME = "NestedFormBuilder";
export const DB_VERSION = 4;
export const STORE_NAMES = {
  forms: "formsCache",
  records: "recordsCache",
  recordsMeta: "recordsCacheMeta",
  settings: "settingsStore",
};

// キャッシュポリシー（ミリ秒）
export const RECORD_CACHE_MAX_AGE_MS = 5 * 60 * 1000;
export const RECORD_CACHE_BACKGROUND_REFRESH_MS = 1 * 60 * 1000;
export const FORM_CACHE_MAX_AGE_MS = 60 * 60 * 1000;
export const FORM_CACHE_BACKGROUND_REFRESH_MS = 10 * 60 * 1000;

// 日時処理関連
export const MS_PER_DAY = 24 * 60 * 60 * 1000;
export const SERIAL_EPOCH_UTC_MS = Date.UTC(1899, 11, 30);
export const JST_OFFSET_MS = 9 * 60 * 60 * 1000;



================================================
FILE: builder/src/core/displayModes.js
================================================
const TRUE_LIKE_VALUES = new Set(["true", "1", "yes", "on"]);
const FALSE_LIKE_VALUES = new Set(["false", "0", "no", "off", ""]);

const toBoolean = (value) => {
  if (typeof value === "boolean") return value;
  if (typeof value === "number") return value !== 0;
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase();
    if (TRUE_LIKE_VALUES.has(normalized)) return true;
    if (FALSE_LIKE_VALUES.has(normalized)) return false;
  }
  return !!value;
};

/**
 * 表示可否を isDisplayed に正規化して解決する。
 * 旧データ移行ルール:
 * 1. isDisplayed が存在する場合はその値を採用
 * 2. displayMode が存在する場合は "none" 以外を true
 * 3. important が存在する場合は truthy を true
 * 4. 何もなければ false
 */
export const resolveIsDisplayed = (field) => {
  const target = field || {};
  if (Object.prototype.hasOwnProperty.call(target, "isDisplayed")) {
    return toBoolean(target.isDisplayed);
  }
  if (Object.prototype.hasOwnProperty.call(target, "displayMode")) {
    const rawMode = target.displayMode;
    if (typeof rawMode === "string") {
      return rawMode.toLowerCase() !== "none";
    }
    return rawMode !== "none";
  }
  if (Object.prototype.hasOwnProperty.call(target, "important")) {
    return toBoolean(target.important);
  }
  return false;
};



================================================
FILE: builder/src/core/ids.js
================================================
export const genId = () => `f_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;



================================================
FILE: builder/src/core/schema.js
================================================
import { genId } from "./ids.js";
import { resolveIsDisplayed } from "./displayModes.js";
import { DEFAULT_STYLE_SETTINGS, normalizeStyleSettings } from "./styleSettings.js";
import { MAX_DEPTH } from "./constants.js";
import { mapSchema, traverseSchema } from "./schemaUtils.js";

const sanitizeOptionLabel = (label) => (/^選択肢\d+$/.test(label || "") ? "" : label || "");

export const SCHEMA_STORAGE_KEY = "nested_form_builder_schema_slim_v1";
export { MAX_DEPTH };

export const sampleSchema = () => [
  {
    id: genId(),
    type: "checkboxes",
    label: "好きな果物？",
    options: [
      { id: genId(), label: "リンゴ" },
      { id: genId(), label: "みかん" },
      { id: genId(), label: "ぶどう" },
    ],
    childrenByValue: {
      "リンゴ": [
        { id: genId(), type: "regex", label: "どれくらい食べる？", pattern: "^.+$", required: false, placeholder: "例: 1日1個" },
      ],
      "みかん": [
        {
          id: genId(),
          type: "select",
          label: "何個食べる？",
          options: [
            { id: genId(), label: "１個" },
            { id: genId(), label: "２個" },
            { id: genId(), label: "３個以上" },
          ],
        },
      ],
    },
  },
];

export const deepClone = (value) => {
  if (typeof structuredClone === "function") return structuredClone(value);
  return JSON.parse(JSON.stringify(value));
};

export const normalizeSchemaIDs = (nodes) => {
  return mapSchema(nodes, (field) => {
    const id = field.id || genId();
    const base = { ...field, id };

    if (["radio", "select", "checkboxes"].includes(base.type)) {
      base.options = (base.options || []).map((opt) => ({
        id: opt?.id || genId(),
        label: sanitizeOptionLabel(opt?.label),
      }));
      delete base.pattern;
      delete base.defaultNow;
    } else if (base.type === "regex") {
      delete base.options;
      base.pattern = typeof base.pattern === "string" ? base.pattern : "";
      delete base.defaultNow;
    } else if (["date", "time"].includes(base.type)) {
      delete base.options;
      delete base.pattern;
      base.defaultNow = !!base.defaultNow;
    } else if (base.type === "userName") {
      delete base.options;
      delete base.pattern;
      delete base.placeholder;
      delete base.showPlaceholder;
      base.defaultNow = !!base.defaultNow;
    } else if (base.type === "email") {
      delete base.options;
      delete base.pattern;
      delete base.placeholder;
      delete base.showPlaceholder;
      base.defaultNow = !!base.defaultNow;
    } else if (base.type === "message") {
      delete base.options;
      delete base.pattern;
      delete base.defaultNow;
      delete base.required;
      delete base.placeholder;
      delete base.showPlaceholder;
    } else {
      delete base.options;
      delete base.pattern;
      delete base.defaultNow;
    }

    base.isDisplayed = resolveIsDisplayed(base);
    delete base.displayMode;
    delete base.important;
    delete base.compact;

    if (base.placeholder !== undefined && base.showPlaceholder === undefined) {
      base.showPlaceholder = true;
    }

    if (Object.prototype.hasOwnProperty.call(base, "showStyleSettings")) {
      if (typeof base.showStyleSettings === "string") {
        const lowered = base.showStyleSettings.toLowerCase();
        if (lowered === "true") base.showStyleSettings = true;
        else if (lowered === "false") base.showStyleSettings = false;
        else base.showStyleSettings = !!base.showStyleSettings;
      } else {
        base.showStyleSettings = !!base.showStyleSettings;
      }
    } else if (base.styleSettings && typeof base.styleSettings === "object") {
      base.showStyleSettings = true;
    }

    const hasExplicitShowStyleSettings = typeof base.showStyleSettings === "boolean";
    const shouldKeepStyleSettings = hasExplicitShowStyleSettings ? base.showStyleSettings : !!base.styleSettings;
    if (shouldKeepStyleSettings && (!base.styleSettings || typeof base.styleSettings !== "object")) {
      base.styleSettings = { ...DEFAULT_STYLE_SETTINGS };
    } else if (shouldKeepStyleSettings && base.styleSettings && typeof base.styleSettings === "object") {
      base.styleSettings = normalizeStyleSettings(base.styleSettings);
    } else {
      delete base.styleSettings;
    }

    if (hasExplicitShowStyleSettings) {
      base.showStyleSettings = !!base.showStyleSettings;
    } else if (base.styleSettings) {
      base.showStyleSettings = true;
    } else {
      delete base.showStyleSettings;
    }

    delete base._savedChoiceState;
    delete base._savedStyleSettings;
    delete base._savedChildrenForChoice;
    delete base._savedDisplayModeForChoice;

    return base;
  });
};

export const stripSchemaIDs = (nodes) => {
  return mapSchema(nodes, (field) => {
    const { id, ...rest } = field;
    const base = { ...rest };

    if (["radio", "select", "checkboxes"].includes(base.type) && Array.isArray(base.options)) {
      base.options = base.options.map(({ id: optId, ...optRest }) => optRest);
    }

    delete base._savedChoiceState;
    delete base._savedStyleSettings;
    delete base._savedChildrenForChoice;
    delete base._savedDisplayModeForChoice;

    return base;
  });
};

export const maxDepthOf = (fields) => {
  let max = 0;
  traverseSchema(fields, (field, context) => {
    max = Math.max(max, context.depth);
  });
  return max;
};

export const validateMaxDepth = (fields, max = MAX_DEPTH) => {
  const depth = maxDepthOf(fields);
  return depth <= max ? { ok: true, depth } : { ok: false, depth };
};

export const validateUniqueLabels = (fields) => {
  const seen = new Set();
  for (const field of fields || []) {
    const label = (field.label || "").trim();
    if (!label) continue;
    if (seen.has(label)) return { ok: false, dup: label };
    seen.add(label);
  }
  return { ok: true };
};

export const validateRequiredLabels = (fields, { responses = null, visibleOnly = false } = {}) => {
  const emptyLabels = [];

  traverseSchema(fields, (field, context) => {
    if (visibleOnly && field?.isDisplayed !== true) return false;

    const label = (field?.label || "").trim();
    if (!label) {
      emptyLabels.push({ path: context.pathSegments.join(" > ") });
    }
  }, { responses: visibleOnly ? responses : null });

  if (emptyLabels.length > 0) return { ok: false, emptyLabels };
  return { ok: true };
};

export const computeSchemaHash = (schema) => {
  const json = JSON.stringify(schema);
  let hash = 0;
  for (let i = 0; i < json.length; i += 1) {
    hash = (hash << 5) - hash + json.charCodeAt(i);
    hash |= 0;
  }
  return `v1-${Math.abs(hash)}`;
};



================================================
FILE: builder/src/core/schemaUtils.js
================================================
/**
 * スキーマの木構造を変換して新しいツリーを生成する（Map操作）
 */
export const mapSchema = (schema, mapper) => {
  const walk = (nodes, pathSegments = [], depth = 1) => {
    return (nodes || []).map((field, index) => {
      const fieldLabel = (field.label || "").trim();
      const currentPath = [...pathSegments, fieldLabel];
      const context = { pathSegments: currentPath, index, depth };

      const newField = mapper(field, context);

      if (newField && newField.childrenByValue && typeof newField.childrenByValue === "object") {
        const newChildren = {};
        Object.keys(newField.childrenByValue).forEach((optionLabel) => {
          newChildren[optionLabel] = walk(
            newField.childrenByValue[optionLabel],
            [...currentPath, optionLabel],
            depth + 1
          );
        });
        newField.childrenByValue = newChildren;
      }

      return newField;
    });
  };
  return walk(Array.isArray(schema) ? schema : []);
};

/**
 * スキーマの木構造を巡回する（Read-Only操作）
 */
export const traverseSchema = (schema, visitor, options = {}) => {
  const walk = (nodes, pathSegments = [], depth = 1, indexTrail = []) => {
    (nodes || []).forEach((field, index) => {
      const currentIndexTrail = [...indexTrail, index + 1];
      const fieldLabel = (field.label || "").trim();
      const fallbackLabel = `質問 ${currentIndexTrail.join(".")} (${field.type || "unknown"})`;
      const currentPath = [...pathSegments, fieldLabel || fallbackLabel];
      const context = { pathSegments: currentPath, index, depth, indexTrail: currentIndexTrail };

      const shouldContinue = visitor(field, context);
      if (shouldContinue === false) return;

      if (field.childrenByValue && typeof field.childrenByValue === "object") {
        let childKeys = Object.keys(field.childrenByValue);

        if (options.getChildKeys) {
          childKeys = options.getChildKeys(field, context);
        } else if (options.responses) {
          const value = options.responses[field.id];
          if (field.type === "checkboxes" && Array.isArray(value)) {
            childKeys = value.filter(k => Object.prototype.hasOwnProperty.call(field.childrenByValue, k));
          } else if (["radio", "select"].includes(field.type) && typeof value === "string" && value) {
            childKeys = field.childrenByValue[value] ? [value] : [];
          } else {
            childKeys = [];
          }
        }

        childKeys.forEach((key) => {
          walk(field.childrenByValue[key], [...currentPath, key], depth + 1, currentIndexTrail);
        });
      }
    });
  };
  walk(Array.isArray(schema) ? schema : []);
};



================================================
FILE: builder/src/core/selfTests.js
================================================
import { buildSafeRegex, hasValidationErrors, validateByPattern } from "./validate.js";
import { collectResponses } from "./collect.js";
import { computeSchemaHash, normalizeSchemaIDs } from "./schema.js";
import { buildSearchColumns, buildColumnsFromHeaderMatrix } from "../features/search/searchTable.js";

export const runSelfTests = () => {
  try {
    console.assert(buildSafeRegex("^[0-9]+$").error === null, "regex valid should have no error");
    console.assert(buildSafeRegex("(").error !== null, "regex invalid should have error");

    const regexField = { type: "regex", pattern: "^[a-z]+$", required: false };
    console.assert(validateByPattern(regexField, "abc").ok === true, "pattern should accept alpha");
    console.assert(validateByPattern(regexField, "123").ok === false, "pattern should reject digits");
    console.assert(validateByPattern(regexField, "").ok === true, "empty ok when not required");

    const schema = normalizeSchemaIDs([
      { type: "radio", label: "色", options: [{ label: "赤" }, { label: "青" }] },
      { type: "text", label: "名前" },
    ]);
    const responses = { [schema[0].id]: "赤", [schema[1].id]: "太郎" };
    const output = collectResponses(schema, responses);
    console.assert(output["色|赤"] === "●" && output["名前"] === "太郎", "collectResponses basic");

    console.assert(typeof computeSchemaHash(schema) === "string", "schema hash returns string");

    // 表示フラグ正規化: 未指定は false
    const displayDefault = normalizeSchemaIDs([{ type: "text", label: "表示デフォルト" }]);
    console.assert(displayDefault[0].isDisplayed === false, "isDisplayed default should be false");

    // 旧表示キー移行: isDisplayed > displayMode > important の優先順で正規化
    const migratedDisplay = normalizeSchemaIDs([
      { type: "text", label: "none", displayMode: "none" },
      { type: "text", label: "compact", displayMode: "compact" },
      { type: "text", label: "important", important: true },
      { type: "text", label: "priority", isDisplayed: false, displayMode: "normal", important: true },
    ]);
    console.assert(migratedDisplay[0].isDisplayed === false, "displayMode none should migrate to false");
    console.assert(migratedDisplay[1].isDisplayed === true, "displayMode not none should migrate to true");
    console.assert(migratedDisplay[2].isDisplayed === true, "important true should migrate to true");
    console.assert(migratedDisplay[3].isDisplayed === false, "isDisplayed should have highest priority");
    console.assert(!Object.prototype.hasOwnProperty.call(migratedDisplay[1], "displayMode"), "displayMode should be removed");
    console.assert(!Object.prototype.hasOwnProperty.call(migratedDisplay[2], "important"), "important should be removed");

    // 選択系表示は常に縮退列1本に統合される
    const choiceSchema = normalizeSchemaIDs([
      {
        type: "select",
        label: "色",
        isDisplayed: true,
        options: [{ label: "赤" }, { label: "青" }],
      },
    ]);
    const baseColumns = buildSearchColumns({ schema: choiceSchema }, { includeOperations: false });
    const matrixColumns = buildColumnsFromHeaderMatrix(
      [
        ["No.", "modifiedAt", "色", "色"],
        ["", "", "赤", "青"],
      ],
      baseColumns,
    );
    const choiceColumns = matrixColumns.filter((column) => column?.path === "色");
    console.assert(choiceColumns.length === 1, "choice columns should be collapsed into one display column");

    // 必須チェック: テキスト
    const requiredText = normalizeSchemaIDs([{ type: "text", label: "氏名", required: true }]);
    console.assert(hasValidationErrors(requiredText, {}) === true, "required text should error when empty");
    console.assert(hasValidationErrors(requiredText, { [requiredText[0].id]: "山田" }) === false, "required text should pass when filled");

    // 必須チェック: セレクト + 子要素
    const selectWithChild = normalizeSchemaIDs([
      {
        type: "select",
        label: "カラー",
        required: true,
        options: [{ label: "赤" }, { label: "青" }],
        childrenByValue: {
          赤: [{ type: "text", label: "理由", required: true }],
        },
      },
    ]);
    const selectId = selectWithChild[0].id;
    const reasonId = selectWithChild[0].childrenByValue["赤"][0].id;
    console.assert(hasValidationErrors(selectWithChild, {}) === true, "required select should error when empty");
    console.assert(hasValidationErrors(selectWithChild, { [selectId]: "赤" }) === true, "child required should error when empty");
    console.assert(hasValidationErrors(selectWithChild, { [selectId]: "赤", [reasonId]: "好き" }) === false, "child required should pass when filled");
  } catch (err) {
    console.warn("[SelfTests] error:", err);
  }
};



================================================
FILE: builder/src/core/storage.js
================================================
import { openDB, STORE_NAMES } from '../app/state/dbHelpers.js';
import { DEFAULT_PAGE_SIZE, DEFAULT_SHEET_NAME } from './constants.js';

export const SETTINGS_STORAGE_KEY = "nested_form_builder_settings_v1";

const readJson = async (key) => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAMES.settings, "readonly");
    const store = tx.objectStore(STORE_NAMES.settings);
    const request = store.get(key);
    const value = await new Promise((resolve, reject) => {
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
    db.close();
    return value?.value || null;
  } catch (err) {
    console.warn(`[storage] failed to read ${key}`, err);
    return null;
  }
};

export const readSettingsValue = async (key) => readJson(key);

const writeJson = async (key, value) => {
  try {
    const db = await openDB();
    const tx = db.transaction(STORE_NAMES.settings, "readwrite");
    const store = tx.objectStore(STORE_NAMES.settings);
    const request = store.put({ key, value });
    await new Promise((resolve, reject) => {
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
    db.close();
  } catch (err) {
    console.warn(`[storage] failed to write ${key}`, err);
  }
};

export const writeSettingsValue = async (key, value) => writeJson(key, value);

export const DEFAULT_SETTINGS = {
  spreadsheetId: "",
  sheetName: DEFAULT_SHEET_NAME,
  theme: "standard",
  pageSize: DEFAULT_PAGE_SIZE,
  searchCellMaxChars: "",
  syncAllFormsTheme: false,
};

export const loadSettingsFromStorage = async () => {
  const loaded = await readJson(SETTINGS_STORAGE_KEY);
  if (!loaded) return { ...DEFAULT_SETTINGS };
  return { ...DEFAULT_SETTINGS, ...loaded };
};

export const saveSettingsToStorage = async (settings) => {
  await writeJson(SETTINGS_STORAGE_KEY, { ...DEFAULT_SETTINGS, ...settings });
};



================================================
FILE: builder/src/core/styleSettings.js
================================================
export const DEFAULT_STYLE_SETTINGS = { labelSize: "default", textColor: "#000000" };

export const normalizeLabelSize = (value) => {
  if (value === "smallest" || value === "smaller" || value === "default" || value === "larger" || value === "largest") return value;
  return "default";
};

export const normalizeStyleSettings = (input) => {
  const next = { ...(input || {}) };
  if (!next.labelSize && typeof next.fontSize === "string") {
    const numeric = parseInt(next.fontSize, 10);
    if (!Number.isNaN(numeric)) {
      if (numeric <= 12) next.labelSize = "smaller";
      else if (numeric >= 18) next.labelSize = "larger";
      else next.labelSize = "default";
    } else {
      next.labelSize = "default";
    }
  }
  next.labelSize = normalizeLabelSize(next.labelSize);
  if (typeof next.textColor !== "string" || !next.textColor) {
    next.textColor = DEFAULT_STYLE_SETTINGS.textColor;
  }
  delete next.fontSize;
  return next;
};

/**
 * スタイル設定からラベルサイズを解決する（PreviewPage用）
 * normalizeStyleSettings と同等だが textColor の正規化は行わない
 */
export const resolveLabelSize = (styleSettings) => {
  if (styleSettings?.labelSize === "smallest" || styleSettings?.labelSize === "smaller" || styleSettings?.labelSize === "default" || styleSettings?.labelSize === "larger" || styleSettings?.labelSize === "largest") {
    return styleSettings.labelSize;
  }
  if (typeof styleSettings?.fontSize === "string") {
    const numeric = parseInt(styleSettings.fontSize, 10);
    if (!Number.isNaN(numeric)) {
      if (numeric <= 12) return "smaller";
      if (numeric >= 18) return "larger";
    }
  }
  return "default";
};



================================================
FILE: builder/src/core/validate.js
================================================
import { traverseSchema } from "./schemaUtils.js";

const regexCache = new Map();
const EMAIL_REGEX = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;

export const buildSafeRegex = (pattern) => {
  if (!pattern) return { re: null, error: null };
  try {
    return { re: new RegExp(pattern), error: null };
  } catch (err) {
    return { re: null, error: err instanceof Error ? err.message : String(err) };
  }
};

export const validateByPattern = (field, value, cachedRegex = null) => {
  if (field.type !== "regex") return { ok: true, message: "" };
  const { re, error } = cachedRegex || buildSafeRegex(field.pattern || "");
  if (error) return { ok: false, message: `正規表現が不正です: ${error}` };

  const strValue = value ?? "";
  if (field.required && strValue === "") return { ok: false, message: "入力は必須です" };
  if (strValue === "" || !re) return { ok: true, message: "" };

  return re.test(String(value))
    ? { ok: true, message: "" }
    : { ok: false, message: `入力がパターンに一致しません: /${field.pattern}/` };
};

const isEmpty = (field, value) => {
  if (value === undefined || value === null) return true;
  if (["text", "textarea", "regex", "date", "time", "select", "radio", "url", "userName", "email"].includes(field.type)) {
    return value === "";
  }
  if (field.type === "number") {
    return value === "";
  }
  if (field.type === "checkboxes") {
    return !Array.isArray(value) || value.length === 0;
  }
  return false;
};

const getRegexResult = (pattern) => {
  const key = pattern || "";
  if (!regexCache.has(key)) {
    regexCache.set(key, buildSafeRegex(key));
  }
  return regexCache.get(key);
};

export const collectValidationErrors = (fields, responses) => {
  const errors = [];

  traverseSchema(fields, (field, context) => {
    const value = responses?.[field.id];
    const path = context.pathSegments.join(" > ");
    let hasRequiredError = false;

    if (field.required && isEmpty(field, value)) {
      errors.push({
        fieldId: field.id,
        path,
        type: "required",
        message: "必須項目が未入力です",
      });
      hasRequiredError = true;
    }

    if (field.type === "regex") {
      const regexResult = getRegexResult(field.pattern);
      if (regexResult.error) {
        errors.push({
          fieldId: field.id,
          path,
          type: "regex_invalid",
          message: `正規表現が不正です: ${regexResult.error}`,
        });
      } else {
        const result = validateByPattern(field, value, regexResult);
        if (!result.ok && result.message !== "入力は必須です") {
          errors.push({
            fieldId: field.id,
            path,
            type: "regex_mismatch",
            message: result.message,
          });
        } else if (!result.ok && !hasRequiredError) {
          errors.push({
            fieldId: field.id,
            path,
            type: "required",
            message: "必須項目が未入力です",
          });
        }
      }
    }

    if (field.type === "email" && value && !EMAIL_REGEX.test(String(value))) {
      errors.push({
        fieldId: field.id,
        path,
        type: "email_invalid",
        message: "メールアドレスの形式が正しくありません (例: user@example.com)",
      });
    }
  }, { responses });

  return { errors };
};

export const formatValidationErrors = (result) => {
  const errors = result?.errors || [];
  if (errors.length === 0) return "";

  const items = errors.map((error, index) => (
    `${index + 1}. [${error.path}]\n   ${error.message}`
  ));

  return `以下の項目にエラーがあります:\n\n${items.join("\n\n")}`;
};

export const hasValidationErrors = (fields, responses) => collectValidationErrors(fields, responses).errors.length > 0;



================================================
FILE: builder/src/features/admin/FormBuilderWorkspace.jsx
================================================
import React, { useCallback, useEffect, useImperativeHandle, useMemo, useRef, useState } from "react";
import EditorPage from "../editor/EditorPage.jsx";
import PreviewPage from "../preview/PreviewPage.jsx";
import SearchPreviewPanel from "./SearchPreviewPanel.jsx";
import { useBuilderSettings } from "../settings/settingsStore.js";
import { normalizeSchemaIDs, validateMaxDepth, validateRequiredLabels, validateUniqueLabels, MAX_DEPTH } from "../../core/schema.js";
import { runSelfTests } from "../../core/selfTests.js";
import { useAlert } from "../../app/hooks/useAlert.js";
import { omitThemeSetting } from "../../utils/settings.js";
import { deepEqual } from "../../utils/deepEqual.js";

const FormBuilderWorkspace = React.forwardRef(function FormBuilderWorkspace(
  { initialSchema, initialSettings, formTitle, onSave, onDirtyChange, showToolbarSave = true },
  ref,
) {
  const { showAlert } = useAlert();
const [activeTab, setActiveTab] = useState("editor");
  const [schema, setSchema] = useState(() => normalizeSchemaIDs(initialSchema || []));
  const [responses, setResponses] = useState({});
  const { settings, replaceSettings, updateSetting } = useBuilderSettings();
  const initialSchemaRef = useRef(null);
  const initialSettingsRef = useRef(null);
  const [questionControl, setQuestionControl] = useState(null);
  const [isInitialized, setIsInitialized] = useState(false);

  useEffect(() => {
    runSelfTests();
  }, []);

  // initialSchema/initialSettingsが変わったら、リセット
  useEffect(() => {
    const normalized = normalizeSchemaIDs(initialSchema || []);
    setSchema(normalized);
    // replaceSettingsはマージ後の値を返すので、それを初期値として記録
    const mergedSettings = replaceSettings(initialSettings || {});

    initialSchemaRef.current = normalized;
    initialSettingsRef.current = mergedSettings;
    setIsInitialized(true);
    onDirtyChange?.(false);
  }, [initialSchema, initialSettings, replaceSettings, onDirtyChange]);

  // schema/settingsが変わったらdirty判定（初期化完了後のみ）
  useEffect(() => {
    if (!isInitialized) {
      return;
    }
    if (initialSchemaRef.current === null || initialSettingsRef.current === null) {
      return;
    }

    const schemaDirty = !deepEqual(initialSchemaRef.current, schema);
    const settingsDirty = !deepEqual(omitThemeSetting(initialSettingsRef.current), omitThemeSetting(settings));

    onDirtyChange?.(schemaDirty || settingsDirty);
  }, [schema, settings, isInitialized, onDirtyChange]);

  const handleSchemaChange = (nextSchema) => {
    const normalized = normalizeSchemaIDs(nextSchema);
    const depthCheck = validateMaxDepth(normalized, MAX_DEPTH);
    if (!depthCheck.ok) {
      showAlert(`入れ子（キー）の深さは ${MAX_DEPTH} 段までです（現在: ${depthCheck.depth} 段）。`);
      return;
    }
    setSchema(normalized);
  };

  const handleSave = useCallback(() => {
    const labelCheck = validateRequiredLabels(schema);
    if (!labelCheck.ok) {
      const items = (labelCheck.emptyLabels || []).map((entry, index) => `${index + 1}. ${entry.path}`).join("\n");
      showAlert(`以下の質問にラベルが設定されていません:\n\n${items}`, "ラベル未設定");
      return false;
    }

    const uniqueCheck = validateUniqueLabels(schema);
    if (!uniqueCheck.ok) {
      showAlert(`重複する項目名: ${uniqueCheck.dup}`);
      return false;
    }

    initialSchemaRef.current = schema;
    initialSettingsRef.current = settings;
    onDirtyChange?.(false);
    onSave?.({ schema, settings });
    return true;
  }, [onSave, schema, settings, onDirtyChange, showAlert]);

  useImperativeHandle(
    ref,
    () => ({
      save: handleSave,
      getSchema: () => schema,
      getSettings: () => settings,
      updateSetting: updateSetting,
      setMode: setActiveTab,
      getQuestionControl: () => questionControl,
    }),
    [handleSave, schema, settings, updateSetting, questionControl],
  );

  const previewSettings = useMemo(() => ({ ...settings, formTitle }), [settings, formTitle]);

  return (
    <div className="form-builder">
      <div className="form-builder-header">
        <div className="form-builder-title">{formTitle || "フォーム"}</div>
        <div className="form-builder-tabs">
          <button type="button" className="form-builder-tab" data-active={activeTab === "editor" ? "true" : "false"} onClick={() => setActiveTab("editor")}>
            編集
          </button>
          <button type="button" className="form-builder-tab" data-active={activeTab === "preview" ? "true" : "false"} onClick={() => setActiveTab("preview")}>
            プレビュー
          </button>
          {showToolbarSave && (
            <button type="button" className="form-builder-tab" data-active="false" onClick={handleSave}>
              保存
            </button>
          )}
        </div>
      </div>

      {activeTab === "editor" && (
        <EditorPage schema={schema} onSchemaChange={handleSchemaChange} onQuestionControlChange={setQuestionControl} />
      )}

      {activeTab === "preview" && (
        <>
          <PreviewPage
            schema={schema}
            responses={responses}
            setResponses={setResponses}
            settings={previewSettings}
            showOutputJson={false}
            showSaveButton={false}
          />
          <SearchPreviewPanel schema={schema} responses={responses} settings={settings} />
        </>
      )}
</div>
  );
});

export default FormBuilderWorkspace;



================================================
FILE: builder/src/features/admin/SearchPreviewPanel.jsx
================================================
import React, { useMemo } from "react";
import { collectResponses } from "../../core/collect.js";
import { collectDisplayFieldSettings } from "../../utils/formPaths.js";
import {
  buildSearchTableLayout,
  computeRowValues,
  applyDisplayLengthLimit,
  parseSearchCellDisplayLimit,
} from "../search/searchTable.js";
const BASE_KEYS = new Set(["id", "createdAt", "modifiedAt", "__actions"]);

const hasAnyValue = (values, columns) =>
  (columns || []).some((column) => {
    if (BASE_KEYS.has(column.key)) return false;
    const display = values?.[column.key]?.display;
    return typeof display === "string" && display.trim().length > 0;
  });

export default function SearchPreviewPanel({ schema, responses, settings }) {
  const displayFieldSettings = useMemo(() => collectDisplayFieldSettings(schema), [schema]);
  const form = useMemo(
    () => ({
      displayFieldSettings,
    }),
    [displayFieldSettings],
  );

  const displayLengthLimit = parseSearchCellDisplayLimit(settings?.searchCellMaxChars);

  const sampleEntry = useMemo(() => {
    const data = collectResponses(schema, responses);
    return {
      id: "プレビュー",
      createdAt: "",
      modifiedAt: "",
      data,
    };
  }, [schema, responses]);

  const { columns, headerRows } = useMemo(
    () => buildSearchTableLayout(form, { includeOperations: false }),
    [form],
  );
  const previewRow = useMemo(
    () => ({ entry: sampleEntry, values: computeRowValues(sampleEntry, columns) }),
    [sampleEntry, columns],
  );

  const hasImportantColumns = useMemo(
    () => columns.some((column) => !BASE_KEYS.has(column.key)),
    [columns],
  );
  const hasResponses = useMemo(
    () => hasAnyValue(previewRow.values, columns),
    [previewRow.values, columns],
  );

  return (
    <section className="nf-mt-24">
      <details open>
        <summary className="nf-cursor-pointer nf-fw-600 nf-mb-12">
          検索プレビュー
        </summary>
        <div className="nf-card">
          {!hasImportantColumns ? (
            <p className="nf-text-subtle nf-text-12">
              「表示」に設定された質問がありません。表示項目を設定すると検索プレビューが表示されます。
            </p>
          ) : (
            <div className="search-table-wrap">
              <table className="search-preview-table">
                <thead>
                  {headerRows.map((row, rowIndex) => (
                    <tr key={`preview-header-${rowIndex}`}>
                      {row.map((cell, cellIndex) => (
                        <th
                          key={`preview-header-cell-${rowIndex}-${cellIndex}`}
                          className="search-preview-th"
                          colSpan={cell.colSpan}
                          rowSpan={cell.rowSpan ?? 1}
                        >
                          {cell.label}
                        </th>
                      ))}
                    </tr>
                  ))}
                </thead>
                <tbody>
                  {hasResponses ? (
                    <tr>
                      {columns.map((column) => (
                        <td key={`preview-${column.key}`} className="search-preview-td">
                          {applyDisplayLengthLimit(
                            previewRow.values?.[column.key]?.display ?? "",
                            displayLengthLimit,
                          )}
                        </td>
                      ))}
                    </tr>
                  ) : (
                    <tr>
                      <td className="search-preview-td nf-text-center nf-text-subtle" colSpan={columns.length || 1}>
                        フォームに入力すると、表示項目の検索結果プレビューがここに表示されます。
                      </td>
                    </tr>
                  )}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </details>
    </section>
  );
}



================================================
FILE: builder/src/features/editor/EditorPage.jsx
================================================
import React from "react";
import QuestionList from "./QuestionList.jsx";
import { normalizeSchemaIDs } from "../../core/schema.js";
import { styles as s } from "./styles.js";
import { genId } from "../../core/ids.js";

function collectFieldIds(fields, ids = new Set()) {
  (fields || []).forEach((field) => {
    if (!field || typeof field !== "object") return;
    if (field.id) ids.add(field.id);
    if (field.childrenByValue && typeof field.childrenByValue === "object") {
      Object.values(field.childrenByValue).forEach((children) => {
        collectFieldIds(children, ids);
      });
    }
  });
  return ids;
}

/**
 * フォームエディターのメインページ
 * 質問リストを管理
 */
export default function EditorPage({ schema, onSchemaChange, onQuestionControlChange }) {
  const tempUiStateRef = React.useRef(new Map());

  const getTempState = React.useCallback((fieldId) => {
    if (!fieldId) return null;
    return tempUiStateRef.current.get(fieldId) || null;
  }, []);

  const setTempState = React.useCallback((fieldId, partialState) => {
    if (!fieldId || !partialState || typeof partialState !== "object") return;
    const current = tempUiStateRef.current.get(fieldId) || {};
    const nextState = { ...current, ...partialState };
    Object.keys(nextState).forEach((key) => {
      if (nextState[key] === undefined) delete nextState[key];
    });
    if (Object.keys(nextState).length === 0) {
      tempUiStateRef.current.delete(fieldId);
      return;
    }
    tempUiStateRef.current.set(fieldId, nextState);
  }, []);

  const clearTempState = React.useCallback((fieldId) => {
    if (!fieldId) return;
    tempUiStateRef.current.delete(fieldId);
  }, []);

  React.useEffect(() => {
    const aliveIds = collectFieldIds(schema || []);
    Array.from(tempUiStateRef.current.keys()).forEach((fieldId) => {
      if (!aliveIds.has(fieldId)) {
        tempUiStateRef.current.delete(fieldId);
      }
    });
  }, [schema]);

  /**
   * 新しい質問を追加
   */
  const handleAddQuestion = () => {
    const next = normalizeSchemaIDs([...(schema || [])]);
    next.push({ id: genId(), type: "text", label: "" });
    onSchemaChange(next);
  };

  return (
    <div>
      <QuestionList
        fields={schema}
        onChange={onSchemaChange}
        onQuestionControlChange={onQuestionControlChange}
        getTempState={getTempState}
        setTempState={setTempState}
        clearTempState={clearTempState}
      />
      <div className="nf-row-center nf-mt-12">
        <button type="button" className={s.btn.className} onClick={handleAddQuestion}>質問を追加</button>
      </div>
    </div>
  );
}



================================================
FILE: builder/src/features/editor/OptionRow.jsx
================================================
import React from "react";
import { styles as s } from "./styles.js";

export default function OptionRow({ option, onChange, onDelete, onFocus, isSelected, onAddChild, childrenArea, canAddChild = true }) {
  return (
    <div className="nf-option-row" data-selected={isSelected ? "true" : "false"}>
      <div className="nf-row nf-gap-8">
        <button type="button" onClick={onDelete} className="nf-btn nf-btn-danger nf-btn-compact">削除</button>
        <input
          className={s.input.className}
          placeholder="選択肢"
          value={option.label}
          onChange={(event) => onChange({ ...option, label: event.target.value })}
          onFocus={onFocus}
        />
        <button type="button" onClick={onAddChild} className="nf-btn" disabled={!canAddChild}>子質問追加</button>
      </div>
      {childrenArea}
    </div>
  );
}



================================================
FILE: builder/src/features/editor/QuestionCard.jsx
================================================
import React from "react";
import { buildSafeRegex } from "../../core/validate.js";
import { deepClone, normalizeSchemaIDs, MAX_DEPTH } from "../../core/schema.js";
import { genId } from "../../core/ids.js";
import { resolveIsDisplayed } from "../../core/displayModes.js";
import { DEFAULT_STYLE_SETTINGS, normalizeStyleSettings } from "../../core/styleSettings.js";
import { styles as s } from "./styles.js";
import OptionRow from "./OptionRow.jsx";
// 定数
const CHOICE_TYPES = ["radio", "select", "checkboxes"];
const INPUT_TYPES = ["text", "textarea", "number", "url"];
const DATE_TIME_TYPES = ["date", "time"];
const MESSAGE_TYPE = "message";
const USER_NAME_TYPE = "userName";
const EMAIL_TYPE = "email";
const DISPLAY_LABEL = "表示";

// ヘルパー関数
const isChoiceType = (type) => CHOICE_TYPES.includes(type);
const isInputType = (type) => INPUT_TYPES.includes(type);
const isDateOrTimeType = (type) => DATE_TIME_TYPES.includes(type);
const isMessageType = (type) => type === MESSAGE_TYPE;
const isUserNameType = (type) => type === USER_NAME_TYPE;
const isEmailType = (type) => type === EMAIL_TYPE;
const applyDisplayedFlag = (target, displayed) => {
  target.isDisplayed = displayed === true;
  delete target.displayMode;
  delete target.important;
  delete target.compact;
};

/**
 * 選択肢系から非選択肢系への変更時に、選択肢状態をメモリへ退避してoptionsを削除する
 */
function saveAndClearChoiceState(next, field, oldIsChoice, setTempState) {
  if (oldIsChoice) {
    setTempState?.(field.id, {
      choiceState: {
        options: deepClone(field.options || []),
        childrenByValue: field.childrenByValue ? deepClone(field.childrenByValue) : undefined,
      },
    });
  }
  delete next.options;
  delete next.childrenByValue;
}

/**
 * タイプ変更時の状態を管理する関数
 * 選択肢系⇔入力系の変換時にchildrenByValueの状態を保存・復元する
 */
function handleTypeChange(field, newType, { getTempState, setTempState } = {}) {
  const next = deepClone(field);
  const oldType = field.type;
  next.type = newType;
  const wasDisplayed = resolveIsDisplayed(next);

  const oldIsChoice = isChoiceType(oldType);
  const newIsChoice = isChoiceType(newType);

  if (newIsChoice) {
    // 選択肢系への変更
    delete next.pattern;
    delete next.defaultNow;

    if (oldIsChoice) {
      // 選択肢系 → 選択肢系: childrenByValueをそのまま引き継ぎ
      next.options = next.options?.length ? next.options : [{ id: genId(), label: "" }];
    } else {
      // 入力系 → 選択肢系: 仮保存から復元
      const savedChoiceState = getTempState?.(field.id)?.choiceState;
      if (savedChoiceState && Array.isArray(savedChoiceState.options) && savedChoiceState.options.length > 0) {
        next.options = deepClone(savedChoiceState.options);
        if (savedChoiceState.childrenByValue && typeof savedChoiceState.childrenByValue === "object") {
          next.childrenByValue = deepClone(savedChoiceState.childrenByValue);
        } else {
          delete next.childrenByValue;
        }
      } else {
        next.options = next.options?.length ? next.options : [{ id: genId(), label: "" }];
        delete next.childrenByValue;
      }
    }
  } else if (newType === "regex") {
    // 正規表現への変更
    next.pattern = typeof next.pattern === "string" ? next.pattern : "";
    delete next.defaultNow;
    saveAndClearChoiceState(next, field, oldIsChoice, setTempState);
  } else if (isDateOrTimeType(newType)) {
    // 日付・時刻への変更
    delete next.pattern;
    next.defaultNow = !!next.defaultNow;
    saveAndClearChoiceState(next, field, oldIsChoice, setTempState);
  } else if (newType === USER_NAME_TYPE || newType === EMAIL_TYPE) {
    // 入力ユーザー名への変更
    delete next.pattern;
    delete next.placeholder;
    delete next.showPlaceholder;
    next.defaultNow = !!next.defaultNow;
    saveAndClearChoiceState(next, field, oldIsChoice, setTempState);
  } else if (newType === MESSAGE_TYPE) {
    // メッセージへの変更
    delete next.pattern;
    delete next.defaultNow;
    delete next.required;
    saveAndClearChoiceState(next, field, oldIsChoice, setTempState);
  } else {
    // テキスト、テキストエリア、数値への変更
    delete next.pattern;
    delete next.defaultNow;
    saveAndClearChoiceState(next, field, oldIsChoice, setTempState);
  }

  applyDisplayedFlag(next, wasDisplayed);

  return next;
}

/**
 * プレースホルダー入力UI
 */
function PlaceholderInput({ field, onChange, onFocus }) {
  return (
    <div className="nf-mt-8">
      <label className={`nf-row nf-gap-6${field.showPlaceholder ? " nf-mb-4" : ""}`}>
        <input
          type="checkbox"
          checked={!!field.showPlaceholder}
          onChange={(event) => {
            onChange({ ...field, showPlaceholder: event.target.checked });
          }}
        />
        プレースホルダー
      </label>
      {field.showPlaceholder && (
        <div className="nf-row nf-gap-8">
          <input
            className={s.input.className}
            placeholder="例: 入力例を表示"
            value={field.placeholder || ""}
            onChange={(event) => onChange({ ...field, placeholder: event.target.value })}
            onFocus={onFocus}
          />
        </div>
      )}
    </div>
  );
}

/**
 * スタイル設定入力UI
 */
function StyleSettingsInput({ field, onChange, onFocus, getTempState, setTempState }) {
  const styleSettings = normalizeStyleSettings(field.styleSettings || {});
  const isStyleSettingsEnabled = typeof field.showStyleSettings === "boolean"
    ? field.showStyleSettings
    : !!field.styleSettings;
  const savedStyleSettings = getTempState?.(field.id)?.savedStyleSettings;
  return (
    <div className="nf-mt-8">
      <label className={`nf-row nf-gap-6${isStyleSettingsEnabled ? " nf-mb-4" : ""}`}>
        <input
          type="checkbox"
          checked={isStyleSettingsEnabled}
          onChange={(event) => {
            const checked = event.target.checked;
            if (checked) {
              const restored = (field.styleSettings && typeof field.styleSettings === "object")
                ? field.styleSettings
                : (savedStyleSettings && typeof savedStyleSettings === "object" ? savedStyleSettings : {});
              const nextStyleSettings = { ...DEFAULT_STYLE_SETTINGS, ...normalizeStyleSettings(restored) };
              console.log("[StyleSettingsInput] toggle ON", {
                id: field.id,
                label: field.label,
                restoredFrom: field.styleSettings ? "styleSettings" : (savedStyleSettings ? "tempState" : "default"),
                nextStyleSettings
              });
              const nextField = { ...field, showStyleSettings: true, styleSettings: nextStyleSettings };
              setTempState?.(field.id, { savedStyleSettings: undefined });
              onChange(nextField);
              return;
            }
            console.log("[StyleSettingsInput] toggle OFF (keep in-memory until save)", {
              id: field.id,
              label: field.label,
              styleSettings: field.styleSettings,
            });
            const nextField = { ...field, showStyleSettings: false };
            if (field.styleSettings && typeof field.styleSettings === "object") {
              setTempState?.(field.id, { savedStyleSettings: deepClone(field.styleSettings) });
            }
            delete nextField.styleSettings;
            onChange(nextField);
          }}
        />
        スタイル設定
      </label>
      {isStyleSettingsEnabled && (
        <div className="nf-row nf-gap-8 nf-mt-4">
          <div className="nf-flex-1">
            <label className="nf-text-12 nf-mb-2 nf-text-subtle">文字サイズ</label>
            <select
              className={s.input.className}
              value={styleSettings.labelSize || "default"}
              onChange={(event) => onChange({
                ...field,
                styleSettings: { ...styleSettings, labelSize: event.target.value }
              })}
              onFocus={onFocus}
            >
              <option value="smallest">最も小さく</option>
              <option value="smaller">小さく</option>
              <option value="default">標準</option>
              <option value="larger">大きく</option>
              <option value="largest">最も大きく</option>
            </select>
          </div>
          <div className="nf-flex-1">
            <label className="nf-text-12 nf-mb-2 nf-text-subtle">文字色</label>
            <select
              className={s.input.className}
              value={styleSettings.textColor || "#000000"}
              onChange={(event) => onChange({
                ...field,
                styleSettings: { ...styleSettings, textColor: event.target.value }
              })}
              onFocus={onFocus}
            >
              <option value="#000000">黒（デフォルト）</option>
              <option value="#DC2626">赤</option>
              <option value="#2563EB">青</option>
              <option value="#16A34A">緑</option>
              <option value="#6B7280">グレー</option>
            </select>
          </div>
        </div>
      )}
    </div>
  );
}

export default function QuestionCard({
  field,
  onChange,
  onAddBelow,
  onDelete,
  onFocus,
  isSelected,
  QuestionListComponent,
  depth = 1,
  getTempState,
  setTempState,
  clearTempState,
}) {
  const isChoice = isChoiceType(field.type);
  const isRegex = field.type === "regex";
  const isDateOrTime = isDateOrTimeType(field.type);
  const isInput = isInputType(field.type);
  const isMessage = isMessageType(field.type);
  const isUserName = isUserNameType(field.type);
  const isEmail = isEmailType(field.type);
  const canAddChild = depth < MAX_DEPTH;
  const regexCheck = isRegex ? buildSafeRegex(field.pattern || "") : { error: null };
  const [selectedOptionIndex, setSelectedOptionIndex] = React.useState(null);
  const latestFieldRef = React.useRef(field);
  const latestOnChangeRef = React.useRef(onChange);
  latestFieldRef.current = field;
  latestOnChangeRef.current = onChange;
  const isDisplayed = resolveIsDisplayed(field);
  const handleDisplayToggle = (checked) => {
    const nextField = { ...field };
    applyDisplayedFlag(nextField, checked);
    onChange(nextField);
  };

  // 既存のplaceholderがある場合はshowPlaceholderをtrueにする
  React.useEffect(() => {
    if ((isInput || isRegex) && field.placeholder && !field.showPlaceholder) {
      onChange({ ...field, showPlaceholder: true });
    }
  }, []);

  const moveOptionUp = (index) => {
    const currentField = latestFieldRef.current;
    if (!Array.isArray(currentField?.options)) return;
    if (index <= 0 || index >= currentField.options.length) return;
    const next = deepClone(currentField);
    [next.options[index - 1], next.options[index]] = [next.options[index], next.options[index - 1]];
    latestOnChangeRef.current(next);
    setSelectedOptionIndex(index - 1);
  };

  const moveOptionDown = (index) => {
    const currentField = latestFieldRef.current;
    if (!Array.isArray(currentField?.options)) return;
    if (index < 0 || index >= currentField.options.length - 1) return;
    const next = deepClone(currentField);
    [next.options[index], next.options[index + 1]] = [next.options[index + 1], next.options[index]];
    latestOnChangeRef.current(next);
    setSelectedOptionIndex(index + 1);
  };

  // 選択肢の選択状態を親に伝達（質問の上下移動とは別の制御）
  React.useEffect(() => {
    if (isChoice && selectedOptionIndex !== null) {
      // 選択肢が選択されている場合は、その情報を含めて親に通知
      const canMoveUp = selectedOptionIndex > 0;
      const canMoveDown = selectedOptionIndex < (field.options?.length || 0) - 1;
      const optionLabel = field.options?.[selectedOptionIndex]?.label || `選択肢 ${selectedOptionIndex + 1}`;
      // onFocusに選択肢情報を含めることで、QuestionListが適切に処理できるようにする
      onFocus({
        type: "option",
        optionIndex: selectedOptionIndex,
        optionLabel,
        canMoveUp,
        canMoveDown,
        moveUp: () => moveOptionUp(selectedOptionIndex),
        moveDown: () => moveOptionDown(selectedOptionIndex)
      });
    }
  }, [selectedOptionIndex, isChoice, field.options?.length]);

  const cardAttrs = s.card(0, isSelected);

  return (
    <div className={cardAttrs.className} data-depth={cardAttrs["data-depth"]} data-selected={cardAttrs["data-selected"]}>
      <div className="nf-row nf-gap-8 nf-mb-8 nf-wrap">
        <span className="nf-text-13 nf-fw-500 nf-text-ink nf-shrink-0">項目名</span>
        <input
          className={`${s.input.className} nf-w-auto nf-flex-1-1-200 nf-min-w-0`}
          placeholder="項目名を入力"
          value={field.label || ""}
          required
          onChange={(event) => onChange({ ...field, label: event.target.value })}
          onFocus={() => {
            setSelectedOptionIndex(null);
            onFocus();
          }}
        />
        <select
          value={field.type}
          className={`${s.input.className} nf-w-auto nf-min-w-150 nf-flex-0-1-auto`}
          onChange={(event) => {
            const next = handleTypeChange(field, event.target.value, { getTempState, setTempState });
            onChange(next);
          }}
          onFocus={onFocus}
        >
          <option value="text">テキスト</option>
          <option value="textarea">テキスト（複数行）</option>
          <option value="number">数値</option>
          <option value="regex">正規表現</option>
          <option value="checkboxes">チェックボックス</option>
          <option value="radio">ラジオ</option>
          <option value="select">ドロップダウン</option>
          <option value="date">日付</option>
          <option value="time">時間</option>
          <option value="userName">名前</option>
          <option value="email">メールアドレス</option>
          <option value="url">URL</option>
          <option value="message">メッセージ</option>
        </select>
        {!isMessage && (
          <label className="nf-row nf-gap-4 nf-nowrap">
            <input
              type="checkbox"
              checked={!!field.required}
              onChange={(event) => onChange({ ...field, required: event.target.checked })}
            />
            必須
          </label>
        )}
        <label className="nf-row nf-gap-6">
          <input
            type="checkbox"
            checked={isDisplayed}
            onChange={(event) => handleDisplayToggle(event.target.checked)}
          />
          {DISPLAY_LABEL}
        </label>
      </div>

      {/* スタイル設定（全タイプで利用可能） */}
      <StyleSettingsInput
        field={field}
        onChange={onChange}
        onFocus={onFocus}
        getTempState={getTempState}
        setTempState={setTempState}
      />

      {isInput && <PlaceholderInput field={field} onChange={onChange} onFocus={onFocus} />}

      {isDateOrTime && (
        <div className="nf-mt-8">
          <label className="nf-row nf-gap-6">
            <input
              type="checkbox"
              checked={!!field.defaultNow}
              onChange={(event) => onChange({ ...field, defaultNow: event.target.checked })}
            />
            初期値を現在{field.type === "date" ? "の日付" : "の時刻"}にする
          </label>
        </div>
      )}

      {isUserName && (
        <div className="nf-mt-8">
          <label className="nf-row nf-gap-6">
            <input
              type="checkbox"
              checked={!!field.defaultNow}
              onChange={(event) => onChange({ ...field, defaultNow: event.target.checked })}
            />
            作成時に入力ユーザーの氏名を自動入力
          </label>
        </div>
      )}
      {isEmail && (
        <div className="nf-mt-8">
          <label className="nf-row nf-gap-6">
            <input
              type="checkbox"
              checked={!!field.defaultNow}
              onChange={(event) => onChange({ ...field, defaultNow: event.target.checked })}
            />
            作成時に入力ユーザーのアドレスを自動入力
          </label>
        </div>
      )}

      {isRegex && (
        <div className="nf-mt-8">
          <label className="nf-fw-600 nf-mb-4">正規表現（任意）</label>
          <input
            className={s.input.className}
            placeholder="例: ^[0-9]+$"
            value={field.pattern || ""}
            onChange={(event) => onChange({ ...field, pattern: event.target.value })}
            onFocus={onFocus}
          />
          {regexCheck.error && (
            <div className="nf-text-danger-ink nf-text-12 nf-mt-4">正規表現が不正です: {regexCheck.error}</div>
          )}
          <PlaceholderInput field={field} onChange={onChange} onFocus={onFocus} />
        </div>
      )}

      {isChoice && (
        <div className="nf-mt-8">
          <div className="nf-row-between nf-mb-6">
            <strong>選択肢</strong>
            <button
              type="button"
              className={s.btn.className}
              onClick={() => {
                const next = deepClone(field);
                next.options = next.options || [];
                next.options.push({ id: genId(), label: "" });
                onChange(next);
              }}
            >
              選択肢を追加
            </button>
          </div>

          {(field.options || []).map((opt, index) => (
            <OptionRow
              key={opt.id}
              option={opt}
              onChange={(nextOpt) => {
                const next = deepClone(field);
                const prevLabel = opt.label || "";
                const nextLabel = nextOpt.label || "";
                next.options[index] = { id: nextOpt.id || genId(), label: nextLabel };

                // ラベル変更時も子質問を維持する
                if (prevLabel !== nextLabel && next.childrenByValue?.[prevLabel]) {
                  next.childrenByValue = { ...next.childrenByValue };
                  const movedChildren = next.childrenByValue[prevLabel];
                  const existing = next.childrenByValue[nextLabel];
                  next.childrenByValue[nextLabel] = existing
                    ? normalizeSchemaIDs([...movedChildren, ...existing])
                    : movedChildren;
                  delete next.childrenByValue[prevLabel];
                }
                onChange(next);
              }}
              onDelete={() => {
                const next = deepClone(field);
                next.options.splice(index, 1);
                onChange(next);
                if (selectedOptionIndex === index) {
                  setSelectedOptionIndex(null);
                } else if (selectedOptionIndex > index) {
                  setSelectedOptionIndex(selectedOptionIndex - 1);
                }
              }}
              onFocus={() => {
                setSelectedOptionIndex(index);
                // 選択肢がフォーカスされた時は、質問カード全体は選択しない
              }}
              isSelected={selectedOptionIndex === index}
              onAddChild={() => {
                if (!canAddChild) return;
                const next = deepClone(field);
                next.childrenByValue = next.childrenByValue || {};
                const key = opt.label;
                next.childrenByValue[key] = normalizeSchemaIDs(next.childrenByValue[key] || []);
                next.childrenByValue[key].push({ id: genId(), type: "text", label: "" });
                onChange(next);
              }}
              canAddChild={canAddChild}
              childrenArea={
                (() => {
                  const hasChildren = field.childrenByValue && field.childrenByValue[opt.label]?.length;
                  return hasChildren ? (
                    <div className={s.child.className}>
                      <QuestionListComponent
                      fields={field.childrenByValue[opt.label]}
                      onChange={(childFields) => {
                        const next = deepClone(field);
                        next.childrenByValue[opt.label] = normalizeSchemaIDs(childFields);
                        onChange(next);
                      }}
                      depth={depth + 1}
                      getTempState={getTempState}
                      setTempState={setTempState}
                      clearTempState={clearTempState}
                    />
                  </div>
                  ) : null;
                })()
              }
            />
          ))}
        </div>
      )}

      <div className="nf-row nf-gap-8 nf-mt-12">
        <button type="button" className={s.btnDanger.className} onClick={onDelete}>削除</button>
        <div className="nf-flex-1" />
        <button type="button" className={s.btn.className} onClick={onAddBelow}>次の質問を追加</button>
      </div>
    </div>
  );
}



================================================
FILE: builder/src/features/editor/QuestionList.jsx
================================================
import React from "react";
import { deepClone, normalizeSchemaIDs, validateMaxDepth, MAX_DEPTH } from "../../core/schema.js";
import { genId } from "../../core/ids.js";
import QuestionCard from "./QuestionCard.jsx";
import { useAlert } from "../../app/hooks/useAlert.js";

/**
 * スキーマのバリデーションを実行
 * 入力中は深さチェックのみ行い、重複チェックは保存時のみ実施
 * @returns {object} { ok: boolean, error: string | null }
 */
function validateSchema(schema) {
  const depthResult = validateMaxDepth(schema, MAX_DEPTH);
  if (!depthResult.ok) {
    return { ok: false, error: `入れ子(キー)の深さは ${MAX_DEPTH} 段までです(現在: ${depthResult.depth} 段)。` };
  }

  return { ok: true, error: null };
}

/**
 * 配列の要素を入れ替える
 */
function swapItems(array, index1, index2) {
  const next = deepClone(array);
  [next[index1], next[index2]] = [next[index2], next[index1]];
  return next;
}

/**
 * 質問制御情報を生成
 */
function buildQuestionControlInfo(selectedIndex, normalized, moveUp, moveDown) {
  if (selectedIndex === null) {
    return {
      selectedIndex: null,
      questionLabel: null,
      canMoveUp: false,
      canMoveDown: false,
      moveUp: () => {},
      moveDown: () => {},
      isOption: false
    };
  }

  const questionLabel = normalized[selectedIndex]?.label || `質問 ${selectedIndex + 1}`;
  const canMoveUp = selectedIndex > 0;
  const canMoveDown = selectedIndex < normalized.length - 1;

  return {
    selectedIndex,
    questionLabel,
    canMoveUp,
    canMoveDown,
    moveUp: () => moveUp(selectedIndex),
    moveDown: () => moveDown(selectedIndex),
    isOption: false
  };
}

/**
 * 選択肢制御情報を生成
 */
function buildOptionControlInfo(selectedIndex, optionControl, normalized) {
  const questionLabel = selectedIndex !== null ? normalized[selectedIndex]?.label || `質問 ${selectedIndex + 1}` : null;

  return {
    selectedIndex,
    questionLabel,
    canMoveUp: optionControl.canMoveUp,
    canMoveDown: optionControl.canMoveDown,
    moveUp: optionControl.moveUp,
    moveDown: optionControl.moveDown,
    isOption: true,
    optionIndex: optionControl.optionIndex,
    optionLabel: optionControl.optionLabel
  };
}

function clearTempStateForField(field, clearTempState) {
  if (!field || typeof field !== "object") return;
  if (field.id) clearTempState?.(field.id);
  if (field.childrenByValue && typeof field.childrenByValue === "object") {
    Object.values(field.childrenByValue).forEach((children) => {
      (children || []).forEach((child) => clearTempStateForField(child, clearTempState));
    });
  }
}

export default function QuestionList({
  fields,
  onChange,
  depth = 1,
  onQuestionControlChange,
  getTempState,
  setTempState,
  clearTempState,
}) {
  const { showAlert } = useAlert();
  const normalized = normalizeSchemaIDs(fields);
  const [selectedIndex, setSelectedIndex] = React.useState(null);
  const [optionControl, setOptionControl] = React.useState(null);

  React.useEffect(() => {
    if (depth === 1 && onQuestionControlChange) {
      let controlInfo;

      // 選択肢が選択されている場合は、選択肢の制御情報を使う
      if (optionControl && optionControl.type === 'option') {
        controlInfo = buildOptionControlInfo(selectedIndex, optionControl, normalized);
      } else {
        // 質問が選択されている場合
        controlInfo = buildQuestionControlInfo(selectedIndex, normalized, moveUp, moveDown);
      }

      onQuestionControlChange(controlInfo);
    }
  }, [selectedIndex, optionControl, normalized.length, depth]);

  const commit = (next) => {
    const fixed = normalizeSchemaIDs(next);
    const validation = validateSchema(fixed);
    if (!validation.ok) {
      showAlert(validation.error);
      return;
    }
    onChange(fixed);
  };

  const setOne = (index, field) => {
    const next = deepClone(normalized);
    next[index] = field.id ? field : { ...field, id: genId() };
    commit(next);
  };

  const insertAfter = (index) => {
    const next = deepClone(normalized);
    next.splice(index + 1, 0, { id: genId(), type: "text", label: "" });
    commit(next);
  };

  const removeOne = (index) => {
    const next = deepClone(normalized);
    const [removed] = next.splice(index, 1);
    clearTempStateForField(removed, clearTempState);
    commit(next);
    if (selectedIndex === index) {
      setSelectedIndex(null);
    } else if (selectedIndex > index) {
      setSelectedIndex(selectedIndex - 1);
    }
  };

  const moveUp = (index) => {
    if (index === 0) return;
    const next = swapItems(normalized, index - 1, index);
    commit(next);
    if (selectedIndex === index) {
      setSelectedIndex(index - 1);
    } else if (selectedIndex === index - 1) {
      setSelectedIndex(index);
    }
  };

  const moveDown = (index) => {
    if (index === normalized.length - 1) return;
    const next = swapItems(normalized, index, index + 1);
    commit(next);
    if (selectedIndex === index) {
      setSelectedIndex(index + 1);
    } else if (selectedIndex === index + 1) {
      setSelectedIndex(index);
    }
  };

  return (
    <>
      <div className="nf-col nf-gap-12">
        {normalized.map((field, index) => (
          <QuestionCard
            key={field.id}
            field={field}
            onChange={(nextField) => setOne(index, nextField)}
            onAddBelow={() => insertAfter(index)}
            onDelete={() => removeOne(index)}
            onFocus={(controlInfo) => {
              if (controlInfo && typeof controlInfo === 'object') {
                // 選択肢が選択された場合
                setSelectedIndex(index);
                setOptionControl(controlInfo);
              } else {
                // 質問が選択された場合
                setSelectedIndex(index);
                setOptionControl(null);
              }
            }}
            isSelected={selectedIndex === index}
            QuestionListComponent={QuestionList}
            depth={depth}
            getTempState={getTempState}
            setTempState={setTempState}
            clearTempState={clearTempState}
          />
        ))}
      </div>
</>
  );
}



================================================
FILE: builder/src/features/editor/styles.js
================================================
export const styles = {
  input: { className: "nf-input" },
  btn: { className: "nf-btn" },
  btnDanger: { className: "nf-btn nf-btn-danger" },
  child: { className: "nf-child" },
  card: (depth = 0, isSelected = false) => ({
    className: "nf-card",
    "data-depth": String(depth),
    "data-selected": isSelected ? "true" : "false",
  }),
};



================================================
FILE: builder/src/features/export/SettingsPanel.jsx
================================================
import React from "react";
import { SETTINGS_GROUPS } from "../settings/settingsSchema.js";

const SettingsField = ({ field, value, onChange }) => {
  const isSelect = field.type === "select" || Array.isArray(field.options);
  const isCheckbox = field.type === "checkbox";

  if (isCheckbox) {
    return (
      <div className="nf-mb-12">
        <label className="nf-flex nf-items-center nf-gap-8" style={{ cursor: "pointer" }}>
          <input
            type="checkbox"
            checked={value !== undefined ? !!value : !!field.defaultValue}
            onChange={(event) => onChange(field.key, event.target.checked)}
          />
          <span className="nf-fw-600">{field.label}</span>
        </label>
        {field.description && (
          <p className="nf-text-11 nf-text-muted nf-mt-4 nf-mb-0">{field.description}</p>
        )}
      </div>
    );
  }

  return (
    <div className="nf-mb-12">
      <label className="nf-block nf-fw-600 nf-mb-6">
        {field.label}
        {field.required && <span className="nf-text-danger nf-ml-4">*</span>}
      </label>
      {isSelect ? (
        <select className="nf-input" value={value ?? ""} onChange={(event) => onChange(field.key, event.target.value)}>
          {(field.options || []).map((option) => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>
      ) : (
        <input
          className="nf-input"
          type={field.type || "text"}
          value={value ?? ""}
          placeholder={field.placeholder}
          onChange={(event) => onChange(field.key, event.target.value)}
        />
      )}
      {field.description && (
        <p className="nf-text-11 nf-text-muted nf-mt-4 nf-mb-0">{field.description}</p>
      )}
    </div>
  );
};

export default function SettingsPanel({ settings, onSettingsChange }) {
  return (
    <div className="nf-card">
      {SETTINGS_GROUPS.map((group) => (
        <div key={group.key} className="nf-mb-16">
          <div className="nf-settings-group-title nf-mb-12">{group.label}</div>
          {group.fields.map((field) => (
            <SettingsField key={field.key} field={field} value={settings[field.key]} onChange={onSettingsChange} />
          ))}
        </div>
      ))}
    </div>
  );
}



================================================
FILE: builder/src/features/preview/PreviewPage.jsx
================================================
import React, { useEffect, useImperativeHandle, useMemo, useRef, useState } from "react";
import { collectResponses, sortResponses } from "../../core/collect.js";
import { computeSchemaHash } from "../../core/schema.js";
import { collectValidationErrors, formatValidationErrors, validateByPattern } from "../../core/validate.js";
import { submitResponses, hasScriptRun } from "../../services/gasClient.js";
import { normalizeSpreadsheetId } from "../../utils/spreadsheet.js";
import { styles as s } from "../editor/styles.js";
import { useAlert } from "../../app/hooks/useAlert.js";
import { collectDefaultNowResponses } from "../../utils/responses.js";
import { resolveLabelSize } from "../../core/styleSettings.js";

const generateRecordId = () => {
  if (window.crypto?.getRandomValues) {
    const bytes = new Uint8Array(12);
    window.crypto.getRandomValues(bytes);
    return `r_${Array.from(bytes)
      .map((b) => (`0${b.toString(16)}`).slice(-2))
      .join("")}`;
  }
  return `r_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`;
};


const FieldRenderer = ({ field, value, onChange, renderChildrenAll, renderChildrenForOption, readOnly = false }) => {
  const validation = validateByPattern(field, value);

  const renderReadOnlyValue = () => {
    if (field.type === "checkboxes" && Array.isArray(value)) return value.join(", ");
    if (Array.isArray(value)) return value.join(", ");
    if (value === undefined || value === null || value === "") return "—";
    if (field.type === "url" && value) {
      return (
        <a href={value} target="_blank" rel="noopener noreferrer" className="nf-link">
          {value}
        </a>
      );
    }
    return String(value);
  };

  // スタイル設定を適用
  const styleSettings = field.styleSettings || {};
  const labelSize = resolveLabelSize(styleSettings);
  const labelStyleVars = {
    ...(labelSize === "smallest" ? { "--label-font-size-offset": "var(--label-size-offset-xs)" } : {}),
    ...(labelSize === "smaller" ? { "--label-font-size-offset": "var(--label-size-offset-sm)" } : {}),
    ...(labelSize === "larger" ? { "--label-font-size-offset": "var(--label-size-offset-lg)" } : {}),
    ...(labelSize === "largest" ? { "--label-font-size-offset": "var(--label-size-offset-xl)" } : {}),
    ...(styleSettings.textColor ? { "--label-color": styleSettings.textColor } : {}),
  };

  // メッセージタイプの場合はラベルのみ表示
  if (field.type === "message") {
    return (
      <div className="preview-field">
        <div className="preview-label" style={labelStyleVars}>
          {field.label || <span className="nf-text-faded">メッセージ</span>}
        </div>
      </div>
    );
  }

  if (readOnly) {
    const childrenForCheckboxes =
      field.type === "checkboxes" && renderChildrenForOption
        ? (Array.isArray(value) ? value : []).map((label) => (
            <div key={`ro_child_${field.id}_${label}`} className={s.child.className}>
              {renderChildrenForOption(label)}
            </div>
          ))
        : null;

    const childrenCommon =
      field.type !== "checkboxes" && renderChildrenAll
        ? <div className={s.child.className}>{renderChildrenAll()}</div>
        : null;

    const readOnlyClassName =
      field.type === "textarea" ? "nf-input nf-input--readonly nf-textarea-readonly" : "nf-input nf-input--readonly";

    return (
      <div className="preview-field">
        <label className="preview-label" style={labelStyleVars}>
          {field.label || <span className="nf-text-faded">項目</span>}
          {field.required && <span className="nf-text-danger nf-ml-4">*</span>}
        </label>
        <div className={readOnlyClassName}>{renderReadOnlyValue()}</div>
        {childrenForCheckboxes}
        {childrenCommon}
      </div>
    );
  }

  return (
    <div className="preview-field">
      <label className="preview-label" style={labelStyleVars}>
        {field.label || <span className="nf-text-faded">項目</span>}
        {field.required && <span className="nf-text-danger nf-ml-4">*</span>}
      </label>

      {(field.type === "text" || field.type === "userName" || field.type === "email") && (
        <input
          type={field.type === "email" ? "email" : "text"}
          value={value ?? ""}
          onChange={(event) => onChange(event.target.value)}
          className={s.input.className}
          placeholder={field.type === "userName"
            ? "入力ユーザー名"
            : (field.type === "email" ? "メールアドレス" : (field.placeholder || "入力"))}
        />
      )}

      {field.type === "textarea" && (
        <textarea
          value={value ?? ""}
          onChange={(event) => onChange(event.target.value)}
          className={`${s.input.className} nf-h-96`}
          placeholder={field.placeholder || "入力"}
        />
      )}

      {field.type === "number" && (
        <input
          type="number"
          value={value ?? ""}
          onChange={(event) => {
            const val = event.target.value;
            onChange(val === "" ? "" : Number(val));
          }}
          className={s.input.className}
          placeholder={field.placeholder || ""}
        />
      )}

      {field.type === "regex" && (
        <>
          <input
            type="text"
            value={value ?? ""}
            onChange={(event) => onChange(event.target.value)}
            className={validation.ok ? s.input.className : `${s.input.className} nf-input--error`}
            placeholder={field.placeholder || "入力"}
          />
          {!validation.ok && (
            <div className="nf-text-danger-ink nf-text-12 nf-mt-4">{validation.message}</div>
          )}
        </>
      )}

      {field.type === "date" && (
        <input
          type="date"
          value={value ?? ""}
          onChange={(event) => onChange(event.target.value)}
          className={s.input.className}
        />
      )}

      {field.type === "time" && (
        <input
          type="time"
          value={value ?? ""}
          onChange={(event) => onChange(event.target.value)}
          className={s.input.className}
        />
      )}

      {field.type === "url" && (
        <input
          type="url"
          value={value ?? ""}
          onChange={(event) => onChange(event.target.value)}
          className={s.input.className}
          placeholder={field.placeholder || "https://example.com"}
        />
      )}

      {field.type === "radio" && (
        <div>
          {(field.options || []).map((opt) => (
            <label key={opt.id} className="nf-block nf-mb-4">
              <input type="radio" name={field.id} checked={value === opt.label} onChange={() => onChange(opt.label)} />
              <span className="nf-ml-6">{opt.label || "選択肢"}</span>
            </label>
          ))}
        </div>
      )}

      {field.type === "select" && (
        <select value={value ?? ""} onChange={(event) => onChange(event.target.value)} className={s.input.className}>
          <option value="">-- 未選択 --</option>
          {(field.options || []).map((opt) => (
            <option key={opt.id} value={opt.label}>
              {opt.label || "選択肢"}
            </option>
          ))}
        </select>
      )}

      {field.type === "checkboxes" && (
        <div>
          {(field.options || []).map((opt) => {
            const arr = Array.isArray(value) ? value : [];
            const checked = arr.includes(opt.label);
            return (
              <div key={opt.id} className="nf-mb-4">
                <label>
                  <input
                    type="checkbox"
                    checked={checked}
                    onChange={(event) => {
                      const next = new Set(arr);
                      event.target.checked ? next.add(opt.label) : next.delete(opt.label);
                      onChange(Array.from(next));
                    }}
                  />
                  <span className="nf-ml-6">{opt.label || "選択肢"}</span>
                </label>
                {checked && renderChildrenForOption && (
                  <div className={s.child.className}>{renderChildrenForOption(opt.label)}</div>
                )}
              </div>
            );
          })}
        </div>
      )}

      {renderChildrenAll && field.type !== "checkboxes" && <div className={s.child.className}>{renderChildrenAll()}</div>}
    </div>
  );
};

const RendererRecursive = ({ fields, responses, onChange, depth = 0, readOnly = false }) => {
  const renderChildrenAll = (field, fid) => () => {
    if (!field?.childrenByValue) return null;
    if (["radio", "select"].includes(field.type)) {
      const selected = (responses || {})[fid];
      if (!selected) return null;
      return (
        <RendererRecursive
          fields={field.childrenByValue[selected] || []}
          responses={responses}
          onChange={onChange}
          depth={depth + 1}
          readOnly={readOnly}
        />
      );
    }
    if (field.type === "checkboxes") {
      const arr = Array.isArray((responses || {})[fid]) ? (responses || {})[fid] : [];
      return arr.map((label) => (
        <RendererRecursive
          key={`child_${fid}_${label}`}
          fields={field.childrenByValue[label] || []}
          responses={responses}
          onChange={onChange}
          depth={depth + 1}
          readOnly={readOnly}
        />
      ));
    }
    return null;
  };

  const renderChildrenForOption = (field, fid, optionLabel) => {
    if (!field?.childrenByValue) return null;
    return (
      <RendererRecursive
        fields={field.childrenByValue[optionLabel] || []}
        responses={responses}
        onChange={onChange}
        depth={depth + 1}
      />
    );
  };

  return (
    <div>
      {(fields || []).map((field, index) => {
        const fid = field?.id || `tmp_${depth}_${index}_${field?.label || ""}`;
        const value = (responses || {})[fid] ?? (responses || {})[field?.id];
        const cardAttrs = s.card(depth, false);
        return (
          <div key={`node_${fid}`} className={cardAttrs.className} data-depth={cardAttrs["data-depth"]}>
            <FieldRenderer
              field={{ ...field, id: fid }}
              value={value}
              onChange={(nextValue) => onChange((prev) => ({ ...(prev || {}), [fid]: nextValue }))}
              renderChildrenAll={renderChildrenAll(field, fid)}
              renderChildrenForOption={(label) => renderChildrenForOption(field, fid, label)}
              readOnly={readOnly}
            />
          </div>
        );
      })}
    </div>
  );
};

const PreviewPage = React.forwardRef(function PreviewPage(
  {
    schema,
    responses,
    setResponses,
    settings = {},
    showOutputJson = true,
    onSave,
    saveButtonLabel = "回答保存",
    showSaveButton = true,
    readOnly = false,
  },
  ref,
) {
  const { showAlert } = useAlert();
  const initialRecordId = settings.recordId;
  const recordIdRef = useRef(initialRecordId || generateRecordId());
  const currentUserName = typeof settings.userName === "string" ? settings.userName : "";
  const currentUserEmail = typeof settings.userEmail === "string" ? settings.userEmail : "";
  const defaultNowMap = useMemo(
    () => collectDefaultNowResponses(schema, new Date(), { userName: currentUserName, userEmail: currentUserEmail }),
    [schema, currentUserName, currentUserEmail],
  );

  useEffect(() => {
    if (initialRecordId && recordIdRef.current !== initialRecordId) {
      recordIdRef.current = initialRecordId;
    }
  }, [initialRecordId]);

  useEffect(() => {
    // 既往データ編集時は日付・時間・入力ユーザー名の自動初期値設定をスキップ
    if (settings.recordId) return;

    if (!defaultNowMap || Object.keys(defaultNowMap).length === 0) return;
    setResponses((prev) => {
      const current = prev || {};
      let changed = false;
      const next = { ...current };
      Object.keys(defaultNowMap).forEach((key) => {
        const currentValue = next[key];
        if (currentValue === undefined || currentValue === null || currentValue === "") {
          next[key] = defaultNowMap[key];
          changed = true;
        }
      });
      return changed ? next : current;
    });
  }, [defaultNowMap, setResponses, settings.recordId]);

  const sortedData = useMemo(() => {
    const raw = collectResponses(schema, responses);
    return sortResponses(raw, schema, responses);
  }, [schema, responses]);
  const output = sortedData.map;
  const sortedKeys = sortedData.keys;
  const formTitle = settings.formTitle || "受付フォーム";

  const [isSaving, setIsSaving] = useState(false);

  const handleSaveToSheet = async (options = {}) => {
    let alertShown = false;
    setIsSaving(true);
    try {
      if (readOnly) {
        throw new Error("read_only_mode");
      }
      const validationResult = collectValidationErrors(schema, responses);
      if (validationResult.errors.length > 0) {
        showAlert(formatValidationErrors(validationResult), "入力エラー");
        alertShown = true;
        throw new Error("validation_failed");
      }

      let spreadsheetId = null;
      if (!onSave) {
        const scriptRunAvailable = hasScriptRun();
        spreadsheetId = normalizeSpreadsheetId(settings.spreadsheetId || "");
        if (!spreadsheetId) {
          showAlert("Spreadsheet ID / URL が未入力です");
          alertShown = true;
          throw new Error("missing_spreadsheet_id");
        }
        if (!scriptRunAvailable) {
          showAlert("この機能はGoogle Apps Script環境でのみ利用可能です");
          alertShown = true;
          throw new Error("missing_script_run");
        }
      }

      const payload = {
        version: 1,
        formTitle,
        schemaHash: computeSchemaHash(schema),
        id: recordIdRef.current,
        responses: output,
        order: sortedKeys,
      };

      if (onSave) {
        const result = await onSave({
          payload,
          sortedKeys,
          recordId: recordIdRef.current,
          responses,
          options,
        });
        return result ?? payload;
      }
      const res = await submitResponses({
        spreadsheetId,
        sheetName: settings.sheetName || "Data",
        payload,
      });
      const msg = res?.spreadsheetUrl
        ? `送信しました（${res.sheetName} に追記 / 行: ${res.rowNumber}）`
        : "送信しました";
      showAlert(msg);
      return res;
    } catch (error) {
      console.error("[PreviewPage] Error in handleSaveToSheet:", error);
      const suppressAlert = alertShown
        || error?.message === "validation_failed"
        || error?.message === "missing_spreadsheet_id"
        || error?.message === "missing_script_run"
        || error?.message === "read_only_mode";
      if (!options?.silent && !suppressAlert) {
        showAlert(`送信に失敗しました: ${error?.message || error}`);
      }
      throw error;
    } finally {
      setIsSaving(false);
    }
  };

  useImperativeHandle(
    ref,
    () => ({
      submit: handleSaveToSheet,
      getRecordId: () => recordIdRef.current,
      getOutput: () => ({ map: output, keys: sortedKeys }),
    }),
    [handleSaveToSheet, output, sortedKeys],
  );

  return (
    <div className="nf-card" data-depth="0">
      <h2 className="preview-title">{formTitle}</h2>
      {settings.showRecordNo !== false && (
        <div className="nf-mb-12">
          <label className="preview-label">No.</label>
          <input type="text" value={settings.recordNo || ""} readOnly className="nf-input nf-input--readonly" />
        </div>
      )}
      <div className="nf-mb-12">
        <label className="preview-label">回答ID</label>
        <input type="text" value={recordIdRef.current} readOnly className="nf-input nf-input--readonly" />
      </div>
      <RendererRecursive fields={schema} responses={responses} onChange={setResponses} readOnly={readOnly} />
      {showOutputJson && (
        <div className="nf-mt-12">
          <label className="preview-label">回答JSON</label>
          <textarea
            readOnly
            value={JSON.stringify(output, null, 2)}
            className={`${s.input.className} preview-json`}
          />
        </div>
      )}
      {showSaveButton && !readOnly && (
        <div className="nf-row nf-gap-8 nf-mt-12 nf-justify-end">
          <button type="button" className={s.btn.className} onClick={handleSaveToSheet} disabled={isSaving}>
            {isSaving ? "保存中..." : saveButtonLabel}
          </button>
        </div>
      )}
</div>
  );
});

export default PreviewPage;



================================================
FILE: builder/src/features/search/searchStyles.js
================================================
import { theme } from "../../app/theme/tokens.js";

// 共通スタイル定義: Searchページで使用するUIの見た目を一元管理

export const createTableStyle = (maxWidth) => ({
  width: maxWidth ? `${maxWidth}px` : "100%",
  borderCollapse: "collapse",
  background: theme.surface,
  borderRadius: theme.radiusMd,
  overflow: "hidden",
});

export const thStyle = {
  textAlign: "left",
  padding: "12px 16px",
  borderBottom: `1px solid ${theme.border}`,
  background: theme.surfaceSubtle,
  fontSize: 13,
  fontWeight: 600,
  cursor: "pointer",
};

export const tdStyle = {
  padding: "12px 16px",
  borderBottom: `1px solid ${theme.borderSubtle}`,
  fontSize: 13,
  color: theme.textStrong,
  verticalAlign: "top",
};

export const searchBarStyle = {
  display: "flex",
  gap: 12,
  marginBottom: 16,
  flexWrap: "wrap",
  alignItems: "center",
};

export const inputStyle = {
  padding: "8px 12px",
  borderRadius: 8,
  border: `1px solid ${theme.borderStrong}`,
  background: theme.surface,
  fontSize: 14,
};

export const sidebarButtonStyle = {
  ...inputStyle,
  width: "100%",
  textAlign: "left",
};

export const paginationInfoStyle = {
  color: theme.textSubtle,
  fontSize: 13,
};

export const paginationContainerStyle = {
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  marginTop: 16,
};

export const paginationNavStyle = {
  display: "flex",
  gap: 8,
};



================================================
FILE: builder/src/features/search/searchTable.js
================================================
import { splitFieldPath, collectDisplayFieldSettings } from "../../utils/formPaths.js";
import { formatUnixMsDateTime, formatUnixMsDate, formatUnixMsTime, toUnixMs, parseStringToSerial } from "../../utils/dateTime.js";
import { MAX_DEPTH as MAX_HEADER_DEPTH } from "../../core/constants.js";
import { traverseSchema } from "../../core/schemaUtils.js";

export { MAX_HEADER_DEPTH };

const FALSE_LIKE_VALUES = new Set([null, undefined, "", false, 0, "0"]);

const toBooleanLike = (value) => {
  if (Array.isArray(value)) {
    return value.some((item) => toBooleanLike(item));
  }
  return !FALSE_LIKE_VALUES.has(value);
};

const columnType = (column) => column?.sourceType || column?.type || "";
const isChoiceColumn = (column) => {
  const type = columnType(column);
  return type === "checkboxes" || type === "radio" || type === "select";
};
const isBooleanSortColumn = (column) => columnType(column) === "checkboxes";
const isNumericColumn = (column) => columnType(column) === "number";
const isDateLikeColumn = (column) => {
  const type = columnType(column);
  return type === "date" || type === "time";
};
const toNumericValue = (value) => {
  if (value === null || value === undefined || value === "") return null;
  if (typeof value === "number" && Number.isFinite(value)) return value;
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : null;
};

const isDevEnvironment = (() => {
  try {
    if (typeof import.meta !== "undefined" && import.meta.env && typeof import.meta.env.DEV === "boolean") {
      return import.meta.env.DEV;
    }
  } catch (error) {
    // no-op: import.meta may not be available in some runtimes
  }
  if (typeof process !== "undefined" && process.env && typeof process.env.NODE_ENV === "string") {
    return process.env.NODE_ENV !== "production";
  }
  return false;
})();

const debugLog = (...args) => {
  if (!isDevEnvironment) return;
  console.debug("[searchTable]", ...args);
};

const buildHeaderFullPath = (matrix, columnIndex) => {
  const parts = [];
  for (let rowIdx = 0; rowIdx < matrix.length; rowIdx += 1) {
    const val = matrix[rowIdx]?.[columnIndex];
    if (val !== null && val !== undefined && val !== "") {
      parts.push(String(val));
    }
  }
  return parts.join("|");
};

const matchBaseDisplayColumn = (columns, fullPath) => {
  if (!columns || !fullPath) return null;
  for (const column of columns) {
    if (!column || !column.path) continue;
    const pathStr = String(column.path);
    if (fullPath === pathStr) {
      return column;
    }
    if (fullPath.startsWith(`${pathStr}|`)) {
      const remainder = fullPath.slice(pathStr.length + 1);
      if (remainder && !remainder.includes("|")) {
        return column;
      }
    }
  }
  return null;
};

const valueToDisplayString = (value) => {
  if (Array.isArray(value)) {
    return value
      .map((item) => valueToDisplayString(item))
      .filter((item) => item !== "" && item !== null && item !== undefined)
      .join("、");
  }
  if (value === null || value === undefined) return "";
  if (value === "") return "";

  return String(value);
};

const formatTemporalValue = (rawValue, unixMs, column) => {
  const type = columnType(column);
  if (type !== "date" && type !== "time") return valueToDisplayString(rawValue);

  const ms = Number.isFinite(unixMs) ? unixMs : toUnixMs(rawValue);
  if (!Number.isFinite(ms)) return valueToDisplayString(rawValue);

  return type === "time" ? formatUnixMsTime(ms) : formatUnixMsDate(ms);
};

const isChoiceMarkerValue = (value) => value === true || value === 1 || value === "1" || value === "●";

const deriveChoiceLabels = (key, value) => {
  if (!isChoiceMarkerValue(value)) return null;
  if (typeof key !== "string" || !key.includes("|")) return null;

  const segments = key.split("|").filter(Boolean);
  if (segments.length === 0) return null;

  const optionLabel = segments[segments.length - 1];
  const questionLabel = segments.slice(0, -1).join("|");
  const combinedLabel = questionLabel ? `${questionLabel}:${optionLabel}` : optionLabel;

  return {
    optionLabel,
    combinedLabel,
  };
};

export const formatDateTime = (value) => {
  if (value instanceof Date) return formatUnixMsDateTime(value.getTime());
  const ms = Number.isFinite(value) ? value : toUnixMs(value);
  if (Number.isFinite(ms)) return formatUnixMsDateTime(ms);
  if (typeof value === "string") return value;
  return "";
};

const normalizeSearchText = (text) => String(text || "").toLowerCase();

const buildSearchableCandidates = (key, value, unixMs = undefined) => {
  const candidates = [];
  const displayValue = valueToDisplayString(value, unixMs);
  if (displayValue) {
    candidates.push(displayValue);
  }

  const choiceLabels = deriveChoiceLabels(key, value);
  if (choiceLabels?.optionLabel) {
    candidates.push(choiceLabels.optionLabel);
    if (choiceLabels.combinedLabel && choiceLabels.combinedLabel !== choiceLabels.optionLabel) {
      candidates.push(choiceLabels.combinedLabel);
    }
  }

  return candidates;
};

const resolveChoiceDisplayValue = (path, rawValue, column) => {
  const type = columnType(column);
  if (type !== "radio" && type !== "select") return rawValue;
  if (!isChoiceMarkerValue(rawValue)) return rawValue;
  const choiceLabels = deriveChoiceLabels(path, rawValue);
  if (!choiceLabels?.optionLabel) return rawValue;
  return choiceLabels.optionLabel;
};

const collectDirectOptionLabels = (data, path) => {
  const optionValues = [];
  const prefix = `${path}|`;
  Object.entries(data).forEach(([key, value]) => {
    if (!key.startsWith(prefix) || key === path) return;
    const remainder = key.slice(prefix.length);
    if (!remainder) return;
    const [head, ...rest] = remainder.split("|");
    if (!head || rest.length > 0) return;
    if (toBooleanLike(value)) {
      optionValues.push(head);
    }
  });
  return optionValues;
};

const deriveBooleanValue = (rawValues) => toBooleanLike(rawValues.length ? rawValues : undefined);

const resolveSortValue = ({ rawValues, display, dataUnixMs, path, column }) => {
  // radio/select はラベル文字列で並び替えるため、真偽値ソートは checkboxes のみに限定する
  if (isBooleanSortColumn(column)) {
    return deriveBooleanValue(rawValues) ? 1 : 0;
  }

  if (rawValues.length === 0) return "";
  if (rawValues.length > 1) return display;

  const raw = rawValues[0];

  if (isNumericColumn(column)) {
    const num = toNumericValue(raw);
    if (num !== null) return num;
  }

  return display;
};

const collectFieldValue = (entry, path, column) => {
  const data = entry?.data || {};
  const dataUnixMs = entry?.dataUnixMs || {};

  const values = [];
  const rawValues = [];
  const addValue = (raw, unixMs) => {
    const normalizedRaw = resolveChoiceDisplayValue(path, raw, column);
    const display = formatTemporalValue(normalizedRaw, unixMs, column);
    if (display === "" || display === null || display === undefined) return;
    values.push(display);
    rawValues.push(raw);
  };

  // 直接値がある場合はそれを優先
  const hasDirectValue = Object.prototype.hasOwnProperty.call(data, path);
  const optionValues = collectDirectOptionLabels(data, path);

  if (hasDirectValue) {
    const directValue = data[path];
    const shouldPreferOptionLabels =
      (columnType(column) === "radio" || columnType(column) === "select") &&
      isChoiceMarkerValue(directValue) &&
      optionValues.length > 0;
    if (shouldPreferOptionLabels) {
      optionValues.forEach((v) => addValue(v));
    } else {
      addValue(directValue, dataUnixMs[path]);
    }
  } else {
    // 直接値がない場合のみ、option値を探す
    if (optionValues.length) {
      // 値を表示用文字列に変換して追加
      optionValues.forEach((v) => addValue(v));
    }
  }

  const display = values.join("、");
  const primary = values[0] || "";
  const sortDisplay = isChoiceColumn(column) && values.length <= 1 ? primary : display;
  const sortValue = resolveSortValue({ rawValues, display: sortDisplay, dataUnixMs, path, column });

  return {
    display,
    search: normalizeSearchText(values.join(" ")),
    sort: sortValue,
    boolean: deriveBooleanValue(rawValues),
  };
};

const compareStrings = (a, b) => {
  const aa = String(a || "");
  const bb = String(b || "");
  return aa.localeCompare(bb, "ja");
};

const compareValues = (a, b) => {
  // 両方が数値の場合
  if (typeof a === 'number' && typeof b === 'number') {
    return a - b;
  }
  // 片方が数値、もう片方が文字列の場合は数値を優先
  if (typeof a === 'number' && typeof b !== 'number') {
    return -1;
  }
  if (typeof a !== 'number' && typeof b === 'number') {
    return 1;
  }
  // それ以外は文字列として比較
  return compareStrings(a, b);
};

const createBaseColumns = () => [
  {
    key: "No.",
    segments: ["No."],
    sortable: true,
    searchable: true,
    getValue: (entry) => {
      const value = entry?.["No."] || "";
      return {
        display: String(value),
        search: normalizeSearchText(value),
        sort: typeof value === 'number' ? value : (value ? parseFloat(value) || 0 : 0),
      };
    },
  },
  {
    key: "modifiedAt",
    segments: ["最終更新日時"],
    sortable: true,
    searchable: true,
    getValue: (entry) => {
      const raw = entry?.modifiedAt ?? "";
      const display = formatDateTime(raw);
      return {
        display,
        search: normalizeSearchText(display || raw || ""),
        sort: display || "",
      };
    },
  },
];

const createDisplayColumn = (path, sourceType = "") => {
  const segments = splitFieldPath(path).slice(0, MAX_HEADER_DEPTH);
  if (segments.length === 0) segments.push("回答");
  const key = `display:${path}`;
  return {
    key,
    segments,
    sortable: true,
    searchable: true,
    path,
    sourceType,
    getValue: (entry, column) => collectFieldValue(entry, path, column),
  };
};

const actionsColumn = {
  key: "__actions",
  segments: ["操作"],
  sortable: false,
  searchable: false,
  getValue: () => ({ display: "", search: "", sort: "" }),
};

const resolveDisplayFieldSettings = (form) => {
  const collected = collectDisplayFieldSettings(form?.schema || []);
  if (Array.isArray(form?.displayFieldSettings) && form.displayFieldSettings.length) {
    const resolveTypeByPath = (path) => {
      const matched = collected.find((item) => item.path === path);
      return matched?.type || "";
    };
    return form.displayFieldSettings
      .filter((item) => item && item.path)
      .map((item) => ({
        path: String(item.path),
        type: item.type || resolveTypeByPath(String(item.path)),
      }));
  }

  return collected
    .filter((item) => item && item.path)
    .map((item) => ({
      path: String(item.path),
      type: item.type || "",
    }));
};

export const buildSearchColumns = (form, { includeOperations = true } = {}) => {
  const showRecordNo = form?.settings?.showRecordNo !== false;
  const baseColumns = createBaseColumns();
  const columns = showRecordNo ? baseColumns : baseColumns.filter((col) => col.key !== "No.");
  resolveDisplayFieldSettings(form).forEach(({ path, type }) => {
    if (!path) return;
    columns.push(createDisplayColumn(path, type));
  });
  if (includeOperations) columns.push(actionsColumn);
  return columns;
};

export const buildHeaderRows = (columns) => {
  if (!columns || columns.length === 0) return [];

  const normalized = columns.map((column) => {
    const segments = Array.isArray(column.segments) ? column.segments : [];
    const limited = segments
      .filter((segment) => segment !== undefined && segment !== null)
      .slice(0, MAX_HEADER_DEPTH)
      .map((segment) => (typeof segment === "string" ? segment : String(segment)));
    if (limited.length === 0) {
      limited.push(String(column.key ?? ""));
    }
    return {
      segments: limited,
      length: limited.length,
    };
  });

  const depth = Math.min(
    MAX_HEADER_DEPTH,
    Math.max(...normalized.map((column) => column.length || 1), 1),
  );

  const perLevel = Array.from({ length: depth }, () => Array(normalized.length).fill(null));

  normalized.forEach(({ segments }, columnIndex) => {
    const limited = segments.slice(0, depth);
    const segmentCount = limited.length;
    for (let level = 0; level < segmentCount; level += 1) {
      const rawLabel = limited[level] ?? "";
      const label = typeof rawLabel === "string" ? rawLabel : String(rawLabel);
      const rowSpan = level === segmentCount - 1 ? Math.max(1, depth - level) : 1;
      perLevel[level][columnIndex] = {
        label,
        rowSpan,
      };
    }
  });

  const rows = [];
  for (let level = 0; level < depth; level += 1) {
    const row = [];
    let colIndex = 0;
    while (colIndex < perLevel[level].length) {
      const cell = perLevel[level][colIndex];
      if (!cell) {
        colIndex += 1;
        continue;
      }
      const isFirstRow = level === 0;
      let colSpan = 1;
      if (!isFirstRow) {
        while (
          colIndex + colSpan < perLevel[level].length &&
          perLevel[level][colIndex + colSpan] &&
          perLevel[level][colIndex + colSpan].label === cell.label &&
          perLevel[level][colIndex + colSpan].rowSpan === cell.rowSpan
        ) {
          colSpan += 1;
        }
      }

      row.push({
        label: cell.label,
        colSpan,
        rowSpan: cell.rowSpan,
        startIndex: colIndex,
        column: isFirstRow ? columns[colIndex] || null : null,
      });

      colIndex += colSpan;
    }
    if (row.length) rows.push(row);
  }

  return rows;
};

/**
 * headerMatrixから表示すべき列のインデックスを抽出
 * @param {Array<Array<string>>} multiHeaderRows - 11行×列数の2次元配列
 * @param {Array} columns - 表示する列の定義
 * @returns {Array<number>} - 表示する列のインデックス配列
 */
const filterVisibleColumnIndices = (multiHeaderRows, columns) => {
  if (!multiHeaderRows || multiHeaderRows.length === 0 || !columns) return [];

  const firstRow = multiHeaderRows[0] || [];
  const visibleIndices = [];
  const choiceResolvedPaths = new Set();

  for (let i = 0; i < firstRow.length; i += 1) {
    const headerValue = firstRow[i];
    const headerValueStr = String(headerValue);

    if (headerValueStr === "No." || headerValueStr === "modifiedAt") {
      if (columns.some((col) => col?.key === headerValueStr)) {
        visibleIndices.push(i);
      }
      continue;
    }

    const fullPath = buildHeaderFullPath(multiHeaderRows, i);
    if (!fullPath) continue;

    const baseColumn = matchBaseDisplayColumn(columns, fullPath);
    if (!baseColumn) continue;

    if (isChoiceColumn(baseColumn)) {
      const basePath = baseColumn.path ? String(baseColumn.path) : "";
      if (!basePath || choiceResolvedPaths.has(basePath)) {
        continue;
      }
      choiceResolvedPaths.add(basePath);
    }

    visibleIndices.push(i);
  }

  debugLog("filterVisibleColumnIndices", {
    visibleCount: visibleIndices.length,
    sample: visibleIndices.slice(0, 10),
  });
  return visibleIndices;
};

/**
 * CSVのマルチヘッダー構造（11行）からテーブルヘッダー行を生成
 * @param {Array<Array<string>>} multiHeaderRows - 11行×列数の2次元配列
 * @param {Array} columns - 表示する列の定義（オプション）
 * @returns {Array<Array<{label: string, colSpan: number, rowSpan: number, startIndex: number}>>}
 */
/**
 * headerMatrixからスプレッドシートの実際の列に対応するcolumns配列を生成
 * @param {Array<Array<string>>} multiHeaderRows - 11行×列数の2次元配列
 * @param {Array} baseColumns - ベースとなる列定義（表示フィールドなど）
 * @returns {Array} スプレッドシートの列に対応するcolumns配列
 */
export const buildColumnsFromHeaderMatrix = (multiHeaderRows, baseColumns) => {
  if (!multiHeaderRows || multiHeaderRows.length === 0) return baseColumns || [];

  const firstRow = multiHeaderRows[0] || [];
  const result = [];
  const seenKeys = new Set();
  const resolvedBasePaths = new Set();
  const safeBaseColumns = Array.isArray(baseColumns) ? baseColumns : [];

  const pushColumn = (column) => {
    if (!column) return;
    if (column.key && seenKeys.has(column.key)) return;
    result.push(column);
    if (column.key) seenKeys.add(column.key);
  };

  const findBaseColumnByKey = (key) => safeBaseColumns.find((col) => col?.key === key) || null;

  for (let colIndex = 0; colIndex < firstRow.length; colIndex += 1) {
    const headerValue = firstRow[colIndex];
    const headerValueStr = String(headerValue);

    if (headerValueStr === "No.") {
      pushColumn(findBaseColumnByKey("No."));
      continue;
    }
    if (headerValueStr === "modifiedAt") {
      pushColumn(findBaseColumnByKey("modifiedAt"));
      continue;
    }

    const fullPath = buildHeaderFullPath(multiHeaderRows, colIndex);
    if (!fullPath) continue;

    const baseColumn = matchBaseDisplayColumn(safeBaseColumns, fullPath);
    if (!baseColumn) continue;

    if (isChoiceColumn(baseColumn)) {
      const basePath = baseColumn.path ? String(baseColumn.path) : "";
      if (!basePath || resolvedBasePaths.has(basePath)) {
        continue;
      }
      pushColumn(createDisplayColumn(basePath, baseColumn.sourceType));
      resolvedBasePaths.add(basePath);
      debugLog("buildColumnsFromHeaderMatrix:choice", { basePath, columnIndex: colIndex });
    } else {
      pushColumn(createDisplayColumn(fullPath, baseColumn.sourceType));
      if (baseColumn.path) {
        resolvedBasePaths.add(String(baseColumn.path));
      }
    }
  }

  // headerMatrixに存在しない場合でも、ベース列は最低限表示する
  safeBaseColumns.forEach((baseColumn) => {
    if (!baseColumn) return;
    if (baseColumn.key === "__actions" || baseColumn.key === "No." || baseColumn.key === "modifiedAt") return;
    if (!baseColumn.path) return;
    const basePath = String(baseColumn.path);
    if (resolvedBasePaths.has(basePath)) return;
    resolvedBasePaths.add(basePath);
    pushColumn(createDisplayColumn(basePath, baseColumn.sourceType));
  });

  pushColumn(findBaseColumnByKey("__actions"));

  debugLog("buildColumnsFromHeaderMatrix:result", { total: result.length });
  return result;
};

export const buildHeaderRowsFromCsv = (multiHeaderRows, columns = null) => {
  if (!multiHeaderRows || multiHeaderRows.length === 0) return [];

  // 表示する列のインデックスを取得
  let visibleIndices = null;
  if (columns) {
    visibleIndices = filterVisibleColumnIndices(multiHeaderRows, columns);
    if (visibleIndices.length === 0) return [];
  }

  // 対象列（表示する列のみ）を確定
  const indicesToProcess = visibleIndices || Array.from({ length: multiHeaderRows[0]?.length || 0 }, (_, i) => i);

  // 変換後のヘッダ行（簡略表示で最下段を落とす処理用）
  const transformedRows = multiHeaderRows.map((row) => (row ? [...row] : []));

  // headerMatrixの第1行から各列に対応するcolumnオブジェクトを構築
  const firstRow = multiHeaderRows[0] || [];
  const columnMapping = [];

  for (let i = 0; i < firstRow.length; i += 1) {
    const headerValue = firstRow[i];
    const headerValueStr = String(headerValue);

    let matchedColumn = null;

    if (columns) {
      if (headerValueStr === "No.") {
        matchedColumn = columns.find((col) => col.key === "No.") || null;
      } else if (headerValueStr === "modifiedAt") {
        matchedColumn = columns.find((col) => col.key === "modifiedAt") || null;
      } else {
        const fullPath = buildHeaderFullPath(multiHeaderRows, i);
        if (fullPath) {
          matchedColumn = columns.find((col) => col.path === fullPath) || null;
          if (!matchedColumn) {
            const baseColumn = matchBaseDisplayColumn(columns, fullPath);
            if (baseColumn) {
              if (isChoiceColumn(baseColumn)) {
                matchedColumn = createDisplayColumn(baseColumn.path, baseColumn.sourceType);
              } else {
                matchedColumn = createDisplayColumn(fullPath, baseColumn.sourceType);
              }
            }
          }
        }
      }
    }

    columnMapping[i] = matchedColumn;
  }

  // 選択系は常に縮退表示: 最下段の見出しセルを空欄化
  const findDeepestRowWithValue = (colIndex) => {
    for (let r = transformedRows.length - 1; r >= 0; r -= 1) {
      const val = transformedRows[r]?.[colIndex];
      if (val !== null && val !== undefined && val !== "") return r;
    }
    return -1;
  };
  indicesToProcess.forEach((colIndex) => {
    const mappedColumn = columnMapping[colIndex];
    if (!isChoiceColumn(mappedColumn)) return;
    const deepest = findDeepestRowWithValue(colIndex);
    if (deepest >= 0) {
      transformedRows[deepest][colIndex] = "";
    }
  });

  // 全段表示が原則のため、行はすべて処理する
  const nonEmptyRowIndices = Array.from({ length: transformedRows.length }, (_, idx) => idx);
  const rows = [];

  // 各列の統合されたパス(全行を結合したもの)を事前に計算
  const columnFullPaths = indicesToProcess.map((colIndex) => {
    const fullPath = buildHeaderFullPath(multiHeaderRows, colIndex);
    return fullPath;
  });

  const resolveHeaderCellValue = (rowIndex, colIndex, displayColumnIndex) => {
    const csvRow = transformedRows[rowIndex] || [];
    const mappedColumn = columnMapping[colIndex];
    let cellValue = csvRow[colIndex] || "";

    // modifiedAtを「最終更新日時」に変換
    if (rowIndex === 0 && cellValue === "modifiedAt") {
      cellValue = "最終更新日時";
    }

    // 選択系（ラジオ/セレクト/チェックボックス）の選択肢行はヘッダー表示しない（データ側で表示されるため）
    if (mappedColumn?.sourceType && (mappedColumn.sourceType === "radio" || mappedColumn.sourceType === "select" || mappedColumn.sourceType === "checkboxes")) {
      const fullPath = columnFullPaths[displayColumnIndex] || "";
      const segments = splitFieldPath(fullPath);
      const expectedLabel = segments[rowIndex] || "";
      if (expectedLabel && cellValue === expectedLabel && rowIndex === segments.length - 1) {
        return "";
      }
    }

    return cellValue;
  };

  // 空でない行のみを処理
  for (const rowIndex of nonEmptyRowIndices) {
    const rowCellValues = indicesToProcess.map((colIndex, displayColumnIndex) =>
      resolveHeaderCellValue(rowIndex, colIndex, displayColumnIndex),
    );
    const row = [];
    let displayIndex = 0;
    let lastRenderedLabel = "";

    for (let i = 0; i < indicesToProcess.length; i++) {
      const colIndex = indicesToProcess[i];
      const mappedColumn = columnMapping[colIndex];
      const cellValue = rowCellValues[i];

      // 1行目の場合は各列を個別に処理(ソート対応のため)
      const isFirstRow = rowIndex === 0;
      let colSpan = 1;

      if (!isFirstRow) {
        // 1行目以外は同じ値が連続する場合はcolSpanでまとめる
        // (表示変換後の値で判定し、列ごとの非表示ロジックを尊重する)
        while (
          i + colSpan < indicesToProcess.length &&
          indicesToProcess[i + colSpan] === indicesToProcess[i] + colSpan &&
          rowCellValues[i + colSpan] === rowCellValues[i]
        ) {
          colSpan += 1;
        }
      }

      // 1行目の場合のみcolumnオブジェクトを付与
      const column = isFirstRow ? mappedColumn : null;

      // すべての行で、左に同じ文字列があれば空白化（連続重複を抑止）
      let displayLabel = cellValue;
      if (displayLabel && lastRenderedLabel === displayLabel) {
        displayLabel = "";
      }

      row.push({
        label: displayLabel,
        colSpan,
        rowSpan: 1,
        startIndex: displayIndex,
        column: column,
        originalLabel: cellValue, // ソート用に元のラベルを保持
      });

      displayIndex += colSpan;
      if (displayLabel) {
        lastRenderedLabel = displayLabel;
      }
      i += colSpan - 1;
    }

    if (row.length > 0) rows.push(row);
  }

  // すべて空ラベルの行は除外（簡略表示で最下段を省いた場合の余白を削除）
  const filteredRows = rows.filter((row) => row.some((cell) => cell.label));

  return filteredRows;
};

export const buildSearchTableLayout = (form, { headerMatrix = null, includeOperations = true } = {}) => {
  const baseColumns = buildSearchColumns(form, { includeOperations });
  const hasHeaderMatrix = Array.isArray(headerMatrix) && headerMatrix.length > 0;
  if (!hasHeaderMatrix) {
    return {
      columns: baseColumns,
      headerRows: buildHeaderRows(baseColumns),
    };
  }

  const columns = buildColumnsFromHeaderMatrix(headerMatrix, baseColumns);
  const headerRowsFromCsv = buildHeaderRowsFromCsv(headerMatrix, columns);
  return {
    columns,
    headerRows: headerRowsFromCsv && headerRowsFromCsv.length > 0
      ? headerRowsFromCsv
      : buildHeaderRows(columns),
  };
};

const padRowToLength = (row, length) => {
  const base = Array.isArray(row) ? row.slice(0, length) : [];
  while (base.length < length) base.push("");
  return base.map((cell) => (cell === null || cell === undefined ? "" : String(cell)));
};

const expandHeaderRowsToMatrix = (headerRows, columnCount) => {
  if (!Array.isArray(headerRows) || headerRows.length === 0 || columnCount <= 0) return [];
  const matrix = Array.from({ length: headerRows.length }, () => Array(columnCount).fill(""));
  headerRows.forEach((row, rowIndex) => {
    (row || []).forEach((cell) => {
      if (!cell) return;
      const start = Number(cell.startIndex) || 0;
      if (start < 0 || start >= columnCount) return;
      matrix[rowIndex][start] = cell.label ?? "";
    });
  });
  return matrix;
};

const suppressDuplicateHeaderLabels = (matrix) => {
  if (!Array.isArray(matrix) || matrix.length === 0) return matrix;
  return matrix.map((row) => {
    if (!Array.isArray(row)) return row;
    const result = [...row];
    for (let i = 0; i < result.length; i += 1) {
      const val = result[i] === null || result[i] === undefined ? "" : String(result[i]);
      const prev = i > 0
        ? (row[i - 1] === null || row[i - 1] === undefined ? "" : String(row[i - 1]))
        : "";
      if (val && prev === val) {
        result[i] = "";
      }
    }
    return result;
  });
};

const collectAllFieldSettings = (schema) => {
  const collected = [];
  const seen = new Set();
  traverseSchema(schema || [], (field, context) => {
    const path = context?.pathSegments?.join("|") || "";
    if (!path || seen.has(path)) return;
    seen.add(path);
    collected.push({
      path,
      type: field?.type || "",
    });
  });
  return collected;
};

export const buildExportColumns = (form, { includeBaseColumns = true } = {}) => {
  const columns = [];
  if (includeBaseColumns) {
    columns.push(...createBaseColumns());
  }
  collectAllFieldSettings(form?.schema || []).forEach(({ path, type }) => {
    if (!path) return;
    columns.push(createDisplayColumn(path, type));
  });
  return columns;
};

export const buildExportTableData = ({ form, entries }) => {
  const columns = buildExportColumns(form, { includeBaseColumns: true });
  const headerRows = buildHeaderRows(columns);
  const headerMatrix = expandHeaderRowsToMatrix(headerRows, columns.length);
  const deduped = suppressDuplicateHeaderLabels(headerMatrix);
  const normalizedHeaderRows = deduped.map((row) => padRowToLength(row, columns.length));
  const normalizedRows = (entries || []).map((entry) => {
    const values = computeRowValues(entry, columns);
    const row = columns.map((column) => {
      const display = values?.[column.key]?.display;
      if (display === null || display === undefined) return "";
      return String(display);
    });
    return padRowToLength(row, columns.length);
  });
  return {
    columns,
    headerRows: normalizedHeaderRows,
    rows: normalizedRows,
  };
};

export const computeRowValues = (entry, columns) => {
  const values = {};
  (columns || []).forEach((column) => {
    if (!column || !column.key) return;
    if (typeof column.getValue !== "function") {
      values[column.key] = { display: "", search: "", sort: "" };
      return;
    }
    values[column.key] = column.getValue(entry, column) || { display: "", search: "", sort: "" };
  });
  return values;
};

export const compareByColumn = (a, b, column, order = "asc") => {
  if (!column || column.sortable === false) return 0;
  const sortableA = a?.values?.[column.key]?.sort ?? "";
  const sortableB = b?.values?.[column.key]?.sort ?? "";
  const result = compareValues(sortableA, sortableB);
  const finalResult = order === "asc" ? result : -result;
  return finalResult;
};

export const buildDisplayText = (value) => valueToDisplayString(value);

export const applyDisplayLengthLimit = (text, limit) => {
  if (typeof text !== "string") return text ?? "";
  const maxLength = Number(limit);
  if (!Number.isFinite(maxLength) || maxLength <= 0) return text;
  if (text.length <= maxLength) return text;
  return `${text.slice(0, maxLength)}…`;
};

export const parseSearchCellDisplayLimit = (rawValue) => {
  const parsed = Number(rawValue);
  if (!Number.isFinite(parsed) || parsed <= 0) return null;
  return parsed;
};

/**
 * 検索クエリをトークン化
 * 例: '氏名:"山田" and (年齢>=20 or 性別:男性)'
 */
const tokenizeSearchQuery = (query) => {
  if (!query || typeof query !== 'string') return [];

  const tokens = [];
  const normalizedQuery = query.replace(/==/g, "=");
  let i = 0;
  const len = normalizedQuery.length;

  const pushAlwaysFalse = () => {
    tokens.push({ type: 'ALWAYS_FALSE' });
  };

  while (i < len) {
    const char = normalizedQuery[i];

    // 空白をスキップ
    if (/\s/.test(char)) {
      i++;
      continue;
    }

    // 括弧
    if (char === '(' || char === ')') {
      tokens.push({ type: char === '(' ? 'LPAREN' : 'RPAREN', value: char });
      i++;
      continue;
    }

    // NOT演算子（後続が空白または括弧のみ許容）
    const remainingForNot = normalizedQuery.slice(i);
    const notMatch = remainingForNot.match(/^(not)(?=[\s(])/i);
    if (notMatch) {
      tokens.push({ type: 'NOT', value: 'not' });
      i += notMatch[0].length;
      continue;
    }

    // AND/OR演算子
    const remaining = normalizedQuery.slice(i);
    if (/^(and|AND)\b/i.test(remaining)) {
      tokens.push({ type: 'AND', value: 'and' });
      i += 3;
      continue;
    }
    if (/^(or|OR)\b/i.test(remaining)) {
      tokens.push({ type: 'OR', value: 'or' });
      i += 2;
      continue;
    }

    // 条件式のトークン化
    // パターン1: 列名:/正規表現/
    const regexMatch = remaining.match(/^([^:()]+?):\/(.+?)\//);
    if (regexMatch) {
      const colName = regexMatch[1].trim().replace(/^["']|["']$/g, '');
      const pattern = regexMatch[2];
      tokens.push({ type: 'REGEX', column: colName, pattern });
      i += regexMatch[0].length;
      continue;
    }

    // パターン2: 列名[演算子]値（数値・等価比較用。":" "=" "==" 同義）
    // 引用符で囲まれた値はスペースを含めて全体を取得
    let operatorMatch = remaining.match(/^([^:()]+?)(>=|<=|<>|><|!=|>|<|=|:|==)"([^"]*)"(?=\s|$|and|AND|or|OR|\))/i);
    if (!operatorMatch) {
      operatorMatch = remaining.match(/^([^:()]+?)(>=|<=|<>|><|!=|>|<|=|:|==)'([^']*)'(?=\s|$|and|AND|or|OR|\))/i);
    }
    if (!operatorMatch) {
      operatorMatch = remaining.match(/^([^:()]+?)(>=|<=|<>|><|!=|>|<|=|:|==)(.+?)(?=\s|$|and|AND|or|OR|\))/i);
    }
    if (operatorMatch) {
      const colName = operatorMatch[1].trim().replace(/^["']|["']$/g, '');
      const operator = operatorMatch[2];
      let value = operatorMatch[3].trim().replace(/^["']|["']$/g, '');
      if (value === "") {
        pushAlwaysFalse();
        i += operatorMatch[0].length;
        continue;
      }
      const normalized = value.toLowerCase();
      const op = operator === ":" || operator === "==" ? "=" : operator;

      // 真偽指定（=のみ）
      if ((normalized === "true" || normalized === "false") && (op === "=")) {
        tokens.push({ type: 'COLUMN_BOOL', column: colName, value: normalized === "true" });
        i += operatorMatch[0].length;
        continue;
      }

      // 数値比較か判定（= / > / < 等でも数値優先）
      const num = Number(value);
      const isNumeric = Number.isFinite(num);
      if (!isNumeric && op === "=") {
        // 文字列として扱う → COLUMN_PARTIAL（含有）に回す
        tokens.push({ type: 'COLUMN_PARTIAL', column: colName, keyword: value });
        i += operatorMatch[0].length;
        continue;
      }

      tokens.push({ type: 'COMPARE', column: colName, operator: op, value });
      i += operatorMatch[0].length;
      continue;
    }

    // パターン3: 列名:部分一致ワード
    const colonMatch = remaining.match(/^([^:()]+?):(.*?)(?=\s|$|and|AND|or|OR|\))/i);
    if (colonMatch) {
      const colName = colonMatch[1].trim().replace(/^["']|["']$/g, '');
      const keywordRaw = colonMatch[2].trim();
      const keyword = keywordRaw.replace(/^["']|["']$/g, '');
      if (!keyword) {
        pushAlwaysFalse();
        i += colonMatch[0].length;
        continue;
      }
      const normalized = keyword.toLowerCase();
      if (normalized === "true" || normalized === "false") {
        tokens.push({ type: 'COLUMN_BOOL', column: colName, value: normalized === "true" });
      } else {
        tokens.push({ type: 'COLUMN_PARTIAL', column: colName, keyword });
      }
      i += colonMatch[0].length;
      continue;
    }

    // パターン4: 部分一致ワード（列名なし）
    const wordMatch = remaining.match(/^(.+?)(?=\s|$|and|AND|or|OR|\))/i);
    if (wordMatch) {
      const keyword = wordMatch[1].trim().replace(/^["']|["']$/g, '');
      if (keyword) {
        tokens.push({ type: 'PARTIAL', keyword });
        i += wordMatch[0].length;
        continue;
      }
    }

    // マッチしない場合は1文字進む
    i++;
  }

  return tokens;
};

/**
 * トークン列をASTに変換（再帰下降パーサー）
 */
const parseTokens = (tokens) => {
  let pos = 0;

  const parseExpression = () => {
    let left = parseTerm();

    while (pos < tokens.length && tokens[pos].type === 'OR') {
      pos++; // 'OR'をスキップ
      const right = parseTerm();
      left = { type: 'OR', left, right };
    }

    return left;
  };

  const parseTerm = () => {
    let left = parseFactor();

    while (pos < tokens.length && tokens[pos].type === 'AND') {
      pos++; // 'AND'をスキップ
      const right = parseFactor();
      left = { type: 'AND', left, right };
    }

    return left;
  };

  const parseFactor = () => {
    const token = tokens[pos];

    if (!token) {
      return { type: 'EMPTY' };
    }

    if (token.type === 'NOT') {
      pos++;
      const expr = parseFactor();
      return { type: 'NOT', value: expr };
    }

    // 括弧で囲まれた式
    if (token.type === 'LPAREN') {
      pos++; // '('をスキップ
      const expr = parseExpression();
      if (pos < tokens.length && tokens[pos].type === 'RPAREN') {
        pos++; // ')'をスキップ
      }
      return expr;
    }

    // 条件
    if (['PARTIAL', 'COLUMN_PARTIAL', 'COMPARE', 'REGEX', 'COLUMN_BOOL', 'ALWAYS_FALSE'].includes(token.type)) {
      pos++;
      return token;
    }

    return { type: 'EMPTY' };
  };

  if (tokens.length === 0) {
    return { type: 'EMPTY' };
  }

  return parseExpression();
};

/**
 * 列名から対応するcolumnオブジェクトを取得
 */
const findColumnByName = (columns, colName) => {
  if (!columns || !colName) return null;

  const normalized = colName.trim().toLowerCase();

  return columns.find(col => {
    // key名でマッチング
    if (col.key && col.key.toLowerCase() === normalized) return true;

    // path名でマッチング
    if (col.path && col.path.toLowerCase() === normalized) return true;

    // segments（表示名）でマッチング
    if (col.segments && Array.isArray(col.segments)) {
      const lastSegment = col.segments[col.segments.length - 1];
      if (lastSegment && lastSegment.toLowerCase() === normalized) return true;

      // 全セグメントを結合してマッチング
      const fullName = col.segments.join('|').toLowerCase();
      if (fullName === normalized) return true;
    }

    return false;
  });
};

const findMatchingEntryField = (row, columnName) => {
  const entryData = row?.entry?.data || {};
  const entryDataUnixMs = row?.entry?.dataUnixMs || {};
  const normalizedColName = (columnName || "").toLowerCase();
  if (!normalizedColName) return null;

  const matchingKey = Object.keys(entryData).find((key) => {
    const lower = key.toLowerCase();
    return lower === normalizedColName || lower.includes(normalizedColName);
  });

  if (!matchingKey) return null;

  return {
    key: matchingKey,
    value: entryData[matchingKey],
    unixMs: entryDataUnixMs[matchingKey],
  };
};

const candidateMatches = (field, predicate) => {
  if (!field) return false;
  return buildSearchableCandidates(field.key, field.value, field.unixMs).some(predicate);
};

/**
 * 日時文字列をタイムスタンプに変換（JSTとして扱う）
 * @param {string} dateStr - 日時文字列（ISO 8601、YYYY-MM-DD、YYYY-MM-DD HH:MM形式）
 * @returns {number|null} - タイムスタンプ（ミリ秒）またはnull
 */
/**
 * 値の比較（数値/文字列/日時を適切に処理）
 */
const compareValue = (rowValue, operator, targetValue, { allowNumeric = true } = {}) => {
  // 値の正規化
  const normalizeValue = (val) => {
    if (val === null || val === undefined || val === '') return '';
    return String(val);
  };

  let normalizedOperator = operator;
  if (operator === ':' || operator === '==') normalizedOperator = '=';
  if (operator === '!=') normalizedOperator = '<>';
  if (operator === '><') normalizedOperator = '<>';

  const rowStr = normalizeValue(rowValue);
  const targetStr = normalizeValue(targetValue);

  // 両方が数値として解釈できる場合は数値比較
  const rowNum = parseFloat(rowStr);
  const targetNum = parseFloat(targetStr);
  const bothNumbers = !Number.isNaN(rowNum) && !Number.isNaN(targetNum);

  // 引用符で囲まれていない数値の場合は数値比較
  const isQuoted = /^["']/.test(targetValue);

  if (allowNumeric && normalizedOperator !== '=' && normalizedOperator !== '<>' && normalizedOperator !== '><') {
    if (!bothNumbers || isQuoted) {
      return false;
    }
  }

  switch (normalizedOperator) {
    case '=':
      if (allowNumeric && bothNumbers && !isQuoted) return rowNum === targetNum;
      return rowStr === targetStr;

    case '<>':
    case '><':
      if (allowNumeric && bothNumbers && !isQuoted) return rowNum !== targetNum;
      return rowStr !== targetStr;

    case '>':
      if (allowNumeric && bothNumbers && !isQuoted) return rowNum > targetNum;
      return rowStr > targetStr;

    case '>=':
      if (allowNumeric && bothNumbers && !isQuoted) return rowNum >= targetNum;
      return rowStr >= targetStr;

    case '<':
      if (allowNumeric && bothNumbers && !isQuoted) return rowNum < targetNum;
      return rowStr < targetStr;

    case '<=':
      if (allowNumeric && bothNumbers && !isQuoted) return rowNum <= targetNum;
      return rowStr <= targetStr;

    default:
      return false;
  }
};

const resolveBooleanValueForRow = (row, column, columnName) => {
  const collectFromEntry = (entryData, target) => {
    const targetLower = String(target || "").toLowerCase();
    let found = false;
    let truthy = false;
    Object.entries(entryData || {}).forEach(([key, value]) => {
      const lower = String(key).toLowerCase();
      if (lower === targetLower || lower.startsWith(`${targetLower}|`)) {
        found = true;
        if (toBooleanLike(value)) truthy = true;
      }
    });
    if (!found) return null;
    return truthy;
  };

  if (column) {
    const cellValue = row?.values?.[column.key];
    if (typeof cellValue?.boolean === "boolean") return cellValue.boolean;
    if (isChoiceColumn(column)) {
      if (cellValue?.sort === 1) return true;
      if (cellValue?.sort === 0) return false;
    }
    if (cellValue && Object.prototype.hasOwnProperty.call(cellValue, "display")) {
      return toBooleanLike(cellValue.display);
    }
  }

  const entryData = row?.entry?.data || {};
  const boolFromEntry = collectFromEntry(entryData, columnName);
  if (boolFromEntry !== null) return boolFromEntry;

  return false;
};

/**
 * ASTを評価して行がマッチするか判定
 */
const evaluateAST = (ast, row, columns) => {
  if (!ast || ast.type === 'EMPTY') return true;

  switch (ast.type) {
    case 'NOT':
      return !evaluateAST(ast.value, row, columns);

    case 'AND':
      return evaluateAST(ast.left, row, columns) && evaluateAST(ast.right, row, columns);

    case 'OR':
      return evaluateAST(ast.left, row, columns) || evaluateAST(ast.right, row, columns);

    case 'PARTIAL': {
      // 全列に対してOR検索（表示列だけでなく、全データフィールドも対象）
      const keyword = normalizeSearchText(ast.keyword);
      if (!keyword) return true;

      // まず表示されている列を検索
      const matchesInColumns = (columns || []).some((column) => {
        if (column.searchable === false) return false;
        const text = row?.values?.[column.key]?.search;
        if (!text) return false;
        return text.includes(keyword);
      });

      if (matchesInColumns) return true;

      // 表示列で見つからなかった場合、全データフィールドを検索
      const entryData = row?.entry?.data || {};
      const entryDataUnixMs = row?.entry?.dataUnixMs || {};

      return Object.entries(entryData).some(([key, value]) => {
        const unixMs = entryDataUnixMs[key];
        return buildSearchableCandidates(key, value, unixMs).some((candidate) => {
          if (!candidate) return false;
          const normalized = normalizeSearchText(candidate);
          return normalized.includes(keyword);
        });
      });
    }

    case 'COLUMN_PARTIAL': {
      // 指定列に対して部分一致検索
      const column = findColumnByName(columns, ast.column);
      if (!ast.keyword) return false;

      // 表示列から検索
      if (column) {
        const text = row?.values?.[column.key]?.search;
        if (text) {
          const keyword = normalizeSearchText(ast.keyword);
          return text.includes(keyword);
        }
      }

      // 表示列にない場合、データフィールドから直接検索
      const entryField = findMatchingEntryField(row, ast.column);
      if (!entryField) return false;
      const keyword = normalizeSearchText(ast.keyword);
      return candidateMatches(entryField, (candidate) => {
        if (!candidate) return false;
        const normalized = normalizeSearchText(candidate);
        return normalized.includes(keyword);
      });
    }

    case 'COLUMN_BOOL': {
      const column = findColumnByName(columns, ast.column);
      const boolValue = resolveBooleanValueForRow(row, column, ast.column);
      return boolValue === ast.value;
    }

    case 'COMPARE': {
      // 指定列に対して比較演算
      const column = findColumnByName(columns, ast.column);
      if (ast.value === "") return false;

      // 表示列から取得
      if (column) {
        const cellValue = row?.values?.[column.key];
        // sort値を使用（数値の場合は数値、文字列の場合は文字列）
        const rowValue = cellValue?.sort ?? cellValue?.display ?? '';
        if (isDateLikeColumn(column)) {
          const parser = parseStringToSerial;
          const rowMs = parser(String(rowValue));
          const targetMs = parser(String(ast.value));
          if (!Number.isFinite(rowMs) || !Number.isFinite(targetMs)) return false;
          return compareValue(rowMs, ast.operator, targetMs, { allowNumeric: true });
        }

        const numericPossible = Number.isFinite(Number(rowValue)) && Number.isFinite(Number(ast.value));
        const allowNumeric = isNumericColumn(column) || typeof rowValue === "number" || numericPossible;

        if (rowValue !== '') {
          return compareValue(rowValue, ast.operator, ast.value, { allowNumeric });
        }
      }

      // 表示列にない場合、データフィールドから直接取得
      const entryField = findMatchingEntryField(row, ast.column);
      if (!entryField) return false;

      return candidateMatches(entryField, (candidate) => {
        if (candidate === undefined || candidate === null || candidate === "") return false;
        const numCandidate = Number(candidate);
        const numTarget = Number(ast.value);
        const allowNumericCandidate = Number.isFinite(numCandidate) && Number.isFinite(numTarget);
        return compareValue(candidate, ast.operator, ast.value, { allowNumeric: allowNumericCandidate });
      });
    }

    case 'REGEX': {
      // 指定列に対して正規表現検索
      const column = findColumnByName(columns, ast.column);
      if (!ast.pattern) return false;

      // 表示列から検索
      if (column) {
        const text = row?.values?.[column.key]?.display ?? '';
        if (text) {
          try {
            const regex = new RegExp(ast.pattern, 'i');
            return regex.test(text);
          } catch (error) {
            console.warn('Invalid regex pattern:', ast.pattern, error);
            return false;
          }
        }
      }

      // 表示列にない場合、データフィールドから直接検索
      const entryField = findMatchingEntryField(row, ast.column);
      if (!entryField) return false;

      try {
        const regex = new RegExp(ast.pattern, 'i');
        return candidateMatches(entryField, (candidate) => (candidate ? regex.test(candidate) : false));
      } catch (error) {
        console.warn('Invalid regex pattern:', ast.pattern, error);
        return false;
      }
    }

    default:
      if (ast.type === 'ALWAYS_FALSE') return false;
      return true;
  }
};

/**
 * 検索クエリに基づいて行をフィルタリング
 *
 * 検索パターン:
 * 1. {部分一致ワード} - 全テキスト列でOR検索
 * 2. {列名}:{部分一致ワード} - 指定列で部分一致検索
 * 3. {列名}[>|>=|=|<=|<|<>|><|!=]{値} - 指定列で比較演算
 * 4. {列名}:/{正規表現}/ - 指定列で正規表現検索
 * 5. 上記をand/orで連結、()で優先順位制御可能
 *
 * 例:
 * - "山田" → 全列から"山田"を含む行
 * - "氏名:山田" → 氏名列から"山田"を含む行
 * - "年齢>=20" → 年齢が20以上の行
 * - "氏名:/^山/" → 氏名が"山"で始まる行
 * - "氏名:山田 and 年齢>=20" → 氏名に"山田"を含み、年齢が20以上
 * - "(氏名:山田 or 氏名:田中) and 年齢>=20" → (氏名に"山田"または"田中")かつ年齢が20以上
 */
export const matchesKeyword = (row, columns, keyword) => {
  if (!keyword || typeof keyword !== 'string') return true;
  if (!keyword.trim()) return true;

  // トークン化
  const tokens = tokenizeSearchQuery(keyword);

  // パース
  const ast = parseTokens(tokens);

  // 評価
  return evaluateAST(ast, row, columns);
};



================================================
FILE: builder/src/features/search/searchTable.test.js
================================================
import test from "node:test";
import assert from "node:assert/strict";
import { buildExportTableData } from "./searchTable.js";

const buildRegressionForm = () => ({
  schema: [
    {
      type: "select",
      label: "top",
      options: [{ label: "opt1" }, { label: "opt2" }],
      childrenByValue: {
        opt1: [
          {
            type: "text",
            label: "xxx",
            childrenByValue: {
              a: [{ type: "text", label: "leaf1" }],
              b: [{ type: "text", label: "leaf2" }],
            },
          },
        ],
        opt2: [{ type: "text", label: "xxx" }],
      },
    },
  ],
});

test("空白セルを挟んだ同一ヘッダーは残す", () => {
  const { headerRows } = buildExportTableData({ form: buildRegressionForm(), entries: [] });
  assert.equal(headerRows[2][3], "xxx");
  assert.equal(headerRows[2][4], "");
  assert.equal(headerRows[2][5], "");
  assert.equal(headerRows[2][6], "xxx");
});

test("連続する同一ヘッダーは2つ目以降を空白化する", () => {
  const { headerRows } = buildExportTableData({ form: buildRegressionForm(), entries: [] });
  assert.equal(headerRows[0][2], "top");
  assert.deepEqual(headerRows[0].slice(3), ["", "", "", ""]);
});



================================================
FILE: builder/src/features/search/useEntriesWithCache.js
================================================
import { useCallback, useEffect, useState } from "react";
import { dataStore } from "../../app/state/dataStore.js";
import { saveRecordsToCache, getRecordsFromCache } from "../../app/state/recordsCache.js";
import {
  evaluateCache,
  RECORD_CACHE_BACKGROUND_REFRESH_MS,
  RECORD_CACHE_MAX_AGE_MS,
} from "../../app/state/cachePolicy.js";
import { perfLogger } from "../../utils/perfLogger.js";

const defaultAlert = { showAlert: (message) => console.warn("[useEntriesWithCache]", message) };

const shouldForceSync = (locationState) => {
  if (!locationState || typeof locationState !== "object") return false;
  return locationState.saved === true || locationState.deleted === true || locationState.created === true;
};

export const useEntriesWithCache = ({ formId, form, locationKey, locationState, showAlert = defaultAlert.showAlert }) => {
  const [entries, setEntries] = useState([]);
  const [headerMatrix, setHeaderMatrix] = useState([]);
  const [loading, setLoading] = useState(false);
  const [backgroundLoading, setBackgroundLoading] = useState(false);
  const [useCache, setUseCache] = useState(false);
  const [lastSyncedAt, setLastSyncedAt] = useState(null);
  const [cacheDisabled, setCacheDisabled] = useState(false);

  const fetchAndCacheData = useCallback(async ({ background = false } = {}) => {
    if (!formId) return;
    if (!background) setLoading(true);
    else setBackgroundLoading(true);
    const startedAt = Date.now();
    perfLogger.logVerbose("search", "fetch start", { formId, background, startedAt });

    try {
      const result = await dataStore.listEntries(formId);
      const fetchedEntries = result.entries || result || [];
      setEntries(fetchedEntries);
      setHeaderMatrix(result.headerMatrix || []);
      const syncedAt = result.lastSyncedAt || Date.now();
      setLastSyncedAt(syncedAt);

      try {
        await saveRecordsToCache(formId, fetchedEntries, result.headerMatrix || [], { schemaHash: form?.schemaHash });
        setCacheDisabled(false);
      } catch (cacheErr) {
        console.warn("[SearchPage] Failed to save records cache:", cacheErr);
        setCacheDisabled(true);
      }
      setUseCache(false);
    } catch (error) {
      console.error("[SearchPage] Failed to fetch and cache data:", error);
      showAlert(`データの取得に失敗しました: ${error.message || error}`);
    } finally {
      const finishedAt = Date.now();
      perfLogger.logVerbose("search", "fetch done", { formId, background, durationMs: finishedAt - startedAt });
      if (!background) setLoading(false);
      else setBackgroundLoading(false);
    }
  }, [formId, form, showAlert]);

  useEffect(() => {
    if (!formId) return;

    const loadData = async () => {
      let cache = { entries: [], headerMatrix: [], lastSyncedAt: null };
      try {
        cache = await getRecordsFromCache(formId);
      } catch (error) {
        console.warn("[SearchPage] Failed to load cache:", error);
        setCacheDisabled(true);
      }

      const schemaMismatch = cache.schemaHash && form?.schemaHash && cache.schemaHash !== form.schemaHash;
      const hasCache = (cache.entries || []).length > 0 && !schemaMismatch;
      if (schemaMismatch) {
        perfLogger.logVerbose("search", "cache schema mismatch detected; forcing sync", {
          cacheSchema: cache.schemaHash,
          formSchema: form?.schemaHash,
        });
        try {
          await saveRecordsToCache(formId, [], [], { schemaHash: form?.schemaHash });
        } catch (clearErr) {
          console.warn("[SearchPage] Failed to clear stale cache:", clearErr);
        }
      }

      const forceSync = shouldForceSync(locationState);
      const { age, shouldSync, shouldBackground } = evaluateCache({
        lastSyncedAt: cache.lastSyncedAt,
        hasData: hasCache,
        forceSync,
        maxAgeMs: RECORD_CACHE_MAX_AGE_MS,
        backgroundAgeMs: RECORD_CACHE_BACKGROUND_REFRESH_MS,
      });

      perfLogger.logVerbose("search", "cache decision", {
        formId,
        cacheAge: age,
        hasCache,
        shouldSync,
        shouldBackground,
        cacheDisabled,
      });

      if (hasCache) {
        setEntries(cache.entries);
        setHeaderMatrix(cache.headerMatrix || []);
        setLastSyncedAt(cache.lastSyncedAt || cache.cacheTimestamp || null);
        setUseCache(true);
      }

      if ((shouldSync || cacheDisabled) && !hasCache) {
        await fetchAndCacheData({ background: false });
        return;
      }

      if (shouldSync || shouldBackground) {
        fetchAndCacheData({ background: true }).catch((error) => {
          console.error("[SearchPage] background refresh failed:", error);
          showAlert(`データの取得に失敗しました: ${error.message || error}`);
        });
      }
    };

    loadData();
  }, [formId, locationKey, fetchAndCacheData, locationState, form, showAlert, cacheDisabled]);

  return {
    entries,
    headerMatrix,
    loading,
    backgroundLoading,
    useCache,
    lastSyncedAt,
    cacheDisabled,
    fetchAndCacheData,
  };
};



================================================
FILE: builder/src/features/search/components/SearchPagination.jsx
================================================
import React from "react";
export default function SearchPagination({ page, totalPages, totalEntries, startIndex, endIndex, onChange }) {
  return (
    <div className="search-pagination">
      <span className="search-pagination-info">
        {totalEntries} 件中 {startIndex} - {endIndex} 件
      </span>
      <div className="search-pagination-nav">
        <button type="button" className="search-input" disabled={page <= 1} onClick={() => onChange(page - 1)}>
          前へ
        </button>
        <span className="search-pagination-page">
          {page} / {totalPages}
        </span>
        <button type="button" className="search-input" disabled={page >= totalPages} onClick={() => onChange(page + 1)}>
          次へ
        </button>
      </div>
    </div>
  );
}



================================================
FILE: builder/src/features/search/components/SearchSidebar.jsx
================================================
import React from "react";
export default function SearchSidebar({
  onBack,
  showBack,
  onCreate,
  onConfig,
  onDelete,
  onRefresh,
  onExport,
  useCache,
  loading,
  exporting,
  selectedCount,
  filteredCount,
}) {
  return (
    <>
      {showBack && onBack && (
        <button type="button" className="search-input search-sidebar-btn" onClick={onBack}>
          ← 戻る
        </button>
      )}
      <button type="button" className="search-input search-sidebar-btn" onClick={onCreate}>
        新規入力
      </button>
      <button
        type="button"
        className="search-input search-sidebar-btn search-sidebar-btn-danger"
        onClick={onDelete}
        disabled={selectedCount === 0}
      >
        削除
      </button>
      <button
        type="button"
        className={`search-input search-sidebar-btn${useCache ? " search-sidebar-btn-warning" : ""}`}
        onClick={onRefresh}
        disabled={loading}
        title={useCache ? "キャッシュから表示中 - クリックで最新データを取得" : "最新データを取得"}
      >
        {"🔄 更新"}
      </button>
      <button
        type="button"
        className="search-input search-sidebar-btn"
        onClick={onExport}
        disabled={exporting || filteredCount === 0}
        title={filteredCount === 0 ? "出力するデータがありません" : `検索結果 ${filteredCount} 件を出力`}
      >
        {exporting ? "出力中..." : "検索結果を出力"}
      </button>
      {onConfig && (
        <button type="button" className="search-input search-sidebar-btn" onClick={onConfig}>
          設定
        </button>
      )}
    </>
  );
}



================================================
FILE: builder/src/features/search/components/SearchTable.jsx
================================================
import React from "react";
import { applyDisplayLengthLimit } from "../searchTable.js";

const headerSortLabel = (activeSort, columnKey) => {
  if (activeSort.key !== columnKey) return "";
  return activeSort.order === "desc" ? "↓" : "↑";
};

export default function SearchTable({
  columns,
  headerRows,
  pagedEntries,
  selectedEntries,
  activeSort,
  cellDisplayLimit,
  tableMaxWidth,
  onSortToggle,
  onSelectAll,
  onToggleSelect,
  onRowClick,
}) {
  const selectableColumns = columns.filter((column) => column.key !== "__actions");

  return (
    <div className="search-table-wrap">
      <table className="search-table" style={{ "--table-width": tableMaxWidth ? `${tableMaxWidth}px` : "100%" }}>
        <thead>
          {headerRows.map((headerRow, rowIndex) => (
            <tr key={`header-row-${rowIndex}`}>
              {rowIndex === 0 && (
                <th className="search-th search-td-narrow" rowSpan={headerRows.length}>
                  <input
                    type="checkbox"
                    checked={pagedEntries.length > 0 && selectedEntries.size === pagedEntries.length}
                    onChange={(e) => onSelectAll(e.target.checked)}
                  />
                </th>
              )}
              {headerRow.map((cell, cellIndex) => {
                const fallbackColumn = cell.colSpan === 1 ? selectableColumns[cell.startIndex] || null : null;
                const column = cell.column || fallbackColumn;
                if (column && column.key === "__actions") return null;
                const sortable = Boolean(cell.column && cell.column.sortable !== false);
                const orderLabel = sortable ? headerSortLabel(activeSort, column.key) : "";

                return (
                  <th
                    key={`header-cell-${rowIndex}-${cellIndex}`}
                    className="search-th"
                    data-sortable={sortable ? "true" : "false"}
                    colSpan={cell.colSpan}
                    rowSpan={cell.rowSpan ?? 1}
                    onClick={sortable ? () => onSortToggle(column.key) : undefined}
                  >
                    {cell.label}
                    {sortable && <span className="nf-text-muted nf-ml-4">{orderLabel}</span>}
                  </th>
                );
              })}
            </tr>
          ))}
        </thead>
        <tbody>
          {pagedEntries.map(({ entry, values }) => (
            <tr
              key={entry.id}
              className="search-row"
              onClick={() => {
                // テキストが選択されていたら（ドラッグ操作）遷移しない
                const selection = window.getSelection();
                if (selection && selection.toString().length > 0) {
                  return;
                }
                onRowClick(entry.id);
              }}
            >
              <td className="search-td search-td-narrow" onClick={(e) => e.stopPropagation()}>
                <input
                  type="checkbox"
                  checked={selectedEntries.has(entry.id)}
                  onChange={() => onToggleSelect(entry.id)}
                />
              </td>
              {selectableColumns.map((column) => {
                const rawDisplayText = values[column.key]?.display ?? "";
                const limitedText = applyDisplayLengthLimit(rawDisplayText || "", cellDisplayLimit);
                const isUrl = column.sourceType === "url" && rawDisplayText;
                return (
                  <td key={`${entry.id}_${column.key}`} className="search-td">
                    {isUrl ? (
                      <a
                        href={rawDisplayText}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="nf-link"
                        onClick={(e) => e.stopPropagation()}
                      >
                        {limitedText}
                      </a>
                    ) : (
                      limitedText
                    )}
                  </td>
                );
              })}
            </tr>
          ))}
          {pagedEntries.length === 0 && (
            <tr>
              <td className="search-td nf-text-center" colSpan={selectableColumns.length + 1}>
                データがありません。
              </td>
            </tr>
          )}
        </tbody>
      </table>
    </div>
  );
}



================================================
FILE: builder/src/features/search/components/SearchToolbar.jsx
================================================
import React from "react";

export default function SearchToolbar({ query, onChange, lastSyncedAt, useCache, cacheDisabled }) {
  return (
    <div className="search-bar">
      <input
        type="search"
        placeholder="キーワード検索"
        value={query}
        onChange={(event) => onChange(event.target.value)}
        className="search-input nf-flex-1-0-220"
      />
      <span className="nf-text-subtle nf-text-12">
        最終更新: {lastSyncedAt ? new Date(lastSyncedAt).toLocaleString() : "未取得"} {useCache ? "(キャッシュ)" : cacheDisabled ? "(キャッシュ無効)" : ""}
      </span>
    </div>
  );
}



================================================
FILE: builder/src/features/settings/settingsSchema.js
================================================
export const SETTINGS_GROUPS = [
  {
    key: "spreadsheet",
    label: "入力データ保存スプレッドシート",
    fields: [
      {
        key: "spreadsheetId",
        label: "Spreadsheet ID / URL",
        placeholder: "1AbCdEf... / https://docs.google.com/... / https://drive.google.com/drive/folders/...",
        required: false,
        description: "未設定/フォルダURLの場合はマイドライブ直下または指定フォルダに新規作成されます（保存後にURLが自動入力）",
      },
      {
        key: "sheetName",
        label: "Sheet Name",
        placeholder: "Data",
        required: false,
      },
    ],
  },
  {
    key: "search",
    label: "検索画面設定",
    fields: [
      {
        key: "pageSize",
        label: "1画面あたりの表示件数",
        placeholder: "20",
        required: false,
        type: "number",
      },
      {
        key: "searchTableMaxWidth",
        label: "検索結果テーブルの幅（px）",
        placeholder: "1200",
        required: false,
        type: "number",
        description: "未設定の場合は画面幅に合わせて可変",
      },
      {
        key: "searchCellMaxChars",
        label: "検索結果セルの表示文字数上限",
        placeholder: "50",
        required: false,
        type: "number",
      },
    ],
  },
  {
    key: "access",
    label: "アクセス制御",
    fields: [
      {
        key: "showRecordNo",
        label: "No.を表示する",
        type: "checkbox",
        required: false,
        defaultValue: true,
        description: "OFFにすると、検索画面・レコード画面でNo.列が非表示になります（回答状況の推測を防止）",
      },
      {
        key: "showOwnRecordsOnly",
        label: "自分の回答のみ表示",
        type: "checkbox",
        required: false,
        description: "ONにすると、検索画面で自分が作成したレコードのみ表示されます（管理者は全件表示）",
      },
    ],
  },
];

// 後方互換のためフラット配列もエクスポート
export const SETTINGS_FIELDS = SETTINGS_GROUPS.flatMap((g) => g.fields);



================================================
FILE: builder/src/features/settings/settingsStore.js
================================================
import { useCallback, useEffect, useRef, useState } from "react";
import { DEFAULT_SETTINGS, loadSettingsFromStorage, saveSettingsToStorage } from "../../core/storage.js";
import { DEFAULT_THEME, applyThemeWithFallback } from "../../app/theme/theme.js";

export const useBuilderSettings = (options = {}) => {
  const applyGlobalTheme = options.applyGlobalTheme !== false;
  const [settings, setSettings] = useState({ ...DEFAULT_SETTINGS });
  const [loadingLocal, setLoadingLocal] = useState(true);
  const defaultsRef = useRef({ ...DEFAULT_SETTINGS });

  useEffect(() => {
    let active = true;
    (async () => {
      const loaded = await loadSettingsFromStorage();
      if (!active) return;
      setSettings((prev) => {
        const merged = { ...DEFAULT_SETTINGS, ...loaded, ...prev };
        if (loaded?.theme && prev?.theme === DEFAULT_SETTINGS.theme) {
          merged.theme = loaded.theme;
        }
        defaultsRef.current = merged;
        return merged;
      });
      setLoadingLocal(false);
    })();
    return () => {
      active = false;
    };
  }, []);

  useEffect(() => {
    if (loadingLocal) return;
    (async () => {
      await saveSettingsToStorage(settings);
    })();
  }, [settings, loadingLocal]);

  useEffect(() => {
    if (loadingLocal) return;
    defaultsRef.current = { ...DEFAULT_SETTINGS, ...settings };
  }, [settings, loadingLocal, defaultsRef]);

  useEffect(() => {
    if (loadingLocal) return;
    if (!applyGlobalTheme) return;
    void applyThemeWithFallback(settings?.theme || DEFAULT_THEME, { persist: true });
  }, [settings?.theme, loadingLocal, applyGlobalTheme]);

  const updateSetting = useCallback(
    (key, value) => {
      setSettings((prev) => (prev?.[key] === value ? prev : { ...prev, [key]: value }));
    },
    [setSettings],
  );

  const replaceSettings = useCallback(
    (next = {}) => {
      let merged = { ...DEFAULT_SETTINGS, ...defaultsRef.current, ...next };
      setSettings((prev) => {
        const prevObj = prev || {};
        const keys = new Set([...Object.keys(prevObj), ...Object.keys(merged)]);
        for (const key of keys) {
          if (prevObj[key] !== merged[key]) {
            return merged;
          }
        }
        merged = prevObj;
        return prev;
      });
      return merged;
    },
    [defaultsRef, setSettings],
  );

  return { settings, updateSetting, replaceSettings };
};



================================================
FILE: builder/src/pages/AdminDashboardPage.jsx
================================================
import React, { useCallback, useEffect, useMemo, useState } from "react";
import { useNavigate } from "react-router-dom";
import JSZip from "jszip";
import { saveAs } from "file-saver";
import AppLayout from "../app/components/AppLayout.jsx";
import ConfirmDialog from "../app/components/ConfirmDialog.jsx";
import { useAppData } from "../app/state/AppDataProvider.jsx";
import { dataStore } from "../app/state/dataStore.js";
import { useAlert } from "../app/hooks/useAlert.js";
import { DEFAULT_THEME, applyThemeWithFallback } from "../app/theme/theme.js";
import { useBuilderSettings } from "../features/settings/settingsStore.js";
import { importFormsFromDrive, hasScriptRun } from "../services/gasClient.js";
import { formatUnixMsDateTime, toUnixMs } from "../utils/dateTime.js";

const formatDisplayFieldsSummary = (form) => {
  if (!form) return "";
  const settings = Array.isArray(form.displayFieldSettings) && form.displayFieldSettings.length
    ? form.displayFieldSettings
    : (Array.isArray(form.importantFields) ? form.importantFields.map((path) => ({ path })) : []);
  if (!settings.length) return "";
  return settings
    .filter((item) => item?.path)
    .map((item) => item.path)
    .join(", ");
};

const formatDate = (value) => {
  const ms = Number.isFinite(value) ? value : toUnixMs(value);
  if (!Number.isFinite(ms)) return "---";
  return formatUnixMsDateTime(ms);
};

const buildImportDetail = (skipped = 0, parseFailed = 0, { useRegisteredLabel = false } = {}) => {
  const parts = [];
  if (skipped > 0) {
    const label = useRegisteredLabel ? "登録済みスキップ" : "スキップ";
    parts.push(`${label} ${skipped} 件`);
  }
  if (parseFailed > 0) parts.push(`読込失敗 ${parseFailed} 件`);
  return parts.length > 0 ? `（${parts.join("、")}）` : "";
};

export default function AdminDashboardPage() {
  const { forms, loadFailures, loadingForms, archiveForm, unarchiveForm, archiveForms, unarchiveForms, deleteForms, refreshForms, exportForms, registerImportedForm } = useAppData();
  const { settings } = useBuilderSettings();
  const navigate = useNavigate();
  const { showAlert } = useAlert();
const [selected, setSelected] = useState(() => new Set());
  const [confirmArchive, setConfirmArchive] = useState({ open: false, formId: null, targetIds: [], multiple: false, allArchived: false, hasPublished: false });
  const [confirmDelete, setConfirmDelete] = useState({ open: false, formId: null, targetIds: [], multiple: false });
  const [importDialogOpen, setImportDialogOpen] = useState(false);
  const [importUrl, setImportUrl] = useState("");
  const [importing, setImporting] = useState(false);
  const [copiedId, setCopiedId] = useState(null);

  
  const sortedForms = useMemo(() => {
    const list = forms.slice();
    list.sort(
      (a, b) => (Number.isFinite(b.modifiedAtUnixMs) ? b.modifiedAtUnixMs : toUnixMs(b.modifiedAt)) -
        (Number.isFinite(a.modifiedAtUnixMs) ? a.modifiedAtUnixMs : toUnixMs(a.modifiedAt))
    );
    return list;
  }, [forms]);

  const loadFailureRows = useMemo(() => {
    const rows = (loadFailures || []).map((item) => ({
      id: item.id,
      archived: true,
      settings: {},
      description: "",
      modifiedAt: item.lastTriedAt,
      loadError: item,
    }));
    rows.sort(
      (a, b) => (Number.isFinite(b.modifiedAtUnixMs) ? b.modifiedAtUnixMs : toUnixMs(b.modifiedAt || 0)) -
        (Number.isFinite(a.modifiedAtUnixMs) ? a.modifiedAtUnixMs : toUnixMs(a.modifiedAt || 0))
    );
    return rows;
  }, [loadFailures]);

  const adminForms = useMemo(() => [...sortedForms, ...loadFailureRows], [sortedForms, loadFailureRows]);

  const toggleSelect = (formId) => {
    setSelected((prev) => {
      const next = new Set(prev);
      if (next.has(formId)) next.delete(formId);
      else next.add(formId);
      return next;
    });
  };

  const selectAll = (checked) => {
    if (checked) setSelected(new Set(adminForms.map((form) => form.id)));
    else setSelected(new Set());
  };

  const clearSelectionByIds = useCallback((ids = []) => {
    if (!Array.isArray(ids) || ids.length === 0) return;
    setSelected((prev) => {
      const next = new Set(prev);
      ids.forEach((id) => next.delete(id));
      return next;
    });
  }, []);

  const handleArchiveSelected = () => {
    const selectedForms = sortedForms.filter((form) => selected.has(form.id));
    if (!selectedForms.length) {
      showAlert("アーカイブ可能なフォームを選択してください。（読み込みエラーの項目は削除のみ可能です）");
      return;
    }

    const allArchived = selectedForms.every((form) => form.archived);
    const hasPublished = selectedForms.some((form) => !form.archived);

    const targetIds = selectedForms.map((form) => form.id);
    const firstId = targetIds[0];
    setConfirmArchive({
      open: true,
      formId: firstId,
      targetIds,
      multiple: targetIds.length > 1,
      allArchived,
      hasPublished,
    });
  };

  const handleDeleteSelected = () => {
    if (!selected.size) {
      showAlert("削除するフォームを選択してください。");
      return;
    }
    const targetIds = Array.from(selected);
    const firstId = targetIds[0];
    setConfirmDelete({ open: true, formId: firstId, multiple: targetIds.length > 1, targetIds });
  };

  const handleExport = async () => {
    if (!selected.size) {
      showAlert("スキーマをエクスポートするフォームを選択してください。");
      return;
    }
    const targets = await exportForms(Array.from(selected));
    if (!targets.length) {
      showAlert("エクスポート可能なデータがありません");
      return;
    }

    if (targets.length === 1) {
      // 1個の場合は.jsonファイルとして保存
      const form = targets[0];
      const filename = `${form.settings?.formTitle || form.id}.json`;
      const { id, ...formWithoutId } = form;
      const blob = new Blob([JSON.stringify(formWithoutId, null, 2)], { type: "application/json" });
      saveAs(blob, filename);
    } else {
      // 複数の場合はZIPファイルとして保存
      const zip = new JSZip();
      targets.forEach((form) => {
        const filename = `${form.settings?.formTitle || form.id}.json`;
        const { id, ...formWithoutId } = form;
        zip.file(filename, JSON.stringify(formWithoutId, null, 2));
      });
      const blob = await zip.generateAsync({ type: "blob" });
      saveAs(blob, `forms_${new Date().toISOString().replace(/[:.-]/g, "")}.zip`);
    }
  };

  const handleImport = () => {
    if (importing) return;
    if (!hasScriptRun()) {
      showAlert("インポート機能はGoogle Apps Script環境でのみ利用可能です");
      return;
    }
    setImportUrl("");
    setImportDialogOpen(true);
  };
  const sanitizeImportedForm = (raw) => {
    if (!raw || typeof raw !== "object") return null;
    const schema = Array.isArray(raw.schema) ? raw.schema : [];
    const settings = raw && typeof raw.settings === "object" && !Array.isArray(raw.settings) ? raw.settings : {};

    // 旧形式のnameフィールドがある場合、settings.formTitleに移行
    if (!settings.formTitle && typeof raw.name === "string") {
      settings.formTitle = raw.name;
    }

    return {
      id: raw.id, // IDを保持（重要）
      description: typeof raw.description === "string" ? raw.description : "",
      schema,
      settings,
      archived: !!raw.archived,
      schemaVersion: Number.isFinite(raw.schemaVersion) ? raw.schemaVersion : 1,
      createdAt: raw.createdAt, // 作成日時を保持
      modifiedAt: raw.modifiedAt, // 更新日時を保持
      createdAtUnixMs: Number.isFinite(raw.createdAtUnixMs) ? raw.createdAtUnixMs : toUnixMs(raw.createdAt),
      modifiedAtUnixMs: Number.isFinite(raw.modifiedAtUnixMs) ? raw.modifiedAtUnixMs : toUnixMs(raw.modifiedAt),
    };
  };

  const flattenImportedContents = (contents) => {
    const list = [];
    let invalidPayloadCount = 0;
    (Array.isArray(contents) ? contents : []).forEach((item) => {
      // GASから返ってくる新形式: { form, fileId, fileUrl }
      if (item && item.form && item.fileId) {
        const sanitized = sanitizeImportedForm(item.form);
        if (sanitized) {
          list.push({ form: sanitized, fileId: item.fileId, fileUrl: item.fileUrl || null });
        } else {
          invalidPayloadCount += 1;
        }
      } else {
        invalidPayloadCount += 1;
      }
    });
    return { list, invalidPayloadCount };
  };

  const startImportWorkflow = useCallback(
    async (parsedContents, { skipped = 0, parseFailed = 0 } = {}) => {
      const { list: queue, invalidPayloadCount } = flattenImportedContents(parsedContents);
      const detail = buildImportDetail(skipped, parseFailed, { useRegisteredLabel: true });
      if (!queue.length) {
        showAlert(`取り込めるフォームはありませんでした${detail}。`);
        return;
      }

      setImporting(true);
      let imported = 0;
      let saveFailed = invalidPayloadCount;

      try {
        for (const item of queue) {
          try {
            // fileIdがある場合はコピーなしで登録（元ファイルをそのまま管理）
            await registerImportedForm({
              form: item.form,
              fileId: item.fileId,
              fileUrl: item.fileUrl,
            });
            imported += 1;
          } catch (error) {
            saveFailed += 1;
            console.warn("[DriveImport] failed to import one form", {
              formId: item?.form?.id,
              title: item?.form?.settings?.formTitle,
              error: error?.message || error,
            });
          }
        }

        setSelected(new Set());
        const saveFailedDetail = saveFailed > 0 ? `（保存失敗 ${saveFailed} 件）` : "";

        // 結果メッセージ
        if (imported > 0) {
          showAlert(`${imported} 件のフォームを取り込みました${detail}${saveFailedDetail}。`);
        } else {
          showAlert(`取り込めるフォームはありませんでした${detail}${saveFailedDetail}。`);
        }
        console.log(
          `[DriveImport] success=${imported}, alreadyRegistered=${skipped}, parseFailed=${parseFailed}, saveFailed=${saveFailed}`,
        );
      } catch (error) {
        console.error("[DriveImport] import workflow failed", error);
        showAlert(error?.message || "スキーマの取り込み中にエラーが発生しました");
      } finally {
        setImporting(false);
      }
    },
    [registerImportedForm, showAlert],
  );

  const handleImportFromDrive = async () => {
    const url = importUrl?.trim();
    if (!url) {
      showAlert("Google Drive URLを入力してください");
      return;
    }

    setImportDialogOpen(false);
    setImporting(true);

    try {
      // Google DriveからフォームデータをAPI経由で取得
      const result = await importFormsFromDrive(url);
      const { forms: importedForms, skipped = 0, parseFailed = 0 } = result;
      const detail = buildImportDetail(skipped, parseFailed);

      if (!importedForms || importedForms.length === 0) {
        showAlert(`有効なフォームがありませんでした${detail}。`);
        setImporting(false);
        return;
      }

      // インポートワークフローを実行
      await startImportWorkflow(importedForms, { skipped, parseFailed });
    } catch (error) {
      console.error("[DriveImport] import from Drive failed", error);
      showAlert(error?.message || "Google Driveからのインポートに失敗しました");
      setImporting(false);
    }
  };

  const confirmArchiveAction = () => {
    const targetIds = (confirmArchive.targetIds && confirmArchive.targetIds.length
      ? confirmArchive.targetIds
      : confirmArchive.formId
        ? [confirmArchive.formId]
        : []);
    if (!targetIds.length) return;

    // アーカイブ状態を保持
    const shouldUnarchive = confirmArchive.allArchived;

    // ダイアログを即座に閉じて選択をクリア
    clearSelectionByIds(targetIds);
    setConfirmArchive({ open: false, formId: null, targetIds: [], multiple: false, allArchived: false, hasPublished: false });

    // バックグラウンドで一括処理を実行
    (async () => {
      try {
        if (shouldUnarchive) {
          await unarchiveForms(targetIds);
        } else {
          await archiveForms(targetIds);
        }
      } catch (error) {
        console.error("[AdminDashboard] Archive action failed:", error);
        showAlert(`アーカイブ処理中にエラーが発生しました: ${error.message}`);
      }
    })();
  };

  const confirmDeleteAction = async () => {
    const targetIds = (confirmDelete.targetIds && confirmDelete.targetIds.length
      ? confirmDelete.targetIds
      : confirmDelete.formId
        ? [confirmDelete.formId]
        : []);
    if (!targetIds.length) return;

    try {
      await deleteForms(targetIds);
      clearSelectionByIds(targetIds);
      setConfirmDelete({ open: false, formId: null, targetIds: [], multiple: false });
    } catch (error) {
      console.error("[AdminDashboard] Delete action failed:", error);
      showAlert(error?.message || "フォームの削除中にエラーが発生しました");
    }
  };

  const goToEditor = (formId) => {
    navigate(`/forms/${formId}/edit`);
  };

  const handleCopyId = useCallback((formId, event) => {
    event.stopPropagation();
    const baseUrl = window.__GAS_WEBAPP_URL__ || window.location.origin;
    const fullUrl = `${baseUrl}?form=${formId}`;
    navigator.clipboard.writeText(fullUrl).then(() => {
      setCopiedId(formId);
      setTimeout(() => setCopiedId(null), 2000);
    }).catch((error) => {
      console.error("Failed to copy:", error);
      showAlert("URLのコピーに失敗しました");
    });
  }, [showAlert]);

  const handleCreateNew = () => {
    navigate("/forms/new");
  };

  return (
    <AppLayout
      title="フォーム管理"
      badge="フォーム一覧"
      fallbackPath="/"
      actions={null}
      sidebarActions={
        <>
          <button type="button" className="nf-btn-outline nf-btn-sidebar nf-text-13" onClick={handleCreateNew}>
            新規作成
          </button>
          <button type="button" className="nf-btn-outline nf-btn-sidebar nf-text-13" onClick={handleImport}>
            {importing ? "インポート中..." : "インポート"}
          </button>
          <button type="button" className="nf-btn-outline nf-btn-sidebar nf-text-13" onClick={handleExport} disabled={selected.size === 0}>
            エクスポート
          </button>
          <button
            type="button"
            className="nf-btn-outline nf-btn-sidebar nf-text-13"
            onClick={handleArchiveSelected}
            disabled={selected.size === 0}
          >
            アーカイブ
          </button>
          <button
            type="button"
            className="nf-btn-outline nf-btn-sidebar nf-text-13 admin-danger-btn"
            onClick={handleDeleteSelected}
            disabled={selected.size === 0}
          >
            削除
          </button>
          <button
            type="button"
            className={`nf-btn-outline nf-btn-sidebar nf-text-13${!loadingForms ? " admin-refresh-btn" : ""}`}
            onClick={() => refreshForms("manual:admin-dashboard")}
            disabled={loadingForms}
          >
            {loadingForms ? "🔄 更新中..." : "🔄 更新"}
          </button>
        </>
      }
    >
      {loadingForms ? (
        <p className="nf-text-subtle">読み込み中...</p>
      ) : (
        <div className="search-table-wrap">
          <table className="search-table">
            <thead>
              <tr>
                <th className="search-th">
                  <input type="checkbox" checked={adminForms.length > 0 && selected.size === adminForms.length} onChange={(event) => selectAll(event.target.checked)} />
                </th>
                <th className="search-th">名称</th>
                <th className="search-th">フォームID</th>
                <th className="search-th">更新日時</th>
                <th className="search-th">表示項目</th>
                <th className="search-th">状態</th>
              </tr>
            </thead>
            <tbody>
              {adminForms.map((form) => {
                const isLoadError = !!form.loadError;
                const summary = isLoadError ? "" : formatDisplayFieldsSummary(form);
                const loadError = form.loadError || null;
                const lastUpdated = isLoadError ? formatDate(loadError?.lastTriedAt) : formatDate(form.modifiedAt);
                return (
                  <tr
                    key={form.id}
                    className="admin-row"
                    data-clickable={isLoadError ? "false" : "true"}
                    data-error={isLoadError ? "true" : "false"}
                    onClick={() => {
                      if (!isLoadError) {
                        goToEditor(form.id);
                      }
                    }}
                  >
                    <td className="search-td" onClick={(e) => e.stopPropagation()}>
                      <input type="checkbox" checked={selected.has(form.id)} onChange={() => toggleSelect(form.id)} />
                      {isLoadError && <div className="nf-text-danger-ink nf-text-11 nf-mt-4">削除のみ可能</div>}
                    </td>
                    <td className="search-td">
                      {isLoadError ? (
                        <>
                          <div className="nf-fw-600 nf-text-danger-ink">{loadError?.fileName || "(名称不明)"}</div>
                          <div className="nf-text-danger-ink-strong nf-text-12">フォームID: {form.id}</div>
                          {loadError?.fileId && <div className="nf-text-danger-ink-strong nf-text-12">ファイルID: {loadError.fileId}</div>}
                          {loadError?.driveFileUrl && (
                            <div className="nf-mt-6">
                              <a
                                href={loadError.driveFileUrl}
                                target="_blank"
                                rel="noreferrer"
                                onClick={(event) => event.stopPropagation()}
                                className="admin-link"
                              >
                                Driveで確認
                              </a>
                            </div>
                          )}
                        </>
                      ) : (
                        <>
                          <div className="nf-fw-600">{form.settings?.formTitle || "(無題)"}</div>
                          {form.description && <div className="nf-text-muted nf-text-12">{form.description}</div>}
                        </>
                      )}
                    </td>
                    <td className="search-td" onClick={(e) => e.stopPropagation()}>
                      <div className="nf-row nf-gap-6">
                        <span className="admin-form-id">{form.id}</span>
                        <button
                          type="button"
                          className="admin-copy-btn"
                          onClick={(e) => handleCopyId(form.id, e)}
                          title="URLをコピー"
                        >
                          {copiedId === form.id ? "✓" : "📋"}
                        </button>
                      </div>
                    </td>
                    <td className="search-td">{lastUpdated}</td>
                    <td className="search-td">
                      {isLoadError ? (
                        <>
                          <div className="nf-text-danger-ink nf-fw-600">読み込みエラー</div>
                          <div className="nf-text-danger-ink-strong nf-text-12">{loadError?.errorMessage || "読み込みに失敗しました"}</div>
                          {loadError?.errorStage && <div className="nf-text-danger-ink-strong nf-text-11 nf-mt-4">ステージ: {loadError.errorStage}</div>}
                        </>
                      ) : summary ? (
                        summary
                      ) : (
                        <span className="nf-text-subtle nf-text-12">設定なし</span>
                      )}
                    </td>
                    <td className="search-td">
                      {isLoadError ? (
                        <span className="nf-text-danger-strong nf-fw-600">読み込みエラー</span>
                      ) : form.archived ? (
                        <span className="nf-text-danger-strong">アーカイブ済み</span>
                      ) : (
                        <span className="nf-text-success">公開中</span>
                      )}
                    </td>
                  </tr>
                );
              })}
              {adminForms.length === 0 && (
                <tr>
                  <td className="search-td nf-text-center" colSpan={6}>
                    フォームが登録されていません。
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      )}

      <ConfirmDialog
        open={confirmArchive.open}
        title={confirmArchive.allArchived ? "アーカイブを解除" : "フォームをアーカイブ"}
        message={
          confirmArchive.allArchived
            ? "このフォームのアーカイブを解除して公開中に戻します。よろしいですか？"
            : "このフォームをアーカイブします。検索画面には表示されなくなります。よろしいですか？"
        }
        options={[
          {
            label: "キャンセル",
            value: "cancel",
            onSelect: () => setConfirmArchive({ open: false, formId: null, targetIds: [], multiple: false, allArchived: false, hasPublished: false }),
          },
          {
            label: confirmArchive.allArchived ? "解除" : "アーカイブ",
            value: "archive",
            variant: "primary",
            onSelect: confirmArchiveAction,
          },
        ]}
      />

      <ConfirmDialog
        open={confirmDelete.open}
        title="フォームを削除"
        message={
          confirmDelete.multiple
            ? "選択したフォームをまとめて削除します。元に戻すことはできません。よろしいですか？"
            : "このフォームを削除します。元に戻すことはできません。よろしいですか？"
        }
        options={[
          {
            label: "キャンセル",
            value: "cancel",
            onSelect: () => setConfirmDelete({ open: false, formId: null, targetIds: [], multiple: false }),
          },
          {
            label: "削除",
            value: "delete",
            variant: "danger",
            onSelect: confirmDeleteAction,
          },
        ]}
      />

      <ImportUrlDialog
        open={importDialogOpen}
        url={importUrl}
        onUrlChange={setImportUrl}
        onImport={handleImportFromDrive}
        onCancel={() => setImportDialogOpen(false)}
      />

</AppLayout>
  );
}

function ImportUrlDialog({ open, url, onUrlChange, onImport, onCancel }) {
  const [error, setError] = useState("");

  useEffect(() => {
    if (!open) {
      setError("");
    }
  }, [open]);

  if (!open) return null;

  const handleImport = () => {
    const trimmed = (url || "").trim();
    if (!trimmed) {
      setError("Google Drive URLを入力してください");
      return;
    }
    setError("");
    onImport();
  };

  return (
    <div className="admin-import-overlay">
      <div className="admin-import-panel">
        <h3 className="nf-text-18 nf-fw-700 nf-mb-8">Google Driveからインポート</h3>
        <p className="nf-mb-16 nf-text-muted nf-text-14">
          ファイルURLまたはフォルダURLを入力してください。
        </p>

        <div className="nf-mb-16">
          <label className="nf-block nf-mb-6 nf-text-13 nf-fw-600">
            Google Drive URL
          </label>
          <input
            type="text"
            value={url}
            onChange={(event) => {
              onUrlChange(event.target.value);
              if (error) setError("");
            }}
            className="nf-input admin-import-input"
            placeholder="https://drive.google.com/file/d/... または https://drive.google.com/drive/folders/..."
          />
          {error && <p className="nf-mt-6 nf-text-danger-strong nf-text-12">{error}</p>}
          <p className="nf-mt-6 nf-text-muted nf-text-11">
            ・ファイルURL: そのフォームのみをインポート<br />
            ・フォルダURL: フォルダ内の全ての.jsonファイルをインポート<br />
            ・既にプロパティサービスに存在するフォームIDは自動的にスキップされます
          </p>
        </div>

        <div className="nf-row nf-gap-12 nf-mt-24 nf-justify-end">
          <button type="button" className="nf-btn-outline admin-import-btn" onClick={onCancel}>
            キャンセル
          </button>
          <button
            type="button"
            className="admin-import-btn admin-import-btn-primary"
            onClick={handleImport}
          >
            インポート
          </button>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: builder/src/pages/AdminFormEditorPage.jsx
================================================
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useLocation, useNavigate, useParams } from "react-router-dom";
import AppLayout from "../app/components/AppLayout.jsx";
import ConfirmDialog from "../app/components/ConfirmDialog.jsx";
import FormBuilderWorkspace from "../features/admin/FormBuilderWorkspace.jsx";
import { SETTINGS_GROUPS } from "../features/settings/settingsSchema.js";
import { useAppData } from "../app/state/AppDataProvider.jsx";
import { useAlert } from "../app/hooks/useAlert.js";
import { useBeforeUnloadGuard } from "../app/hooks/useBeforeUnloadGuard.js";
import { normalizeSpreadsheetId } from "../utils/spreadsheet.js";
import { validateSpreadsheet } from "../services/gasClient.js";
import { omitThemeSetting } from "../utils/settings.js";
import { DEFAULT_THEME, applyThemeWithFallback } from "../app/theme/theme.js";
import { useBuilderSettings } from "../features/settings/settingsStore.js";

const fallbackPath = (locationState) => (locationState?.from ? locationState.from : "/forms");

export default function AdminFormEditorPage() {
  const { formId } = useParams();
  const isEdit = Boolean(formId);
  const { forms, getFormById, createForm, updateForm } = useAppData();
  const form = isEdit ? getFormById(formId) : null;
  const navigate = useNavigate();
  const location = useLocation();
  const { showAlert } = useAlert();
  const fallback = useMemo(() => fallbackPath(location.state), [location.state]);
  const builderRef = useRef(null);
  const initialMetaRef = useRef({ name: form?.name || "新規フォーム", description: form?.description || "" });
  const initialSchema = useMemo(() => (form?.schema ? form.schema : []), [form]);
  const initialSettings = useMemo(() => omitThemeSetting(form?.settings || {}), [form]);

  const { settings } = useBuilderSettings();

  
  const [name, setName] = useState(initialMetaRef.current.name);
  const [description, setDescription] = useState(initialMetaRef.current.description);
  const [driveUrl, setDriveUrl] = useState(form?.driveFileUrl || "");
  const [localSettings, setLocalSettings] = useState(initialSettings);
  const [builderDirty, setBuilderDirty] = useState(false);
  const [confirmState, setConfirmState] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [nameError, setNameError] = useState("");
  const [questionControl, setQuestionControl] = useState(null);

  // QuestionControlの更新を監視
  useEffect(() => {
    const interval = setInterval(() => {
      if (builderRef.current) {
        const control = builderRef.current.getQuestionControl?.();
        if (control !== questionControl) {
          setQuestionControl(control);
        }
      }
    }, 100);
    return () => clearInterval(interval);
  }, [questionControl]);

  useEffect(() => {
    if (!form) return;
    const formTitle = form.settings?.formTitle || "";
    initialMetaRef.current = { name: formTitle, description: form.description || "" };
    setName(formTitle);
    setDescription(form.description || "");
    setDriveUrl(form.driveFileUrl || "");
    setLocalSettings(omitThemeSetting(form.settings || {}));
    setNameError("");
  }, [form]);

  const metaDirty = useMemo(() => name !== initialMetaRef.current.name || description !== initialMetaRef.current.description, [name, description]);
  const isDirty = builderDirty || metaDirty;

  useBeforeUnloadGuard(isDirty);

  const navigateBack = () => {
    if (location.state?.from) {
      navigate(location.state.from, { replace: true });
      return;
    }
    navigate(fallback, { replace: true });
  };

  const handleSettingsChange = useCallback((key, value) => {
    setLocalSettings((prev) => ({ ...prev, [key]: value }));
    builderRef.current?.updateSetting?.(key, value);
  }, []);

  const checkSpreadsheet = useCallback(async (spreadsheetIdOrUrl) => {
    const trimmed = (spreadsheetIdOrUrl || "").trim();
    if (!trimmed) {
      // 未設定の場合はマイドライブに新規作成されるのでOK
      return true;
    }
    try {
      const result = await validateSpreadsheet(trimmed);
      if (!result?.canView) {
        showAlert("閲覧権限がありません。アクセス権を確認してください");
        return false;
      }
      if (!result.canEdit) {
        showAlert("閲覧権限のみで続行します。保存に失敗する場合は編集権限を付与してください。");
      }
      return true;
    } catch (error) {
      console.error("[AdminFormEditorPage] validateSpreadsheet failed", error);
      showAlert(error?.message || "スプレッドシートを確認できません");
      return false;
    }
  }, [showAlert]);

  const handleSave = async () => {
    if (!builderRef.current) return;
    if (isSaving) return;
    setIsSaving(true);

    const trimmedName = (name || "").trim();
    if (!trimmedName) {
      setNameError("フォーム名を入力してください");
      setIsSaving(false);
      return;
    }
    setNameError("");

    const settingsForCheck = builderRef.current.getSettings?.() || {};
    const spreadsheetOk = await checkSpreadsheet(settingsForCheck.spreadsheetId || "");
    if (!spreadsheetOk) {
      setIsSaving(false);
      return;
    }

    // バリデーション実行（失敗時はfalseを返す）
    const saveResult = builderRef.current.save();
    if (saveResult === false) {
      setIsSaving(false);
      return;
    }

    const schema = builderRef.current.getSchema();
    const settings = builderRef.current.getSettings();
    const trimmedSettings = omitThemeSetting(settings);
    const preservedTheme = form?.settings?.theme || DEFAULT_THEME;

    const payload = {
      // Include existing form data for fallback when getForm fails
      ...(isEdit && form ? { id: form.id, createdAt: form.createdAt, driveFileUrl: form.driveFileUrl } : {}),
      description,
      schema,
      settings: { ...trimmedSettings, theme: preservedTheme, formTitle: trimmedName },
      archived: form?.archived ?? false,
      schemaVersion: form?.schemaVersion ?? 1,
    };

    const targetUrl = driveUrl?.trim() || null;
    const isFileUrl = targetUrl ? /\/file\/d\/[a-zA-Z0-9_-]+/.test(targetUrl) : false;
    const isFolderUrl = targetUrl ? /\/folders\/[a-zA-Z0-9_-]+/.test(targetUrl) : false;
    let saveMode = "auto";

    if (!targetUrl) {
      saveMode = isEdit ? "auto" : "copy_to_root";
    } else if (isFileUrl) {
      saveMode = "overwrite_existing";
    } else if (isFolderUrl) {
      saveMode = "copy_to_folder";
    }

    // ファイルURLのバリデーション
    if (targetUrl) {
      if (!isEdit && isFileUrl) {
        showAlert("新規作成時はファイルURLは指定できません。フォルダURLまたは空白にしてください。");
        setIsSaving(false);
        return;
      }
      if (isEdit && isFileUrl) {
        const originalFileUrl = form?.driveFileUrl || "";
        if (targetUrl !== originalFileUrl) {
          showAlert("既存フォームの保存先には、元のファイルURL以外のファイルURLは指定できません。フォルダURLまたは空白にしてください。");
          setIsSaving(false);
          return;
        }
      }
    }

    try {
      if (isEdit) await updateForm(formId, payload, targetUrl, saveMode);
      else await createForm(payload, targetUrl, saveMode);
      initialMetaRef.current = { name: trimmedName, description: payload.description || "" };
      setBuilderDirty(false);
      setIsSaving(false);
      navigate("/forms", { replace: true });
    } catch (error) {
      console.error(error);
      setIsSaving(false);
      showAlert(`保存に失敗しました: ${error?.message || error}`);
    }
  };

  const handleBack = () => {
    if (!isDirty) {
      navigateBack();
      return false;
    }
    setConfirmState(true);
    return false;
  };

  const handleCancel = () => {
    if (!isDirty) {
      navigateBack();
    } else {
      setConfirmState(true);
    }
  };

  const handleOpenSpreadsheet = () => {
    if (!builderRef.current) return;
    const settings = builderRef.current.getSettings();
    const spreadsheetIdOrUrl = settings?.spreadsheetId || "";

    if (!spreadsheetIdOrUrl) {
      showAlert("スプレッドシートIDが設定されていません");
      return;
    }

    // URLまたはIDからスプレッドシートIDを抽出
    const spreadsheetId = normalizeSpreadsheetId(spreadsheetIdOrUrl);

    // スプレッドシートを新しいタブで開く
    const url = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/edit`;
    window.open(url, "_blank", "noopener,noreferrer");
  };

  const confirmOptions = [
    {
      label: "保存して続行",
      value: "save",
      variant: "primary",
      onSelect: async () => {
        setConfirmState(false);
        await handleSave();
      },
    },
    {
      label: "保存せずに戻る",
      value: "discard",
      onSelect: () => {
        setConfirmState(false);
        navigateBack();
      },
    },
    {
      label: "キャンセル",
      value: "cancel",
      onSelect: () => setConfirmState(false),
    },
  ];

  return (
    <AppLayout
      title={isEdit ? "フォーム修正" : "フォーム新規作成"}
      badge="フォーム管理"
      fallbackPath={fallback}
      onBack={handleBack}
      backHidden={true}
      sidebarActions={
        <>
          <button type="button" className="nf-btn-outline nf-btn-sidebar nf-text-14" disabled={isSaving} onClick={handleSave}>
            保存
          </button>
          <button type="button" className="nf-btn-outline nf-btn-sidebar nf-text-14" onClick={handleCancel}>
            キャンセル
          </button>
          <div className="nf-spacer-16" />
          <button
            type="button"
            className="nf-btn-outline nf-btn-sidebar nf-text-14 admin-move-btn"
            disabled={!questionControl?.canMoveUp}
            onClick={() => questionControl?.moveUp?.()}
          >
            ↑ 上へ
          </button>
          <button
            type="button"
            className="nf-btn-outline nf-btn-sidebar nf-text-14 admin-move-btn"
            disabled={!questionControl?.canMoveDown}
            onClick={() => questionControl?.moveDown?.()}
          >
            ↓ 下へ
          </button>
          {questionControl?.selectedIndex !== null && (
            <div className="nf-text-11 nf-text-muted nf-pad-4-8 nf-text-center nf-word-break">
              {questionControl?.isOption
                ? `${questionControl?.questionLabel || `質問 ${(questionControl?.selectedIndex ?? 0) + 1}`} > ${questionControl?.optionLabel || `選択肢 ${(questionControl?.optionIndex ?? 0) + 1}`}`
                : questionControl?.questionLabel || `質問 ${(questionControl?.selectedIndex ?? 0) + 1}`
              }
            </div>
          )}
          <div className="nf-flex-1" />
          <button
            type="button"
            className="nf-btn-outline nf-btn-sidebar nf-text-14 admin-info-btn"
            onClick={handleOpenSpreadsheet}
          >
            📊 スプレッドシートを開く
          </button>
        </>
      }
    >
      <div className="nf-card nf-mb-24">
        <div className="nf-card nf-mb-16">
          <h3 className="nf-settings-group-title nf-mb-16">フォームの基本情報</h3>

          <div className="nf-col nf-gap-6 nf-mb-16">
            <label className="nf-block nf-fw-600 nf-mb-6">フォーム名</label>
            <input
              value={name}
              onChange={(event) => {
                setName(event.target.value);
                if (nameError) setNameError("");
              }}
              className="nf-input admin-input"
              placeholder="フォーム名"
            />
            {nameError && <p className="nf-text-danger-strong nf-text-12 nf-m-0">{nameError}</p>}
          </div>

          <div className="nf-col nf-gap-6 nf-mb-16">
            <label className="nf-block nf-fw-600 nf-mb-6">フォームの説明</label>
            <textarea value={description} onChange={(event) => setDescription(event.target.value)} className="nf-input admin-input nf-min-h-80" placeholder="説明" />
          </div>

          <div className="nf-col nf-gap-6">
            <label className="nf-block nf-fw-600 nf-mb-6">フォーム項目データのGoogle Drive保存先URL</label>
            <input
              value={driveUrl}
              onChange={(event) => setDriveUrl(event.target.value)}
              className="nf-input admin-input"
              placeholder={isEdit
                ? "空白: マイドライブルートに新たにコピー / フォルダURL: 指定フォルダにコピー"
                : "空白: マイドライブルート / フォルダURL: 指定フォルダに保存"}
            />
            <p className="nf-text-11 nf-text-muted nf-mt-4 nf-mb-0">
              {isEdit
                ? "現在のファイルURLが表示されています。空白にするとマイドライブルートに新たなコピーを作成します。フォルダURLに変更するとそのフォルダにコピーを作成します。ファイルURLは元のURL以外は指定できません。"
                : "空白の場合はマイドライブのルートに保存されます。フォルダURLを指定するとそのフォルダに保存されます。ファイルURLは指定できません。"}
            </p>
          </div>
        </div>

        {SETTINGS_GROUPS.map((group) => (
          <div key={group.key} className="nf-card nf-mb-16">
            <div className="nf-settings-group-title nf-mb-12">{group.label}</div>
            {(() => {
              const checkboxFields = group.fields.filter((f) => f.type === "checkbox");
              const otherFields = group.fields.filter((f) => f.type !== "checkbox");
              return (
                <>
                  {otherFields.map((field) => {
                    const isSelect = field.type === "select" || Array.isArray(field.options);
                    return (
                      <div key={field.key} className="nf-mb-12">
                        <label className="nf-block nf-fw-600 nf-mb-6">
                          {field.label}
                          {field.required && <span className="nf-text-danger nf-ml-4">*</span>}
                        </label>
                        {isSelect ? (
                          <select
                            className="nf-input"
                            value={localSettings[field.key] ?? ""}
                            onChange={(event) => handleSettingsChange(field.key, event.target.value)}
                          >
                            {(field.options || []).map((option) => (
                              <option key={option.value} value={option.value}>
                                {option.label}
                              </option>
                            ))}
                          </select>
                        ) : (
                          <input
                            className="nf-input"
                            type={field.type || "text"}
                            value={localSettings[field.key] ?? ""}
                            placeholder={field.placeholder}
                            onChange={(event) => handleSettingsChange(field.key, event.target.value)}
                          />
                        )}
                        {field.description && (
                          <p className="nf-text-11 nf-text-muted nf-mt-4 nf-mb-0">{field.description}</p>
                        )}
                      </div>
                    );
                  })}
                  {checkboxFields.length > 0 && (
                    <div className="nf-flex nf-flex-wrap nf-gap-16 nf-mb-12">
                      {checkboxFields.map((field) => (
                        <label key={field.key} className="nf-flex nf-items-center nf-gap-8" style={{ cursor: "pointer" }}>
                          <input
                            type="checkbox"
                            checked={localSettings[field.key] !== undefined ? !!localSettings[field.key] : !!field.defaultValue}
                            onChange={(event) => handleSettingsChange(field.key, event.target.checked)}
                          />
                          <span className="nf-fw-600">{field.label}</span>
                        </label>
                      ))}
                    </div>
                  )}
                </>
              );
            })()}
          </div>
        ))}

        <FormBuilderWorkspace
          ref={builderRef}
          initialSchema={initialSchema}
          initialSettings={initialSettings}
          formTitle={name || "フォーム"}
          onDirtyChange={setBuilderDirty}
          showToolbarSave={false}
        />
      </div>

      <ConfirmDialog open={confirmState} title="未保存の変更があります" message="保存せずに離れますか？" options={confirmOptions} />

</AppLayout>
  );
}



================================================
FILE: builder/src/pages/AdminSettingsPage.jsx
================================================
import React, { useEffect, useMemo, useState } from "react";
import AppLayout from "../app/components/AppLayout.jsx";
import ConfirmDialog from "../app/components/ConfirmDialog.jsx";
import { useAlert } from "../app/hooks/useAlert.js";
import { DEFAULT_THEME, applyThemeWithFallback } from "../app/theme/theme.js";
import { useBuilderSettings } from "../features/settings/settingsStore.js";
import { hasScriptRun, getAdminKey, setAdminKey, getAdminEmail, setAdminEmail, getRestrictToFormOnly, setRestrictToFormOnly } from "../services/gasClient.js";
import { useAuth } from "../app/state/authContext.jsx";

const normalizeAdminEmailInput = (value) => String(value || "")
  .split(";")
  .map((item) => item.trim())
  .filter(Boolean)
  .join(";");

export default function AdminSettingsPage() {
  const { showAlert } = useAlert();
const { settings } = useBuilderSettings();
  const [deployTime, setDeployTime] = useState("");

  const [adminKey, setAdminKeyState] = useState("");
  const [adminKeyInput, setAdminKeyInput] = useState("");
  const [adminKeyLoading, setAdminKeyLoading] = useState(false);
  const [adminKeyConfirm, setAdminKeyConfirm] = useState(false);

  const [adminEmail, setAdminEmailState] = useState("");
  const [adminEmailInput, setAdminEmailInput] = useState("");
  const [adminEmailLoading, setAdminEmailLoading] = useState(false);
  const [adminEmailConfirm, setAdminEmailConfirm] = useState(false);

  const [restrictToFormOnly, setRestrictToFormOnlyState] = useState(false);
  const [restrictToFormOnlyLoading, setRestrictToFormOnlyLoading] = useState(false);

  const { userEmail } = useAuth();
  const canManageAdminSettings = hasScriptRun();
  const normalizedAdminEmailInput = useMemo(
    () => normalizeAdminEmailInput(adminEmailInput),
    [adminEmailInput],
  );

  
  useEffect(() => {
    const metaTag = document.querySelector("meta[name=\"deploy-time\"]");
    if (metaTag) {
      setDeployTime(metaTag.getAttribute("content") || "");
    }
  }, []);

  useEffect(() => {
    if (!canManageAdminSettings) return;
    (async () => {
      try {
        const [key, email, restrict] = await Promise.all([getAdminKey(), getAdminEmail(), getRestrictToFormOnly()]);
        setAdminKeyState(key);
        setAdminKeyInput(key);
        setAdminEmailState(email);
        setAdminEmailInput(email);
        setRestrictToFormOnlyState(restrict);
      } catch (error) {
        console.error("[AdminSettingsPage] load failed", error);
        showAlert(error?.message || "管理者設定の読み込みに失敗しました");
      }
    })();
  }, [canManageAdminSettings, showAlert]);

  const handleSaveAdminKey = async () => {
    if (!canManageAdminSettings) return;
    setAdminKeyConfirm(false);
    setAdminKeyLoading(true);
    try {
      const newKey = await setAdminKey(adminKeyInput.trim());
      setAdminKeyState(newKey);
      setAdminKeyInput(newKey);
      if (newKey === "") {
        showAlert("管理者キーを解除しました。URLパラメータなしで管理者としてアクセスできます。");
      } else {
        showAlert("管理者キーを更新しました。次回から ?adminkey=" + newKey + " でアクセスしてください。");
      }
    } catch (error) {
      console.error("[AdminSettingsPage] setAdminKey failed", error);
      showAlert(error?.message || "管理者キーの保存に失敗しました");
    } finally {
      setAdminKeyLoading(false);
    }
  };

  const handleSaveAdminEmail = async () => {
    if (!canManageAdminSettings) return;
    setAdminEmailConfirm(false);
    setAdminEmailLoading(true);
    try {
      const newEmail = await setAdminEmail(normalizedAdminEmailInput);
      setAdminEmailState(newEmail);
      setAdminEmailInput(newEmail);
      if (newEmail === "") {
        showAlert("管理者メール制限を解除しました。メールアドレスによる管理者制限は行いません。");
      } else {
        showAlert("管理者メールを更新しました。設定済みメールと一致しないユーザーは管理者画面へアクセスできません。");
      }
    } catch (error) {
      console.error("[AdminSettingsPage] setAdminEmail failed", error);
      showAlert(error?.message || "管理者メールの保存に失敗しました");
    } finally {
      setAdminEmailLoading(false);
    }
  };

  const adminKeyConfirmOptions = [
    { value: "cancel", label: "キャンセル", onSelect: () => setAdminKeyConfirm(false) },
    { value: "save", label: "保存する", variant: "primary", onSelect: handleSaveAdminKey },
  ];

  const handleOpenAdminEmailConfirm = () => {
    // メールリストが空でない場合、現在のユーザーが含まれているか確認する
    if (normalizedAdminEmailInput) {
      const emails = normalizedAdminEmailInput.split(";").map((e) => e.trim().toLowerCase()).filter(Boolean);
      const currentEmail = (userEmail || "").trim().toLowerCase();
      if (!currentEmail || !emails.includes(currentEmail)) {
        showAlert(
          `現在のアカウント（${currentEmail || "不明"}）が管理者リストに含まれていません。\n` +
          `自分自身をロックアウトしないよう、現在のメールアドレスをリストに含めてください。`
        );
        return;
      }
    }
    setAdminEmailConfirm(true);
  };

  const adminEmailConfirmOptions = [
    { value: "cancel", label: "キャンセル", onSelect: () => setAdminEmailConfirm(false) },
    { value: "save", label: "保存する", variant: "primary", onSelect: handleSaveAdminEmail },
  ];

  const handleToggleRestrictToFormOnly = async (event) => {
    if (!canManageAdminSettings) return;
    const newValue = event.target.checked;
    setRestrictToFormOnlyLoading(true);
    try {
      const saved = await setRestrictToFormOnly(newValue);
      setRestrictToFormOnlyState(saved);
    } catch (error) {
      console.error("[AdminSettingsPage] setRestrictToFormOnly failed", error);
      showAlert(error?.message || "設定の保存に失敗しました");
    } finally {
      setRestrictToFormOnlyLoading(false);
    }
  };

  return (
    <AppLayout title="管理者設定" fallbackPath="/" badge="アクセス制御">
      <div className="nf-card">
        {!canManageAdminSettings && (
          <div className="nf-mb-12 nf-text-12 nf-text-muted">
            この機能はGoogle Apps Script環境でのみ利用可能です。
          </div>
        )}

        <div className="nf-settings-group-title nf-mb-6">管理者キー</div>
        <p className="nf-mb-12 nf-text-12 nf-text-muted">
          管理者キーを設定すると、URLパラメータ <code>?adminkey=キー</code> でアクセスした場合のみ管理者として認識されます。
          空欄にすると管理者キー制限は解除されます。
        </p>
        <label className="nf-block nf-fw-600 nf-mb-6">管理者キー</label>
        <div className="nf-row nf-gap-12">
          <input
            className="nf-input nf-flex-1 nf-min-w-0"
            type="text"
            value={adminKeyInput}
            placeholder="未設定（管理者キー制限なし）"
            onChange={(event) => setAdminKeyInput(event.target.value)}
          />
          <button
            type="button"
            className="nf-btn nf-nowrap"
            onClick={() => setAdminKeyConfirm(true)}
            disabled={adminKeyLoading || adminKeyInput.trim() === adminKey}
          >
            {adminKeyLoading ? "保存中..." : "保存"}
          </button>
        </div>
        <p className="nf-mt-6 nf-text-11 nf-text-muted">
          {adminKey ? (
            <>
              現在の管理者アクセスURL: <code>?adminkey={adminKey}</code>
            </>
          ) : (
            "現在は管理者キーが未設定のため、管理者キー制限はありません。"
          )}
        </p>

        <div className="nf-mt-16 nf-pt-16" style={{ borderTop: "1px solid var(--nf-color-border)" }}>
          <div className="nf-settings-group-title nf-mb-6">管理者メール</div>
          <p className="nf-mb-12 nf-text-12 nf-text-muted">
            複数指定する場合は <code>;</code> 区切りで入力してください。例: <code>admin1@example.com;admin2@example.com</code>
          </p>
          <label className="nf-block nf-fw-600 nf-mb-6">管理者メールアドレス</label>
          <div className="nf-row nf-gap-12">
            <input
              className="nf-input nf-flex-1 nf-min-w-0"
              type="text"
              value={adminEmailInput}
              placeholder="未設定（メール制限なし）"
              onChange={(event) => setAdminEmailInput(event.target.value)}
            />
            <button
              type="button"
              className="nf-btn nf-nowrap"
              onClick={handleOpenAdminEmailConfirm}
              disabled={adminEmailLoading || normalizedAdminEmailInput === adminEmail}
            >
              {adminEmailLoading ? "保存中..." : "保存"}
            </button>
          </div>
          <p className="nf-mt-6 nf-text-11 nf-text-muted">
            {adminEmail
              ? (
                <>
                  現在の管理者メール: <code>{adminEmail}</code>
                </>
              )
              : "現在は管理者メールが未設定のため、メールアドレスによる管理者制限はありません。"}
          </p>
        </div>

        <div className="nf-mt-16 nf-pt-16" style={{ borderTop: "1px solid var(--nf-color-border)" }}>
          <div className="nf-settings-group-title nf-mb-6">アクセス制限</div>
          <p className="nf-mb-12 nf-text-12 nf-text-muted">
            管理者キーまたは管理者メールが設定されている場合に有効です。ONにすると、<code>?form=xxx</code> を指定しない一般ユーザーはアクセス拒否されます。
          </p>
          <label className="nf-row nf-gap-8" style={{ alignItems: "center", cursor: restrictToFormOnlyLoading ? "default" : "pointer" }}>
            <input
              type="checkbox"
              checked={restrictToFormOnly}
              disabled={!canManageAdminSettings || restrictToFormOnlyLoading}
              onChange={handleToggleRestrictToFormOnly}
            />
            <span className="nf-text-13">
              一般ユーザーが行ける範囲を個別フォームのみとする
            </span>
            {restrictToFormOnlyLoading && <span className="nf-text-12 nf-text-muted">保存中...</span>}
          </label>
        </div>

        <div className="nf-mt-16 nf-pt-16" style={{ borderTop: "1px solid var(--nf-color-border)" }}>
          <div className="nf-settings-group-title nf-mb-6">システム情報</div>
          <div className="nf-text-12 nf-text-muted">
            <div>最終デプロイ: {deployTime || "情報なし"}</div>
          </div>
        </div>
      </div>

      <ConfirmDialog
        open={adminKeyConfirm}
        title="管理者キーを変更しますか？"
        message={
          adminKeyInput.trim()
            ? `管理者キーを「${adminKeyInput.trim()}」に変更します。変更後は ?adminkey=${adminKeyInput.trim()} でアクセスしてください。`
            : "管理者キーを解除します。URLパラメータなしで管理者としてアクセスできるようになります。"
        }
        options={adminKeyConfirmOptions}
      />

      <ConfirmDialog
        open={adminEmailConfirm}
        title="管理者メールを変更しますか？"
        message={
          normalizedAdminEmailInput
            ? `管理者メールを「${normalizedAdminEmailInput}」に変更します。設定されたメール以外は管理者画面へアクセスできなくなります。`
            : "管理者メール制限を解除します。メールアドレスによる管理者制限は行われません。"
        }
        options={adminEmailConfirmOptions}
      />

</AppLayout>
  );
}



================================================
FILE: builder/src/pages/ConfigPage.jsx
================================================
import React, { useCallback, useEffect, useMemo, useState } from "react";
import { useSearchParams } from "react-router-dom";
import AppLayout from "../app/components/AppLayout.jsx";
import { useAlert } from "../app/hooks/useAlert.js";
import { useBuilderSettings } from "../features/settings/settingsStore.js";
import { useAppData } from "../app/state/AppDataProvider.jsx";
import {
  DEFAULT_THEME,
  THEME_OPTIONS,
  getCustomThemes,
  removeCustomTheme,
  setCustomTheme,
  applyThemeWithFallback,
  resolveThemeName,
} from "../app/theme/theme.js";
import ConfirmDialog from "../app/components/ConfirmDialog.jsx";
import { hasScriptRun, importThemeFromDrive } from "../services/gasClient.js";

const extractThemeName = (css, fallbackName = "") => {
  const match = String(css || "").match(/data-theme=(["'])([^"']+)\1/);
  if (match && match[2]) return match[2].trim();
  if (fallbackName) {
    return fallbackName.replace(/\.[^/.]+$/, "");
  }
  return "";
};

const buildThemeApplyMessage = (updated, failed) => {
  if (updated === 0 && failed === 0) return "更新対象のフォームはありませんでした。";
  if (failed === 0) return `${updated}件のフォームテーマを更新しました。`;
  return `${updated}件のフォームテーマを更新し、${failed}件は更新に失敗しました。`;
};

export default function ConfigPage() {
  const [searchParams] = useSearchParams();
  const requestedFormId = (searchParams.get("form") || "").trim();
  const isFormMode = requestedFormId !== "";

  const { settings, updateSetting } = useBuilderSettings({ applyGlobalTheme: false });
  const { forms, getFormById, updateForm } = useAppData();
  const { showAlert } = useAlert();
const targetForm = useMemo(
    () => (requestedFormId ? getFormById(requestedFormId) : null),
    [requestedFormId, getFormById],
  );
  const rawFormTheme = targetForm?.settings?.theme;
  const formTheme = rawFormTheme || DEFAULT_THEME;
  const rawGlobalTheme = settings?.theme;
  const globalTheme = rawGlobalTheme || DEFAULT_THEME;
  const themeValue = isFormMode ? formTheme : globalTheme;
  const syncAllFormsTheme = settings?.syncAllFormsTheme ?? false;

  const [customThemes, setCustomThemes] = useState([]);
  const [customThemesReady, setCustomThemesReady] = useState(false);
  const [importUrl, setImportUrl] = useState("");
  const [importing, setImporting] = useState(false);
  const [removeTarget, setRemoveTarget] = useState(null);
  const [deployTime, setDeployTime] = useState("");
  const [applyingTheme, setApplyingTheme] = useState(false);

  const themeOptions = useMemo(
    () => [
      ...THEME_OPTIONS,
      ...customThemes.map((theme) => ({ value: theme.id, label: theme.name || "カスタムテーマ" })),
    ],
    [customThemes],
  );
  const availableThemeIds = useMemo(
    () => new Set(themeOptions.map((option) => option.value)),
    [themeOptions],
  );
  const selectThemeValue = availableThemeIds.has(themeValue) ? themeValue : DEFAULT_THEME;
  const fallbackPath = isFormMode ? `/search?form=${encodeURIComponent(requestedFormId)}` : "/";
  const pageTitle = isFormMode
    ? `${targetForm?.settings?.formTitle || requestedFormId} - 設定`
    : "設定";

  useEffect(() => {
    let active = true;
    (async () => {
      try {
        const themes = await getCustomThemes();
        if (active) {
          setCustomThemes(themes);
        }
      } finally {
        if (active) {
          setCustomThemesReady(true);
        }
      }
    })();
    return () => {
      active = false;
    };
  }, []);

  // 個別フォーム設定では常に対象フォームのテーマを画面へ適用
  useEffect(() => {
    if (!isFormMode || !targetForm) return;
    void applyThemeWithFallback(formTheme, { persist: false });
  }, [isFormMode, targetForm?.id, formTheme]);

  // メイン設定では常にグローバルテーマを画面へ適用
  useEffect(() => {
    if (isFormMode) return;
    void applyThemeWithFallback(globalTheme, { persist: false });
  }, [isFormMode, globalTheme]);

  // テーマ欠損時のフォールバック（IndexedDBクリア等）
  useEffect(() => {
    if (!customThemesReady) return;

    if (isFormMode) {
      if (!targetForm) return;
      const resolved = resolveThemeName(rawFormTheme, customThemes);
      if (resolved !== rawFormTheme) {
        void updateForm(targetForm.id, {
          settings: { ...(targetForm.settings || {}), theme: resolved },
        });
      }
      return;
    }

    const resolved = resolveThemeName(rawGlobalTheme, customThemes);
    if (resolved !== rawGlobalTheme) {
      updateSetting("theme", resolved);
    }
  }, [
    customThemesReady,
    isFormMode,
    targetForm?.id,
    targetForm?.settings,
    rawFormTheme,
    rawGlobalTheme,
    customThemes,
    updateSetting,
    updateForm,
  ]);

  // デプロイ時刻を読み取り
  useEffect(() => {
    const metaTag = document.querySelector("meta[name=\"deploy-time\"]");
    if (metaTag) {
      setDeployTime(metaTag.getAttribute("content") || "");
    }
  }, []);

  const applyThemeToAllForms = useCallback(
    async (nextTheme) => {
      const targets = forms.filter((form) => (form?.settings?.theme || DEFAULT_THEME) !== nextTheme);
      let updated = 0;
      let failed = 0;

      for (const form of targets) {
        try {
          await updateForm(form.id, {
            settings: { ...(form.settings || {}), theme: nextTheme },
          });
          updated += 1;
        } catch (error) {
          failed += 1;
          console.error("[ConfigPage] applyThemeToAllForms failed", { formId: form.id, error });
        }
      }
      return { updated, failed };
    },
    [forms, updateForm],
  );

  const handleChangeMainTheme = useCallback(async (nextTheme) => {
    updateSetting("theme", nextTheme);
  }, [updateSetting]);

  const handleChangeFormTheme = useCallback(
    async (nextTheme) => {
      if (!targetForm) return;
      await updateForm(targetForm.id, {
        settings: { ...(targetForm.settings || {}), theme: nextTheme },
      });
      await applyThemeWithFallback(nextTheme, { persist: false });
    },
    [targetForm, updateForm],
  );

  const handleThemeChange = async (event) => {
    const nextTheme = event.target.value;

    if (isFormMode) {
      await handleChangeFormTheme(nextTheme);
      return;
    }

    await handleChangeMainTheme(nextTheme);
    if (!syncAllFormsTheme) return;

    setApplyingTheme(true);
    try {
      await applyThemeToAllForms(nextTheme);
    } finally {
      setApplyingTheme(false);
    }
  };

  const handleToggleSyncAllFormsTheme = async (checked) => {
    updateSetting("syncAllFormsTheme", checked);
    if (!checked) return;

    setApplyingTheme(true);
    try {
      await applyThemeToAllForms(globalTheme);
    } finally {
      setApplyingTheme(false);
    }
  };

  const handleImportTheme = async () => {
    if (importing) return;
    if (!hasScriptRun()) {
      showAlert("インポート機能はGoogle Apps Script環境でのみ利用可能です");
      return;
    }
    const url = (importUrl || "").trim();
    if (!url) {
      showAlert("Google Drive URLを入力してください");
      return;
    }
    setImporting(true);
    try {
      const result = await importThemeFromDrive(url);
      const css = result?.css || "";
      if (!css.trim()) {
        throw new Error("テーマファイルが空です");
      }
      const name = extractThemeName(css, result?.fileName);
      const theme = await setCustomTheme({ css, name });
      if (!theme) {
        throw new Error("テーマファイルが空です");
      }
      const nextThemes = await getCustomThemes();
      setCustomThemes(nextThemes);
      setImportUrl("");

      if (isFormMode) {
        await handleChangeFormTheme(theme.id);
      } else {
        await handleChangeMainTheme(theme.id);
        if (syncAllFormsTheme) {
          const { updated, failed } = await applyThemeToAllForms(theme.id);
          showAlert(`テーマをインポートしました。${buildThemeApplyMessage(updated, failed)}`);
          return;
        }
      }
      showAlert("テーマをインポートしました");
    } catch (error) {
      console.error("[ConfigPage] theme import failed", error);
      showAlert(error?.message || "テーマのインポートに失敗しました");
    } finally {
      setImporting(false);
    }
  };

  const handleRemoveCustomTheme = (theme) => {
    if (!theme) return;
    setRemoveTarget(theme);
  };

  const handleConfirmRemove = async () => {
    if (!removeTarget) return;
    const nextThemes = await removeCustomTheme(removeTarget.id);
    setCustomThemes(nextThemes);
    let syncMessage = "";
    if (selectThemeValue === removeTarget.id) {
      if (isFormMode && targetForm) {
        await handleChangeFormTheme(DEFAULT_THEME);
      } else {
        await handleChangeMainTheme(DEFAULT_THEME);
        if (syncAllFormsTheme) {
          const { updated, failed } = await applyThemeToAllForms(DEFAULT_THEME);
          syncMessage = ` ${buildThemeApplyMessage(updated, failed)}`;
        }
      }
    }
    setRemoveTarget(null);
    showAlert(`インポートしたテーマを削除しました。${syncMessage}`.trim());
  };

  const removeOptions = [
    { value: "cancel", label: "キャンセル", onSelect: () => setRemoveTarget(null) },
    { value: "remove", label: "削除する", variant: "danger", onSelect: handleConfirmRemove },
  ];

  if (isFormMode && !targetForm) {
    return (
      <AppLayout title="設定" fallbackPath={fallbackPath} backHidden={false} badge="テーマ" themeOverride={themeValue}>
        <div className="nf-card">
          <p>指定されたフォームが見つかりません。</p>
          <p className="nf-text-muted nf-text-14 nf-mt-8">メイン画面からフォームを選択してやり直してください。</p>
        </div>
</AppLayout>
    );
  }

  return (
    <AppLayout title={pageTitle} fallbackPath={fallbackPath} backHidden={false} badge="テーマ" themeOverride={themeValue}>
      <div className="nf-card">
        <div className="nf-fw-600 nf-mb-8">テーマ設定</div>
        <div className="nf-mb-12">
          <label className="nf-block nf-fw-600 nf-mb-6">テーマ</label>
          <select
            className="nf-input"
            value={selectThemeValue}
            onChange={handleThemeChange}
            disabled={applyingTheme}
          >
            {themeOptions.map((option) => (
              <option key={option.value} value={option.value}>
                {option.label}
              </option>
            ))}
          </select>
          <p className="nf-mt-6 nf-text-12 nf-text-muted">
            {isFormMode ? "このフォームにのみ適用されます。" : "フォーム以外の画面に適用されます。"}
          </p>
        </div>

        {!isFormMode && (
          <div className="nf-mb-12">
            <label className="nf-row nf-gap-8 nf-items-center">
              <input
                type="checkbox"
                checked={syncAllFormsTheme}
                onChange={(event) => handleToggleSyncAllFormsTheme(event.target.checked)}
                disabled={applyingTheme}
              />
              <span className="nf-fw-600">フォームテーマも一括変更</span>
            </label>
            <p className="nf-mt-6 nf-text-12 nf-text-muted">
              ON時にテーマを変更すると、その時点の値で全フォームのテーマ設定を一括更新します。
            </p>
          </div>
        )}

        <div className="nf-mt-16">
          <div className="nf-settings-group-title nf-mb-8">テーマをインポート</div>
          <p className="nf-mb-12 nf-text-12 nf-text-muted">
            インポートするGoogle Drive内CSSファイルURLを指定してください
          </p>
          <div className="nf-row nf-gap-12">
            <input
              className="nf-input nf-flex-1 nf-min-w-0"
              type="text"
              value={importUrl}
              placeholder="https://drive.google.com/file/d/..."
              onChange={(event) => setImportUrl(event.target.value)}
            />
            <button
              type="button"
              className="nf-btn nf-nowrap"
              onClick={handleImportTheme}
              disabled={importing || applyingTheme}
            >
              {importing ? "インポート中..." : "インポート"}
            </button>
          </div>
          {customThemes.length > 0 && (
            <div className="nf-mt-12">
              <div className="nf-text-12 nf-text-muted">インポート済みテーマ</div>
              <div className="nf-col nf-gap-12 nf-mt-8">
                {customThemes.map((theme) => (
                  <div key={theme.id} className="nf-row nf-gap-12">
                    <div className="nf-flex-1 nf-min-w-0">
                      <div className="nf-fw-600">{theme.name || "カスタムテーマ"}</div>
                    </div>
                    <button
                      type="button"
                      className="nf-btn-outline nf-nowrap"
                      onClick={() => handleRemoveCustomTheme(theme)}
                    >
                      削除
                    </button>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        <div className="nf-mt-16 nf-pt-16" style={{ borderTop: "1px solid var(--nf-color-border)" }}>
          <div className="nf-settings-group-title nf-mb-6">システム情報</div>
          <div className="nf-text-12 nf-text-muted">
            <div>最終デプロイ: {deployTime || "情報なし"}</div>
          </div>
        </div>
      </div>
      <ConfirmDialog
        open={Boolean(removeTarget)}
        title="インポートテーマを削除しますか？"
        message={
          removeTarget
            ? `削除すると「${removeTarget.name || "カスタムテーマ"}」は一覧から消え、選択中の場合はDefaultに戻ります。`
            : ""
        }
        options={removeOptions}
      />
</AppLayout>
  );
}



================================================
FILE: builder/src/pages/FormPage.jsx
================================================
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useLocation, useNavigate, useParams } from "react-router-dom";
import AppLayout from "../app/components/AppLayout.jsx";
import ConfirmDialog from "../app/components/ConfirmDialog.jsx";
import PreviewPage from "../features/preview/PreviewPage.jsx";
import { useAppData } from "../app/state/AppDataProvider.jsx";
import { dataStore } from "../app/state/dataStore.js";
import { restoreResponsesFromData, hasDirtyChanges, collectDefaultNowResponses } from "../utils/responses.js";
import { submitResponses, hasScriptRun } from "../services/gasClient.js";
import { normalizeSpreadsheetId } from "../utils/spreadsheet.js";
import { useAlert } from "../app/hooks/useAlert.js";
import { useBeforeUnloadGuard } from "../app/hooks/useBeforeUnloadGuard.js";
import { normalizeSchemaIDs } from "../core/schema.js";
import { getCachedEntryWithIndex } from "../app/state/recordsCache.js";
import { RECORD_CACHE_MAX_AGE_MS } from "../app/state/cachePolicy.js";
import { useAuth } from "../app/state/authContext.jsx";
import { DEFAULT_THEME, applyThemeWithFallback } from "../app/theme/theme.js";
import { perfLogger } from "../utils/perfLogger.js";

const fallbackForForm = (formId, locationState) => {
  if (locationState?.from) return locationState.from;
  if (formId) return `/search?form=${formId}`;
  return "/";
};

export default function FormPage() {
  const { formId, entryId } = useParams();
  const { getFormById } = useAppData();
  const { userName, userEmail } = useAuth();
  const location = useLocation();
  const navigate = useNavigate();
  const { showAlert } = useAlert();
  const form = formId ? getFormById(formId) : null;
  const normalizedSchema = useMemo(() => normalizeSchemaIDs(form?.schema || []), [form]);
  const [entry, setEntry] = useState(null);
  const [loading, setLoading] = useState(true);
  const [responses, setResponses] = useState({});
  const [currentRecordId, setCurrentRecordId] = useState(entryId || null);
  const [confirmState, setConfirmState] = useState({ open: false, intent: null });
  const [isSaving, setIsSaving] = useState(false);
  const [mode, setMode] = useState(entryId ? "view" : "edit");
  const [isReloading, setIsReloading] = useState(false);
  const initialResponsesRef = useRef({});
  const previewRef = useRef(null);

  const fallbackPath = useMemo(() => fallbackForForm(formId, location.state), [formId, location.state]);

  useEffect(() => {
    if (!form) return;
    const theme = form?.settings?.theme || DEFAULT_THEME;
    void applyThemeWithFallback(theme, { persist: false });
  }, [form?.id, form?.settings?.theme]);

  const entryIds = location.state?.entryIds || [];
  const currentIndex = entryId ? entryIds.indexOf(entryId) : -1;
  const hasPrev = currentIndex > 0;
  const hasNext = currentIndex >= 0 && currentIndex < entryIds.length - 1;

  useEffect(() => {
    setMode(entryId ? "view" : "edit");
  }, [entryId]);

  const isViewMode = mode === "view";
  const applyEntryToState = useCallback((nextEntry, fallbackEntryId = null) => {
    setEntry(nextEntry);
    const restored = restoreResponsesFromData(normalizedSchema, nextEntry?.data || {}, nextEntry?.dataUnixMs || {});
    initialResponsesRef.current = restored;
    setResponses(restored);
    setCurrentRecordId(nextEntry?.id || fallbackEntryId || null);
  }, [normalizedSchema]);

  const navigateToEntryById = useCallback((targetEntryId) => {
    navigate(`/form/${formId}/entry/${targetEntryId}`, {
      state: { from: location.state?.from, entryIds },
      replace: true,
    });
  }, [navigate, formId, location.state?.from, entryIds]);

  useEffect(() => {
    let mounted = true;
    const loadEntry = async () => {
      const tStart = performance.now();
      perfLogger.logVerbose("form-page", "loadEntry start", { formId, entryId });

      if (!formId || !form) {
        setLoading(false);
        return;
      }
      if (!entryId) {
        const initialResponses = collectDefaultNowResponses(normalizedSchema, new Date(), { userName, userEmail });
        initialResponsesRef.current = initialResponses;
        setResponses(initialResponses);
        setLoading(false);
        return;
      }
      setLoading(true);

      const tBeforeGetEntry = performance.now();
      perfLogger.logVerbose("form-page", "before dataStore.getEntry", {
        elapsedFromStartMs: Number((tBeforeGetEntry - tStart).toFixed(2)),
        formId,
        entryId,
      });

      // まずキャッシュから取得を試みる
      const { entry: cachedEntry, rowIndex, lastSyncedAt } = await getCachedEntryWithIndex(formId, entryId);

      if (cachedEntry && mounted) {
        // キャッシュがあれば即座に表示
        applyEntryToState(cachedEntry, entryId);
        setLoading(false);
        perfLogger.logVerbose("form-page", "cache displayed", {
          elapsedFromStartMs: Number((performance.now() - tStart).toFixed(2)),
          rowIndex,
        });

        // キャッシュ年齢を計算し、5分以上古い場合はバックグラウンド更新
        const cacheAge = lastSyncedAt ? Date.now() - lastSyncedAt : Infinity;
        const shouldBackground = cacheAge >= RECORD_CACHE_MAX_AGE_MS;

        if (shouldBackground) {
          perfLogger.logVerbose("form-page", "start background refresh", {
            cacheAgeMs: cacheAge,
            thresholdMs: RECORD_CACHE_MAX_AGE_MS,
            rowIndexHint: rowIndex,
          });
          setIsReloading(true);
          dataStore.getEntry(formId, entryId, { rowIndexHint: rowIndex }).then((freshData) => {
            if (!mounted) return;
            if (freshData) {
              applyEntryToState(freshData, entryId);
              perfLogger.logVerbose("form-page", "background refresh complete", {
                elapsedFromStartMs: Number((performance.now() - tStart).toFixed(2)),
              });
            }
            setIsReloading(false);
          }).catch((error) => {
            console.error("[FormPage] background refresh failed:", error);
            setIsReloading(false);
          });
        } else {
          perfLogger.logVerbose("form-page", "cache is fresh; skip background refresh", {
            cacheAgeMs: cacheAge,
            thresholdMs: RECORD_CACHE_MAX_AGE_MS,
          });
        }
      } else {
        // キャッシュがない場合は同期読み取り（rowIndexがある場合は渡す）
        const data = await dataStore.getEntry(formId, entryId, rowIndex !== undefined ? { rowIndexHint: rowIndex } : {});

        const tAfterGetEntry = performance.now();
        perfLogger.logVerbose("form-page", "after dataStore.getEntry", {
          durationMs: Number((tAfterGetEntry - tBeforeGetEntry).toFixed(2)),
          rowIndexHint: rowIndex,
        });

        if (!mounted) return;
        const tBeforeApply = performance.now();
        applyEntryToState(data, entryId);
        const tAfterApply = performance.now();
        perfLogger.logVerbose("form-page", "applyEntryToState", {
          durationMs: Number((tAfterApply - tBeforeApply).toFixed(2)),
        });
        setLoading(false);

        const tEnd = performance.now();
        perfLogger.logVerbose("form-page", "loadEntry complete", {
          totalDurationMs: Number((tEnd - tStart).toFixed(2)),
          formId,
          entryId,
        });
      }
    };
    loadEntry();
    return () => {
      mounted = false;
    };
  }, [formId, entryId, form, normalizedSchema, userName, userEmail, applyEntryToState]);

  const isDirty = useMemo(() => hasDirtyChanges(initialResponsesRef.current, responses), [responses]);

  useBeforeUnloadGuard(isDirty);

  const navigateBack = ({ saved = false } = {}) => {
    const state = saved ? { saved: true } : undefined;
    if (location.state?.from) {
      navigate(location.state.from, { replace: true, state });
      return;
    }
    if (fallbackPath) {
      navigate(fallbackPath, { replace: true, state });
    } else {
      navigate("/", { replace: true, state });
    }
  };

  const handleSaveToStore = async ({ payload }) => {
    if (!form) throw new Error("form_not_found");
    const isNewEntry = !entry?.id;
    const createdBy = isNewEntry ? (userEmail || "") : (entry?.createdBy || "");
    const modifiedBy = userEmail || entry?.modifiedBy || "";

    // まずIndexedDBに即時保存（体感レスポンスを優先）
    const saved = await dataStore.upsertEntry(form.id, {
      id: payload.id,
      data: payload.responses,
      order: payload.order,
      createdBy,
      modifiedBy,
    });

    // スプレッドシート保存はバックグラウンドで継続
    const settings = form.settings || {};
    const spreadsheetId = normalizeSpreadsheetId(settings.spreadsheetId || "");
    const sheetName = settings.sheetName || "Data";

    if (spreadsheetId) {
      if (!hasScriptRun()) {
        console.warn("[FormPage] google.script.run unavailable; skipped background spreadsheet save");
      } else {
        void submitResponses({
          spreadsheetId,
          sheetName,
          payload: { ...payload, id: saved.id },
        }).catch((error) => {
          console.error("[FormPage] Background spreadsheet save failed:", error);
        });
      }
    } else {
      console.warn("[FormPage] No spreadsheetId configured, skipping spreadsheet save");
    }
    applyEntryToState(saved, saved.id);
    return saved;
  };

  const triggerSave = async ({ redirect } = {}) => {
    if (!form) {
      showAlert("フォームが見つかりません");
      return;
    }
    try {
      setIsSaving(true);
      const preview = previewRef.current;
      if (!preview) throw new Error("preview_not_ready");
      await preview.submit({ silent: true });
      if (redirect) navigateBack({ saved: true });
    } catch (error) {
      console.warn(error);
      if (error?.message === "validation_failed" || error?.message?.includes("missing_")) {
        setIsSaving(false);
        return;
      }
      setIsSaving(false);
      showAlert(`保存に失敗しました: ${error?.message || error}`);
      return;
    }
    setIsSaving(false);
  };

  const attemptLeave = (intent) => {
    if (isDirty) {
      setConfirmState({ open: true, intent });
      return;
    }
    if (intent === "back" || intent === "cancel") {
      navigateBack();
      return;
    }
  };

  const handleEditMode = async () => {
    if (!formId || !entryId) return;
    setIsReloading(true);
    setMode("edit");
    try {
      const data = await dataStore.getEntry(formId, entryId, { forceSync: true });
      if (!data) {
        showAlert("レコードが見つかりませんでした。削除された可能性があります。");
        navigateBack();
        return;
      }
      applyEntryToState(data, entryId);
    } catch (error) {
      console.error("[FormPage] handleEditMode error:", error);
      showAlert(`データの読み込みに失敗しました: ${error?.message || error}`);
    } finally {
      setIsReloading(false);
    }
  };

  const handleBack = () => {
    if (!isDirty) {
      navigateBack();
      return false;
    }
    setConfirmState({ open: true, intent: "back" });
    return false;
  };

  if (!form) {
    return (
      <AppLayout themeOverride={form?.settings?.theme} title="フォーム" fallbackPath="/">
        <p className="nf-text-subtle">フォームが見つかりません。メイン画面からやり直してください。</p>
      </AppLayout>
    );
  }

  const navigateToEntry = (targetEntryId) => {
    if (isDirty) {
      setConfirmState({ open: true, intent: `navigate:${targetEntryId}` });
      return;
    }
    navigateToEntryById(targetEntryId);
  };

  const handleConfirmAction = async (action) => {
    const intent = confirmState.intent;
    setConfirmState({ open: false, intent: null });
    if (action === "discard") {
      if (intent && intent.startsWith("navigate:")) {
        const targetEntryId = intent.slice("navigate:".length);
        navigateToEntryById(targetEntryId);
      } else {
        navigateBack();
      }
      return;
    }
    if (action === "save") {
      if (intent && intent.startsWith("navigate:")) {
        const targetEntryId = intent.slice("navigate:".length);
        await triggerSave();
        navigateToEntryById(targetEntryId);
      } else {
        await triggerSave({ redirect: true });
      }
    }
  };

  const confirmOptions = [
    {
      label: "保存して続行",
      value: "save",
      variant: "primary",
      onSelect: () => handleConfirmAction("save"),
    },
    {
      label: "保存せずに戻る",
      value: "discard",
      onSelect: () => handleConfirmAction("discard"),
    },
    {
      label: "キャンセル",
      value: "cancel",
      onSelect: () => setConfirmState({ open: false, intent: null }),
    },
  ];

  const confirmMessage = "保存せずに前の画面へ戻りますか？";

  return (
    <AppLayout themeOverride={form?.settings?.theme}       title={`${form.settings?.formTitle || "(無題)"} - フォーム入力`}
      fallbackPath={fallbackPath}
      onBack={handleBack}
      backHidden={true}
      badge={{
        label: (loading || isReloading) ? "読み取り中..." : (isViewMode ? "閲覧モード" : "編集モード"),
        variant: (loading || isReloading) ? "loading" : (isViewMode ? "view" : "edit")
      }}
      sidebarActions={
        <>
          {isViewMode ? (
            <>
              <button type="button" className="nf-btn-outline nf-btn-sidebar nf-text-14" onClick={handleEditMode}>
                編集
              </button>
              <button type="button" className="nf-btn-outline nf-btn-sidebar nf-text-14" onClick={() => navigateBack()}>
                戻る
              </button>
            </>
          ) : (
            <>
              <button type="button" className="nf-btn-outline nf-btn-sidebar nf-text-14" disabled={isSaving || isReloading} onClick={() => triggerSave({ redirect: true })}>
                保存
              </button>
              <button type="button" className="nf-btn-outline nf-btn-sidebar nf-text-14" onClick={() => attemptLeave("cancel")}>
                キャンセル
              </button>
            </>
          )}
          {entryIds.length > 0 && (
            <>
              <hr className="nf-sidebar-divider" />
              <div className="nf-flex nf-gap-8 nf-items-center">
                <button type="button" className="nf-btn-outline nf-btn-sidebar nf-text-14" disabled={!hasPrev} onClick={() => navigateToEntry(entryIds[currentIndex - 1])}>
                  ← 前へ
                </button>
                <button type="button" className="nf-btn-outline nf-btn-sidebar nf-text-14" disabled={!hasNext} onClick={() => navigateToEntry(entryIds[currentIndex + 1])}>
                  次へ →
                </button>
              </div>
              <span className="nf-text-11 nf-text-muted">{currentIndex + 1} / {entryIds.length}</span>
            </>
          )}
        </>
      }
    >
      {loading ? (
        <p className="nf-text-subtle">読み込み中...</p>
      ) : (
        <PreviewPage
          ref={previewRef}
          schema={normalizedSchema}
          responses={responses}
          setResponses={setResponses}
          settings={{ ...(form.settings || {}), recordId: currentRecordId, recordNo: entry?.["No."] || "", userName, userEmail }}
          onSave={handleSaveToStore}
          showOutputJson={false}
          showSaveButton={false}
          readOnly={isViewMode || isReloading}
        />
      )}

      <ConfirmDialog
        open={confirmState.open}
        title="未保存の変更があります"
        message={confirmMessage}
        options={confirmOptions}
      />

</AppLayout>
  );
}



================================================
FILE: builder/src/pages/MainPage.jsx
================================================
import React, { useEffect, useMemo } from "react";
import { useNavigate } from "react-router-dom";
import AppLayout from "../app/components/AppLayout.jsx";
import { useAppData } from "../app/state/AppDataProvider.jsx";
import { useAuth } from "../app/state/authContext.jsx";
import { DEFAULT_THEME, applyThemeWithFallback } from "../app/theme/theme.js";
import { useBuilderSettings } from "../features/settings/settingsStore.js";
import { formatUnixMsDateTime, toUnixMs } from "../utils/dateTime.js";

export default function MainPage() {
  const { forms, loadingForms } = useAppData();
  const { isAdmin, propertyStoreMode, adminSettingsEnabled } = useAuth();
  const { settings } = useBuilderSettings();
  const navigate = useNavigate();

  const activeForms = useMemo(() => forms.filter((form) => !form.archived), [forms]);

  
  const handleSelect = (formId) => {
    navigate(`/search?form=${formId}`, {
      state: { fromMainPage: true }
    });
  };

  const handleGoForms = () => {
    navigate("/forms");
  };

  const handleGoConfig = () => {
    navigate("/config");
  };

  const handleGoAdminSettings = () => {
    navigate("/admin-settings");
  };

  const showAdminSettingsButton = isAdmin && adminSettingsEnabled;
  const showFormsButton = propertyStoreMode === "user" || isAdmin;

  return (
    <AppLayout
      title="フォーム一覧"
      backHidden
      sidebarActions={
        <>
          <button type="button" onClick={handleGoConfig} className="nf-btn-outline nf-btn-sidebar">
            設定
          </button>
          {showAdminSettingsButton && (
            <button type="button" onClick={handleGoAdminSettings} className="nf-btn-outline nf-btn-sidebar">
              管理者設定
            </button>
          )}
          {showFormsButton && (
            <button type="button" onClick={handleGoForms} className="nf-btn-outline nf-btn-sidebar">
              フォーム管理
            </button>
          )}
        </>
      }
    >
      {loadingForms ? (
        <p className="nf-text-subtle">読み込み中...</p>
      ) : activeForms.length === 0 ? (
        <p className="nf-text-subtle">登録済みのフォームがありません。フォーム管理から作成してください。</p>
      ) : (
        <div className="main-list">
          {activeForms.map((form) => (
            <div key={form.id} className="main-card" onClick={() => handleSelect(form.id)}>
              <h2 className="main-title">{form.settings?.formTitle || "(無題)"}</h2>
              {form.description && <p className="nf-m-0 nf-text-muted">{form.description}</p>}
              <div className="main-meta">
                最終更新: {formatUnixMsDateTime(form.modifiedAtUnixMs ?? toUnixMs(form.modifiedAt))}
              </div>
            </div>
          ))}
        </div>
      )}
    </AppLayout>
  );
}



================================================
FILE: builder/src/pages/NotFoundPage.jsx
================================================
import React from "react";
import { useNavigate } from "react-router-dom";
import AppLayout from "../app/components/AppLayout.jsx";

export default function NotFoundPage() {
  const navigate = useNavigate();
  return (
    <AppLayout title="ページが見つかりません" fallbackPath="/" backHidden>
      <p className="nf-text-subtle">指定されたページは存在しません。</p>
      <button type="button" onClick={() => navigate("/")} className="nf-btn-outline">
        メインへ戻る
      </button>
    </AppLayout>
  );
}



================================================
FILE: builder/src/pages/SearchPage.jsx
================================================
import React, { useMemo, useState, useCallback, useEffect } from "react";
import { useLocation, useNavigate, useSearchParams } from "react-router-dom";
import AppLayout from "../app/components/AppLayout.jsx";
import ConfirmDialog from "../app/components/ConfirmDialog.jsx";
import { useAppData } from "../app/state/AppDataProvider.jsx";
import { useAuth } from "../app/state/authContext.jsx";
import { dataStore } from "../app/state/dataStore.js";
import { useBuilderSettings } from "../features/settings/settingsStore.js";
import { useAlert } from "../app/hooks/useAlert.js";
import {
  buildSearchTableLayout,
  buildExportTableData,
  computeRowValues,
  compareByColumn,
  matchesKeyword,
  parseSearchCellDisplayLimit,
} from "../features/search/searchTable.js";
import { exportSearchResults } from "../services/gasClient.js";
import { useEntriesWithCache } from "../features/search/useEntriesWithCache.js";
import SearchToolbar from "../features/search/components/SearchToolbar.jsx";
import SearchSidebar from "../features/search/components/SearchSidebar.jsx";
import SearchTable from "../features/search/components/SearchTable.jsx";
import SearchPagination from "../features/search/components/SearchPagination.jsx";
import { DEFAULT_THEME, applyThemeWithFallback } from "../app/theme/theme.js";
import { DEFAULT_PAGE_SIZE } from "../core/constants.js";

const getThemeColors = () => {
  const style = getComputedStyle(document.documentElement);
  const get = (v) => style.getPropertyValue(v).trim();
  const toHex = (color) => {
    if (!color) return null;
    if (/^#[0-9a-fA-F]{6}$/.test(color)) return color.toLowerCase();
    if (/^#[0-9a-fA-F]{3}$/.test(color)) {
      return "#" + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
    }
    if (/^#[0-9a-fA-F]{8}$/.test(color)) {
      const r = parseInt(color.slice(1, 3), 16);
      const g = parseInt(color.slice(3, 5), 16);
      const b = parseInt(color.slice(5, 7), 16);
      const a = parseInt(color.slice(7, 9), 16) / 255;
      const blend = (c) => Math.round(c * a + 255 * (1 - a));
      return "#" + [blend(r), blend(g), blend(b)].map((c) => c.toString(16).padStart(2, "0")).join("");
    }
    const m = color.match(/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*([\d.]+))?\s*\)/);
    if (!m) return null;
    const r = parseInt(m[1]);
    const g = parseInt(m[2]);
    const b = parseInt(m[3]);
    const a = m[4] !== undefined ? parseFloat(m[4]) : 1;
    const blend = (c) => Math.round(c * a + 255 * (1 - a));
    return "#" + [blend(r), blend(g), blend(b)].map((c) => c.toString(16).padStart(2, "0")).join("");
  };
  return {
    primary: toHex(get("--primary")),
    primarySoft: toHex(get("--primary-soft")),
    text: toHex(get("--text")),
    border: toHex(get("--border")),
    surface: toHex(get("--surface")),
  };
};

const buildInitialSort = (params) => {
  const raw = params.get("sort");
  if (!raw) return { key: "No.", order: "desc" };
  const lastColonIndex = raw.lastIndexOf(":");
  if (lastColonIndex === -1) return { key: raw, order: "desc" };
  const key = raw.slice(0, lastColonIndex);
  const order = raw.slice(lastColonIndex + 1);
  return { key: key || "No.", order: order === "asc" ? "asc" : "desc" };
};

export default function SearchPage() {
  const { getFormById } = useAppData();
  const { settings } = useBuilderSettings();
  const { isAdmin, userEmail, formId: scopedFormId } = useAuth();
  const [searchParams, setSearchParams] = useSearchParams();
  const location = useLocation();
  const navigate = useNavigate();
  const { showAlert } = useAlert();
  const queryFormId = (searchParams.get("form") || "").trim();
  const effectiveFormId = queryFormId || scopedFormId;
  const isScopedByAuth = scopedFormId !== "";
  const [showDeleteConfirm, setShowDeleteConfirm] = useState({ open: false, entryIds: [] });
  const [selectedEntries, setSelectedEntries] = useState(new Set());
  const [exporting, setExporting] = useState(false);

  const form = useMemo(() => (effectiveFormId ? getFormById(effectiveFormId) : null), [effectiveFormId, getFormById]);
  const activeSort = useMemo(() => buildInitialSort(searchParams), [searchParams]);
  const query = searchParams.get("q") || "";
  const page = Math.max(1, Number(searchParams.get("page") || 1));
  const PAGE_SIZE = Number(settings?.pageSize) || DEFAULT_PAGE_SIZE;
  const TABLE_MAX_WIDTH = settings?.searchTableMaxWidth ? Number(settings.searchTableMaxWidth) : null;
  const cellDisplayLimit = parseSearchCellDisplayLimit(form?.settings?.searchCellMaxChars);

  const {
    entries,
    headerMatrix,
    loading,
    backgroundLoading,
    useCache,
    lastSyncedAt,
    cacheDisabled,
    fetchAndCacheData,
  } = useEntriesWithCache({
    formId: effectiveFormId,
    form,
    locationKey: location.key,
    locationState: location.state,
    showAlert,
  });

  const { columns, headerRows } = useMemo(
    () => buildSearchTableLayout(form, { headerMatrix, includeOperations: false }),
    [form, headerMatrix],
  );

  const handleSearchChange = (value) => {
    const next = new URLSearchParams(searchParams);
    if (value) next.set("q", value);
    else next.delete("q");
    next.set("page", "1");
    setSearchParams(next);
  };

  const handleSortToggle = (key) => {
    const next = new URLSearchParams(searchParams);
    const current = buildInitialSort(next);
    const order = current.key === key ? (current.order === "desc" ? "asc" : "desc") : "desc";
    next.set("sort", `${key}:${order}`);
    setSearchParams(next);
  };

  const handlePageChange = (nextPage) => {
    const next = new URLSearchParams(searchParams);
    next.set("page", String(nextPage));
    setSearchParams(next);
  };

  useEffect(() => {
    if (!form) return;
    const theme = form?.settings?.theme || DEFAULT_THEME;
    void applyThemeWithFallback(theme, { persist: false });
  }, [form?.id, form?.settings?.theme, settings?.theme]);

  const processedEntries = useMemo(() => entries.map((entry) => ({ entry, values: computeRowValues(entry, columns) })), [entries, columns]);

  const ownerFilteredEntries = useMemo(() => {
    if (isAdmin) return processedEntries;
    if (!form?.settings?.showOwnRecordsOnly) return processedEntries;
    if (!userEmail) return processedEntries;
    return processedEntries.filter((row) => (row.entry?.createdBy || row.entry?.modifiedBy) === userEmail);
  }, [processedEntries, isAdmin, userEmail, form?.settings?.showOwnRecordsOnly]);

  const filteredEntries = useMemo(() => {
    const keyword = query.trim();
    if (!keyword) return ownerFilteredEntries;
    return ownerFilteredEntries.filter((row) => matchesKeyword(row, columns, keyword));
  }, [ownerFilteredEntries, columns, query]);

  const sortedEntries = useMemo(() => {
    const list = filteredEntries.slice();
    const targetColumn = columns.find((column) => column.key === activeSort.key && column.sortable !== false);
    if (targetColumn) {
      list.sort((a, b) => compareByColumn(a, b, targetColumn, activeSort.order));
    }
    return list;
  }, [filteredEntries, columns, activeSort]);

  const pagedEntries = useMemo(() => {
    const start = (page - 1) * PAGE_SIZE;
    return sortedEntries.slice(start, start + PAGE_SIZE);
  }, [sortedEntries, page, PAGE_SIZE]);

  const totalPages = Math.max(1, Math.ceil(sortedEntries.length / PAGE_SIZE));
  const totalEntries = sortedEntries.length;
  const startIndex = totalEntries === 0 ? 0 : (page - 1) * PAGE_SIZE + 1;
  const endIndex = totalEntries === 0 ? 0 : Math.min(page * PAGE_SIZE, totalEntries);

  const badge = useMemo(() => {
    if (loading || backgroundLoading) return { label: "読み取り中...", variant: "loading" };
    return { label: "検索画面", variant: "view" };
  }, [loading, backgroundLoading]);

  const handleRowClick = (entryId) => {
    if (!effectiveFormId) return;
    const entryIds = sortedEntries.map((row) => row.entry.id);
    navigate(`/form/${effectiveFormId}/entry/${entryId}`, {
      state: { from: `${location.pathname}${location.search}`, entryIds },
    });
  };

  const handleCreateNew = () => {
    if (!effectiveFormId) return;
    navigate(`/form/${effectiveFormId}/new`, {
      state: { from: `${location.pathname}${location.search}` },
    });
  };

  const handleOpenFormConfig = () => {
    if (!effectiveFormId) return;
    navigate(`/config?form=${encodeURIComponent(effectiveFormId)}`, {
      state: { from: `${location.pathname}${location.search}` },
    });
  };

  const handleBackToMain = () => {
    navigate("/");
  };

  const toggleSelectEntry = (entryId) => {
    setSelectedEntries((prev) => {
      const next = new Set(prev);
      if (next.has(entryId)) next.delete(entryId);
      else next.add(entryId);
      return next;
    });
  };

  const selectAllEntries = (checked) => {
    if (checked) setSelectedEntries(new Set(pagedEntries.map((item) => item.entry.id)));
    else setSelectedEntries(new Set());
  };

  const handleDeleteSelected = () => {
    if (selectedEntries.size === 0) {
      showAlert("削除する項目を選択してください。");
      return;
    }
    setShowDeleteConfirm({ open: true, entryIds: Array.from(selectedEntries) });
  };

  const handleExportResults = useCallback(async () => {
    if (sortedEntries.length === 0) return;
    setExporting(true);
    try {
      const exportingEntries = sortedEntries.map((row) => row.entry);
      const exportTable = buildExportTableData({ form, entries: exportingEntries });
      const now = new Date();
      const pad = (n) => String(n).padStart(2, "0");
      const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
      const spreadsheetTitle = `検索結果_${form?.settings?.formTitle || form?.id || "form"}_${timestamp}`;
      const themeColors = getThemeColors();
      const result = await exportSearchResults({
        spreadsheetTitle,
        headerRows: exportTable.headerRows,
        rows: exportTable.rows,
        themeColors,
      });
      if (result?.spreadsheetUrl) {
        showAlert(
          React.createElement("span", null,
            `出力完了: ${result.exportedCount} 件を書き出しました。`,
            React.createElement("br"),
            React.createElement("a", {
              href: result.spreadsheetUrl,
              target: "_blank",
              rel: "noopener noreferrer",
              style: { color: "var(--accent-color, #1a73e8)", textDecoration: "underline" },
            }, "スプレッドシートを開く"),
          ),
        );
      } else {
        showAlert(`出力完了: ${result.exportedCount} 件を書き出しました。`);
      }
    } catch (err) {
      showAlert(`出力に失敗しました: ${err.message}`);
    } finally {
      setExporting(false);
    }
  }, [form, sortedEntries, showAlert]);

  const confirmDelete = useCallback(async () => {
    if (!effectiveFormId || showDeleteConfirm.entryIds.length === 0) return;
    for (const entryId of showDeleteConfirm.entryIds) {
      await dataStore.deleteEntry(effectiveFormId, entryId);
    }
    await fetchAndCacheData();
    setSelectedEntries(new Set());
    setShowDeleteConfirm({ open: false, entryIds: [] });
  }, [effectiveFormId, showDeleteConfirm.entryIds, fetchAndCacheData]);

  if (!effectiveFormId || !form) {
    return (
      <AppLayout themeOverride={form?.settings?.theme} title="検索" fallbackPath="/" backHidden={false}>
        <p className="search-empty">
          {isAdmin
            ? "フォームが選択されていません。メイン画面からフォームを選択してください。"
            : "フォームが見つかりません。正しいURLでアクセスしているか確認してください。"}
        </p>
      </AppLayout>
    );
  }

  return (
    <AppLayout themeOverride={form?.settings?.theme}       title={`検索 - ${form.settings?.formTitle || "(無題)"}`}
      fallbackPath="/"
      backHidden
      badge={badge}
      sidebarActions={(
        <SearchSidebar
          onBack={handleBackToMain}
          showBack={!isScopedByAuth}
          onCreate={handleCreateNew}
          onConfig={settings?.syncAllFormsTheme ? undefined : handleOpenFormConfig}
          onDelete={handleDeleteSelected}
          onRefresh={fetchAndCacheData}
          onExport={handleExportResults}
          useCache={useCache}
          loading={loading}
          exporting={exporting}
          selectedCount={selectedEntries.size}
          filteredCount={sortedEntries.length}
        />
      )}
    >
      <SearchToolbar
        query={query}
        onChange={handleSearchChange}
        lastSyncedAt={lastSyncedAt}
        useCache={useCache}
        cacheDisabled={cacheDisabled}
      />

      {loading ? (
        <p className="search-loading">読み込み中...</p>
      ) : (
        <SearchTable
          columns={columns}
          headerRows={headerRows}
          pagedEntries={pagedEntries}
          selectedEntries={selectedEntries}
          activeSort={activeSort}
          cellDisplayLimit={cellDisplayLimit}
          tableMaxWidth={TABLE_MAX_WIDTH}
          onSortToggle={handleSortToggle}
          onSelectAll={selectAllEntries}
          onToggleSelect={toggleSelectEntry}
          onRowClick={handleRowClick}
        />
      )}

      <SearchPagination
        page={page}
        totalPages={totalPages}
        totalEntries={totalEntries}
        startIndex={startIndex}
        endIndex={endIndex}
        onChange={handlePageChange}
      />

      <ConfirmDialog
        open={showDeleteConfirm.open}
        title="レコードを削除"
        message={`選択した${showDeleteConfirm.entryIds.length}件の回答を削除します。よろしいですか？`}
        options={[
          { label: "キャンセル", value: "cancel", onSelect: () => setShowDeleteConfirm({ open: false, entryIds: [] }) },
          { label: "削除", value: "delete", variant: "danger", onSelect: confirmDelete },
        ]}
      />

</AppLayout>
  );
}



================================================
FILE: builder/src/services/gasClient.js
================================================
import { normalizeSpreadsheetId } from "../utils/spreadsheet.js";

export const hasScriptRun = () =>
  typeof google !== "undefined" &&
  google?.script?.run;

const normalizeScriptRunError = (err) => {
  if (err instanceof Error) return err;
  if (typeof err === "string") return new Error(err);
  if (err && typeof err.message === "string") return new Error(err.message);
  try {
    return new Error(JSON.stringify(err) || "Apps Script call failed");
  } catch (jsonErr) {
    return new Error("Apps Script call failed");
  }
};

const callScriptRun = (functionName, payload) =>
  new Promise((resolve, reject) => {
    if (!hasScriptRun()) {
      reject(new Error("この機能はGoogle Apps Script環境でのみ利用可能です"));
      return;
    }
    google.script.run
      .withSuccessHandler((result) => resolve(result))
      .withFailureHandler((error) => reject(normalizeScriptRunError(error)))[functionName](payload);
  });

export const validateSpreadsheet = async (spreadsheetIdOrUrl) => {
  if (!spreadsheetIdOrUrl) {
    throw new Error("Spreadsheet URL/ID is required");
  }
  const result = await callScriptRun("nfbValidateSpreadsheet", spreadsheetIdOrUrl);
  if (!result || result.ok === false) {
    throw new Error(result?.error || "Spreadsheet validation failed");
  }
  return result;
};


export const submitResponses = async ({ spreadsheetId, sheetName = "Data", payload }) => {
  if (!spreadsheetId) throw new Error("spreadsheetId is required");

  const body = { ...(payload || {}), spreadsheetId, sheetName };
  const result = await callScriptRun("saveResponses", body);
  if (!result || result.ok === false) {
    throw new Error(result?.error || "Apps Script call failed");
  }
  return result;
};

export const deleteEntry = async ({ spreadsheetId, sheetName = "Data", entryId }) => {
  if (!spreadsheetId) throw new Error("spreadsheetId is required");
  if (!entryId) throw new Error("entryId is required");

  const cleanSpreadsheetId = normalizeSpreadsheetId(spreadsheetId);

  const payload = {
    spreadsheetId: cleanSpreadsheetId,
    sheetName,
    id: entryId,
  };

  const result = await callScriptRun("deleteRecord", payload);
  if (!result || result.ok === false) {
    throw new Error(result?.error || "Delete failed");
  }
  return result;
};

export const getEntry = async ({ spreadsheetId, sheetName = "Data", entryId, rowIndexHint = null }) => {
  if (!spreadsheetId) throw new Error("spreadsheetId is required");
  if (!entryId) throw new Error("entryId is required");

  const cleanSpreadsheetId = normalizeSpreadsheetId(spreadsheetId);

  const payload = {
    spreadsheetId: cleanSpreadsheetId,
    sheetName,
    id: entryId,
    rowIndexHint,
  };

  const result = await callScriptRun("getRecord", payload);
  if (!result || result.ok === false) {
    throw new Error(result?.error || "Get record failed");
  }
  return {
    record: result.record || null,
    rowIndex: typeof result.rowIndex === "number" ? result.rowIndex : null,
  };
};

export const exportSearchResults = async ({ spreadsheetTitle = "", headerRows, rows, themeColors = null }) => {
  if (!Array.isArray(headerRows) || headerRows.length === 0) throw new Error("headerRows is required");
  if (!Array.isArray(rows)) throw new Error("rows must be an array");

  const CHUNK_SIZE = 100;
  const firstChunk = rows.slice(0, CHUNK_SIZE);

  const result = await callScriptRun("nfbExportSearchResults", {
    spreadsheetTitle,
    headerRows,
    rows: firstChunk,
    themeColors,
  });
  if (!result || result.ok === false) {
    throw new Error(result?.error || "Export failed");
  }

  const headerCount = result.headerCount || headerRows.length;
  for (let i = CHUNK_SIZE; i < rows.length; i += CHUNK_SIZE) {
    const chunk = rows.slice(i, i + CHUNK_SIZE);
    const appendResult = await callScriptRun("nfbAppendExportRows", {
      spreadsheetId: result.spreadsheetId,
      rows: chunk,
      themeColors,
      headerCount,
      rowOffset: i,
    });
    if (!appendResult || appendResult.ok === false) {
      throw new Error(appendResult?.error || "Append chunk failed");
    }
  }

  return { ...result, exportedCount: rows.length };
};

export const listEntries = async ({ spreadsheetId, sheetName = "Data", formId = null }) => {
  if (!spreadsheetId) throw new Error("spreadsheetId is required");

  const cleanSpreadsheetId = normalizeSpreadsheetId(spreadsheetId);

  const payload = {
    spreadsheetId: cleanSpreadsheetId,
    sheetName,
  };
  if (formId) {
    payload.formId = formId;
  }

  const result = await callScriptRun("listRecords", payload);
  if (!result || result.ok === false) {
    console.error("[gasClient] Result validation failed - result:", result);
    throw new Error(result?.error || "データ一覧の取得に失敗しました");
  }
  return {
    records: result.records || [],
    headerMatrix: result.headerMatrix || []
  };
};

// ========================================
// Form Management APIs (Google Drive)
// ========================================

/**
 * フォーム管理API呼び出しの共通ヘルパー
 * @param {string} functionName - GAS関数名
 * @param {*} args - 引数
 * @param {string} errorMessage - エラーメッセージ
 * @returns {Promise<*>} - API結果
 */
const callFormApi = async (functionName, args, errorMessage) => {
  if (!hasScriptRun()) {
    throw new Error("Form management is only available in google.script.run environment");
  }

  try {
    const result = await callScriptRun(functionName, args);
    if (!result || result.ok === false) {
      throw new Error(result?.error || errorMessage);
    }
    return result;
  } catch (error) {
    console.error(`[gasClient] ${functionName} failed`, error);
    throw error;
  }
};

export const listForms = async (options = {}) => {
  const result = await callFormApi("nfbListForms", options, "List forms failed");
  return {
    forms: result.forms || [],
    loadFailures: result.loadFailures || [],
  };
};

export const getForm = async (formId) => {
  if (!formId) throw new Error("formId is required");
  const result = await callFormApi("nfbGetForm", formId, "Get form failed");
  return result.form || null;
};

export const saveForm = async (form, targetUrl = null, saveMode = "auto") => {
  if (!form || !form.id) throw new Error("Form with ID is required");
  const payload = { form, targetUrl, saveMode };
  const result = await callFormApi("nfbSaveForm", payload, "Save form failed");
  return { form: result.form, fileUrl: result.fileUrl };
};

export const deleteFormFromDrive = async (formId) => {
  if (!formId) throw new Error("formId is required");
  return await callFormApi("nfbDeleteForm", formId, "Delete form failed");
};

export const deleteFormsFromDrive = async (formIds) => {
  if (!Array.isArray(formIds) || formIds.length === 0) {
    throw new Error("formIds array is required");
  }
  const result = await callScriptRun("nfbDeleteForms", formIds);
  if (!result) {
    throw new Error("Batch delete forms failed");
  }

  const deleted = Number.isFinite(result.deleted) ? result.deleted : Number(result.deleted) || 0;
  if (result.ok === false && deleted === 0) {
    throw new Error(result?.error || "Batch delete forms failed");
  }

  return result;
};

export const archiveForm = async (formId) => {
  if (!formId) throw new Error("formId is required");
  const result = await callFormApi("nfbArchiveForm", formId, "Archive form failed");
  return result.form || null;
};

export const unarchiveForm = async (formId) => {
  if (!formId) throw new Error("formId is required");
  const result = await callFormApi("nfbUnarchiveForm", formId, "Unarchive form failed");
  return result.form || null;
};

export const archiveForms = async (formIds) => {
  if (!Array.isArray(formIds) || formIds.length === 0) {
    throw new Error("formIds array is required");
  }
  return await callFormApi("nfbArchiveForms", formIds, "Batch archive forms failed");
};

export const unarchiveForms = async (formIds) => {
  if (!Array.isArray(formIds) || formIds.length === 0) {
    throw new Error("formIds array is required");
  }
  return await callFormApi("nfbUnarchiveForms", formIds, "Batch unarchive forms failed");
};

export const importFormsFromDrive = async (url) => {
  if (!url) throw new Error("Google Drive URL is required");
  const result = await callFormApi("nfbImportFormsFromDrive", url, "Import from Drive failed");
  return {
    forms: result.forms || [],
    skipped: result.skipped || 0,
    parseFailed: result.parseFailed || 0,
    totalFiles: result.totalFiles || 0,
  };
};

export const registerImportedForm = async (payload) => {
  if (!payload || !payload.form || !payload.fileId) {
    throw new Error("form and fileId are required");
  }
  return await callFormApi("nfbRegisterImportedForm", payload, "Register imported form failed");
};

export const importThemeFromDrive = async (url) => {
  if (!url) throw new Error("Google Drive URL is required");
  const result = await callScriptRun("nfbImportThemeFromDrive", url);
  if (!result || result.ok === false) {
    throw new Error(result?.error || "Theme import failed");
  }
  return {
    css: result.css || "",
    fileName: result.fileName || "",
    fileUrl: result.fileUrl || url,
  };
};

export const debugGetMapping = async () => {
  try {
    const result = await callScriptRun("nfbDebugGetMapping", {});
    if (!result || result.ok === false) {
      throw new Error(result?.error || "Debug get mapping failed");
    }
    return result;
  } catch (error) {
    console.error(`[gasClient] debugGetMapping failed`, error);
    throw error;
  }
};

// ========================================
// 管理者設定API
// ========================================

/**
 * 管理者キーを取得する
 * @returns {Promise<string>} 管理者キー
 */
export const getAdminKey = async () => {
  const result = await callScriptRun("nfbGetAdminKey", {});
  if (!result || result.ok === false) {
    throw new Error(result?.error || "Get admin key failed");
  }
  return result.adminKey || "";
};

/**
 * 管理者キーを設定する
 * @param {string} newKey - 新しい管理者キー（空文字で認証無効化）
 * @returns {Promise<string>} 設定後の管理者キー
 */
export const setAdminKey = async (newKey) => {
  const result = await callScriptRun("nfbSetAdminKey", newKey);
  if (!result || result.ok === false) {
    throw new Error(result?.error || "Set admin key failed");
  }
  return result.adminKey || "";
};

/**
 * 管理者メールを取得する
 * @returns {Promise<string>} 管理者メール（";"区切り）
 */
export const getAdminEmail = async () => {
  const result = await callScriptRun("nfbGetAdminEmail", {});
  if (!result || result.ok === false) {
    throw new Error(result?.error || "Get admin email failed");
  }
  return result.adminEmail || "";
};

/**
 * 管理者メールを設定する
 * @param {string} newEmail - 新しい管理者メール（";"区切り）
 * @returns {Promise<string>} 設定後の管理者メール（";"区切り）
 */
export const setAdminEmail = async (newEmail) => {
  const result = await callScriptRun("nfbSetAdminEmail", newEmail);
  if (!result || result.ok === false) {
    throw new Error(result?.error || "Set admin email failed");
  }
  return result.adminEmail || "";
};

/**
 * 個別フォーム限定フラグを取得する
 * @returns {Promise<boolean>}
 */
export const getRestrictToFormOnly = async () => {
  const result = await callScriptRun("nfbGetRestrictToFormOnly", {});
  if (!result || result.ok === false) {
    throw new Error(result?.error || "Get restrict to form only failed");
  }
  return Boolean(result.restrictToFormOnly);
};

/**
 * 個別フォーム限定フラグを設定する
 * @param {boolean} value
 * @returns {Promise<boolean>} 設定後の値
 */
export const setRestrictToFormOnly = async (value) => {
  const result = await callScriptRun("nfbSetRestrictToFormOnly", value);
  if (!result || result.ok === false) {
    throw new Error(result?.error || "Set restrict to form only failed");
  }
  return Boolean(result.restrictToFormOnly);
};



================================================
FILE: builder/src/utils/dateTime.js
================================================
import { MS_PER_DAY, SERIAL_EPOCH_UTC_MS, JST_OFFSET_MS } from "../core/constants.js";

const TIME_ZONE = "Asia/Tokyo";
const DEFAULT_LOCALE = "ja-JP";
const SERIAL_EPOCH_JST_MS = SERIAL_EPOCH_UTC_MS - JST_OFFSET_MS;

const pad2 = (value) => String(value).padStart(2, "0");

const isValidDate = (d) => d instanceof Date && !Number.isNaN(d.getTime());

const isProbablyUnixMs = (value) => Math.abs(value) >= 100000000000;

const unixMsToSerial = (unixMs) => (unixMs - SERIAL_EPOCH_JST_MS) / MS_PER_DAY;
const serialToUnixMs = (serial) => SERIAL_EPOCH_JST_MS + serial * MS_PER_DAY;

const buildUtcSerial = (year, month, day, hour, minute, second) => {
  const utcMs = Date.UTC(year, month, day, hour || 0, minute || 0, second || 0);
  const date = new Date(utcMs);
  if (
    date.getUTCFullYear() !== year ||
    date.getUTCMonth() !== month ||
    date.getUTCDate() !== day ||
    date.getUTCHours() !== (hour || 0) ||
    date.getUTCMinutes() !== (minute || 0) ||
    date.getUTCSeconds() !== (second || 0)
  ) {
    return null;
  }
  return (utcMs - SERIAL_EPOCH_UTC_MS) / MS_PER_DAY;
};

export const parseStringToSerial = (value) => {
  if (typeof value !== "string") return null;
  const str = value.trim();
  if (!str) return null;

  // ISO（タイムゾーン付き/なし）
  if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(str)) {
    const iso = new Date(str);
    return isValidDate(iso) ? unixMsToSerial(iso.getTime()) : null;
  }

  // YYYY-MM-DD[/ ]HH:MM[:SS]
  const dt = str.match(/^(\d{4})-(\d{2})-(\d{2})(?:[\/\s]+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
  if (dt) {
    const year = parseInt(dt[1], 10);
    const month = parseInt(dt[2], 10);
    const day = parseInt(dt[3], 10);
    const hour = dt[4] ? parseInt(dt[4], 10) : 0;
    const minute = dt[5] ? parseInt(dt[5], 10) : 0;
    const second = dt[6] ? parseInt(dt[6], 10) : 0;
    if (month < 1 || month > 12 || day < 1 || day > 31) return null;
    if (hour < 0 || hour > 23 || minute < 0 || minute > 59 || second < 0 || second > 59) return null;
    return buildUtcSerial(year, month - 1, day, hour, minute, second);
  }

  // HH:MM[:SS] （基準日: 1899-12-30）
  const t = str.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
  if (t) {
    const hour = parseInt(t[1], 10);
    const minute = parseInt(t[2], 10);
    const second = t[3] ? parseInt(t[3], 10) : 0;
    if (hour < 0 || hour > 23 || minute < 0 || minute > 59 || second < 0 || second > 59) return null;
    return buildUtcSerial(1899, 11, 30, hour, minute, second);
  }

  if (/^[-+]?\d+(?:\.\d+)?$/.test(str)) {
    const numeric = Number(str);
    if (!Number.isFinite(numeric)) return null;
    return isProbablyUnixMs(numeric) ? unixMsToSerial(numeric) : numeric;
  }

  return null;
};

export const toUnixMs = (value) => {
  if (value === null || value === undefined) return null;
  if (typeof value === "number" && Number.isFinite(value)) {
    return isProbablyUnixMs(value) ? unixMsToSerial(value) : value;
  }
  if (value instanceof Date) return unixMsToSerial(value.getTime());
  const parsed = parseStringToSerial(String(value));
  return Number.isFinite(parsed) ? parsed : null;
};

const buildFormatter = (options) => new Intl.DateTimeFormat(DEFAULT_LOCALE, { timeZone: TIME_ZONE, hour12: false, ...options });

const normalizeSerialForFormat = (value) => {
  if (!Number.isFinite(value)) return null;
  const serial = isProbablyUnixMs(value) ? unixMsToSerial(value) : value;
  return serialToUnixMs(serial);
};

const formatFromParts = (formatter, serial) => {
  const unixMs = normalizeSerialForFormat(serial);
  if (!Number.isFinite(unixMs)) return "";
  try {
    const parts = formatter.formatToParts(new Date(unixMs));
    const get = (type) => parts.find((p) => p.type === type)?.value || "";
    const yyyy = get("year");
    const mm = get("month");
    const dd = get("day");
    const hh = get("hour");
    const mi = get("minute");
    if (hh !== "" && mi !== "") {
      return `${yyyy}-${mm}-${dd}/${hh}:${mi}`;
    }
    return `${yyyy}-${mm}-${dd}`;
  } catch (error) {
    return "";
  }
};

const formatterDateTime = buildFormatter({ year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit" });
const formatterDate = buildFormatter({ year: "numeric", month: "2-digit", day: "2-digit" });
const formatterTime = buildFormatter({ hour: "2-digit", minute: "2-digit" });

export const formatUnixMsDateTime = (unixMs) => formatFromParts(formatterDateTime, unixMs);
export const formatUnixMsDate = (unixMs) => formatFromParts(formatterDate, unixMs);
export const formatUnixMsTime = (unixMs) => {
  const normalized = normalizeSerialForFormat(unixMs);
  if (!Number.isFinite(normalized)) return "";
  try {
    const parts = formatterTime.formatToParts(new Date(normalized));
    const get = (type) => parts.find((p) => p.type === type)?.value || "";
    const hh = get("hour");
    const mi = get("minute");
    return hh && mi ? `${pad2(hh)}:${pad2(mi)}` : "";
  } catch (error) {
    return "";
  }
};



================================================
FILE: builder/src/utils/deepEqual.js
================================================
export const deepEqual = (a, b) => {
  if (a === b) return true;
  if (Number.isNaN(a) && Number.isNaN(b)) return true;
  if (typeof a !== typeof b) return false;
  if (a === null || b === null) return false;

  if (Array.isArray(a)) {
    if (!Array.isArray(b) || a.length !== b.length) return false;
    return a.every((val, i) => deepEqual(val, b[i]));
  }

  if (typeof a === "object") {
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    if (keysA.length !== keysB.length) return false;
    return keysA.every((key) => Object.prototype.hasOwnProperty.call(b, key) && deepEqual(a[key], b[key]));
  }

  return false;
};



================================================
FILE: builder/src/utils/formNormalize.js
================================================
import { computeSchemaHash } from "../core/schema.js";
import { genId } from "../core/ids.js";
import { collectDisplayFieldSettings } from "./formPaths.js";
import { toUnixMs } from "./dateTime.js";

const defaultNowFn = () => toUnixMs(Date.now());

const resolveNow = (nowFn) => {
  const value = typeof nowFn === "function" ? nowFn() : defaultNowFn();
  return Number.isFinite(value) ? value : defaultNowFn();
};

const resolveCreatedAt = (source, fallbackCreatedAt, now) => {
  const createdAt = Number.isFinite(source?.createdAt)
    ? source.createdAt
    : (Number.isFinite(source?.createdAtUnixMs) ? source.createdAtUnixMs : toUnixMs(source?.createdAt));
  if (Number.isFinite(createdAt)) return createdAt;

  const fallback = toUnixMs(fallbackCreatedAt);
  if (Number.isFinite(fallback)) return fallback;

  return now;
};

export const normalizeFormRecord = (source = {}, options = {}) => {
  const { fallbackId = genId(), fallbackCreatedAt = undefined, nowFn = defaultNowFn, preserveUnknownFields = false } = options;
  const now = resolveNow(nowFn);
  const schema = Array.isArray(source.schema) ? source.schema : [];
  const displayFieldSettings = collectDisplayFieldSettings(schema);
  const createdAt = resolveCreatedAt(source, fallbackCreatedAt, now);
  const settings =
    source.settings && typeof source.settings === "object" && !Array.isArray(source.settings)
      ? { ...source.settings }
      : {};
  const base = preserveUnknownFields ? { ...source } : {};

  if (!settings.formTitle) {
    settings.formTitle = source.name || "無題のフォーム";
  }

  return {
    ...base,
    id: source.id || fallbackId,
    description: source.description || "",
    schema,
    settings,
    schemaHash: computeSchemaHash(schema),
    importantFields: displayFieldSettings.map((item) => item.path),
    displayFieldSettings,
    createdAt,
    modifiedAt: now,
    createdAtUnixMs: createdAt,
    modifiedAtUnixMs: now,
    archived: !!source.archived,
    schemaVersion: Number.isFinite(source.schemaVersion) ? source.schemaVersion : 1,
  };
};



================================================
FILE: builder/src/utils/formPaths.js
================================================
import { resolveIsDisplayed } from "../core/displayModes.js";
import { traverseSchema } from "../core/schemaUtils.js";

export const collectDisplayFieldSettings = (schema) => {
  const collected = [];

  traverseSchema(schema, (field, context) => {
    if (resolveIsDisplayed(field)) {
      collected.push({
        path: context.pathSegments.join("|"),
        type: field.type || "",
      });
    }
  });

  return collected.sort((a, b) => String(a?.path || "").localeCompare(String(b?.path || ""), "ja"));
};

export const splitFieldPath = (path) => {
  if (!path) return [];
  return String(path)
    .split("|")
    .map((part) => part.trim())
    .filter((part) => part);
};



================================================
FILE: builder/src/utils/perfLogger.js
================================================
/**
 * パフォーマンス計測とサマリー出力
 */

const resolveDefaultVerbose = () => {
  try {
    return Boolean(import.meta?.env?.DEV);
  } catch {
    return false;
  }
};

class PerformanceLogger {
  constructor({ verbose = resolveDefaultVerbose() } = {}) {
    this.verbose = !!verbose;
    this.autoSummaryTimer = null;
    this.reset();
  }

  setVerbose(enabled) {
    this.verbose = !!enabled;
  }

  isVerbose() {
    return this.verbose;
  }

  logVerbose(scope, message, payload) {
    if (!this.verbose) return;
    const prefix = scope ? `[perf][${scope}]` : "[perf]";
    if (payload === undefined) {
      console.log(`${prefix} ${message}`);
      return;
    }
    console.log(`${prefix} ${message}`, payload);
  }

  reset() {
    this.stats = {
      forms: {
        gasReads: [],
        cacheSaves: [],
        cacheHits: [],
      },
      records: {
        gasReads: [],
        cacheHits: [],
        cacheUpdates: [],
        listOperations: [],
      },
    };
  }

  // フォーム取得のGAS読み取り
  logFormGasRead(durationMs, count = 1) {
    this.stats.forms.gasReads.push({ durationMs, count, timestamp: Date.now() });
  }

  // フォームキャッシュ保存
  logFormCacheSave(durationMs, count = 1) {
    this.stats.forms.cacheSaves.push({ durationMs, count, timestamp: Date.now() });
  }

  // フォームキャッシュヒット
  logFormCacheHit(durationMs, count = 1) {
    this.stats.forms.cacheHits.push({ durationMs, count, timestamp: Date.now() });
  }

  // レコード取得のGAS読み取り
  logRecordGasRead(durationMs, entryId = null, operationType = "single") {
    this.stats.records.gasReads.push({ durationMs, entryId, operationType, timestamp: Date.now() });
  }

  // レコードキャッシュヒット
  logRecordCacheHit(durationMs, entryId = null) {
    this.stats.records.cacheHits.push({ durationMs, entryId, timestamp: Date.now() });
  }

  // レコードキャッシュ更新
  logRecordCacheUpdate(durationMs, entryId = null) {
    this.stats.records.cacheUpdates.push({ durationMs, entryId, timestamp: Date.now() });
  }

  // レコード一覧取得
  logRecordList(durationMs, count, fromCache = false) {
    this.stats.records.listOperations.push({ durationMs, count, fromCache, timestamp: Date.now() });
  }

  // 統計計算ヘルパー
  calculateStats(items, durationKey = "durationMs") {
    if (!items || items.length === 0) {
      return { count: 0, total: 0, avg: 0, min: 0, max: 0 };
    }
    const durations = items.map((item) => item[durationKey] || 0);
    const total = durations.reduce((sum, d) => sum + d, 0);
    return {
      count: items.length,
      total: Math.round(total),
      avg: Math.round(total / items.length),
      min: Math.round(Math.min(...durations)),
      max: Math.round(Math.max(...durations)),
    };
  }

  // サマリー出力
  printSummary({ force = false } = {}) {
    if (!force && !this.verbose) return;
    console.log("\n");
    console.log("╔════════════════════════════════════════════════════════╗");
    console.log("║        📊 パフォーマンスサマリー                      ║");
    console.log("╠════════════════════════════════════════════════════════╣");

    // フォーム操作
    const formGasStats = this.calculateStats(this.stats.forms.gasReads);
    const formCacheSaveStats = this.calculateStats(this.stats.forms.cacheSaves);
    const formCacheHitStats = this.calculateStats(this.stats.forms.cacheHits);

    if (formGasStats.count > 0 || formCacheHitStats.count > 0) {
      console.log("║ 📁 フォーム取得                                        ║");
      if (formGasStats.count > 0) {
        console.log(`║   ⚡ GAS読み取り: ${formGasStats.count}回 (合計 ${formGasStats.total}ms, 平均 ${formGasStats.avg}ms)`);
      }
      if (formCacheSaveStats.count > 0) {
        console.log(`║   💾 キャッシュ保存: ${formCacheSaveStats.count}回 (合計 ${formCacheSaveStats.total}ms)`);
      }
      if (formCacheHitStats.count > 0) {
        console.log(`║   ✅ キャッシュヒット: ${formCacheHitStats.count}回 (合計 ${formCacheHitStats.total}ms, 平均 ${formCacheHitStats.avg}ms)`);
      }
      console.log("╠════════════════════════════════════════════════════════╣");
    }

    // レコード操作
    const recordGasStats = this.calculateStats(this.stats.records.gasReads);
    const recordCacheHitStats = this.calculateStats(this.stats.records.cacheHits);
    const recordCacheUpdateStats = this.calculateStats(this.stats.records.cacheUpdates);
    const recordListStats = this.calculateStats(this.stats.records.listOperations);

    if (recordGasStats.count > 0 || recordCacheHitStats.count > 0 || recordListStats.count > 0) {
      console.log("║ 📝 レコード操作                                        ║");
      if (recordCacheHitStats.count > 0) {
        console.log(`║   ✅ キャッシュヒット: ${recordCacheHitStats.count}回 (合計 ${recordCacheHitStats.total}ms, 平均 ${recordCacheHitStats.avg}ms)`);
      }
      if (recordGasStats.count > 0) {
        console.log(`║   ⚡ GAS読み取り: ${recordGasStats.count}回 (合計 ${recordGasStats.total}ms, 平均 ${recordGasStats.avg}ms)`);
      }
      if (recordCacheUpdateStats.count > 0) {
        console.log(`║   💾 キャッシュ更新: ${recordCacheUpdateStats.count}回 (合計 ${recordCacheUpdateStats.total}ms, 平均 ${recordCacheUpdateStats.avg}ms)`);
      }
      if (recordListStats.count > 0) {
        console.log(`║   📋 一覧取得: ${recordListStats.count}回 (合計 ${recordListStats.total}ms, 平均 ${recordListStats.avg}ms)`);
      }
      console.log("╠════════════════════════════════════════════════════════╣");
    }

    // 合計
    const totalGasTime = formGasStats.total + recordGasStats.total;
    const totalCacheTime = formCacheSaveStats.total + formCacheHitStats.total + recordCacheHitStats.total + recordCacheUpdateStats.total;
    const totalGasCount = formGasStats.count + recordGasStats.count;
    const totalCacheCount = formCacheSaveStats.count + formCacheHitStats.count + recordCacheHitStats.count + recordCacheUpdateStats.count;
    const cacheEfficiency = totalGasCount + totalCacheCount > 0 ? Math.round((totalCacheCount / (totalGasCount + totalCacheCount)) * 100) : 0;

    console.log("║ 🎯 合計                                                ║");
    console.log(`║   GAS呼び出し: ${totalGasCount}回 (${totalGasTime}ms)`);
    console.log(`║   キャッシュ操作: ${totalCacheCount}回 (${totalCacheTime}ms)`);
    console.log(`║   キャッシュ効率: ${cacheEfficiency}%`);
    if (totalGasTime > 0 && totalCacheTime > 0) {
      const speedup = Math.round((totalGasTime / totalCacheTime) * 10) / 10;
      console.log(`║   高速化率: ${speedup}倍`);
    }
    console.log("╚════════════════════════════════════════════════════════╝");
    console.log("\n");
  }

  // ショートカット: 定期的にサマリー出力
  enableAutoSummary(intervalMs = 30000) {
    if (this.autoSummaryTimer) {
      clearInterval(this.autoSummaryTimer);
      this.autoSummaryTimer = null;
    }
    if (!this.verbose) {
      return;
    }
    this.autoSummaryTimer = setInterval(() => {
      this.printSummary();
    }, intervalMs);
  }

  disableAutoSummary() {
    if (this.autoSummaryTimer) {
      clearInterval(this.autoSummaryTimer);
      this.autoSummaryTimer = null;
    }
  }
}

// グローバルインスタンス
export const perfLogger = new PerformanceLogger();

// グローバルからアクセス可能にする
if (typeof window !== "undefined") {
  window.perfLogger = perfLogger;
  window.showPerfSummary = () => perfLogger.printSummary({ force: true });
  perfLogger.logVerbose("logger", "window.showPerfSummary() でサマリーを表示できます");
}

// 開発時に自動サマリーを有効化
if (typeof window !== "undefined" && (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1")) {
  perfLogger.enableAutoSummary(60000); // 1分ごと
  perfLogger.logVerbose("logger", "自動サマリーを有効化しました（60秒間隔）");
}



================================================
FILE: builder/src/utils/responses.js
================================================
import { formatUnixMsDate, formatUnixMsTime, toUnixMs } from "./dateTime.js";
import { deepEqual } from "./deepEqual.js";
import { traverseSchema } from "../core/schemaUtils.js";

const normalizeTemporalValue = (field, rawValue, unixMsValue) => {
  if (field.type !== "time" && field.type !== "date") return rawValue;

  const unixMs = Number.isFinite(unixMsValue) ? unixMsValue : toUnixMs(rawValue);
  if (!Number.isFinite(unixMs)) return rawValue;

  return field.type === "time" ? formatUnixMsTime(unixMs) : formatUnixMsDate(unixMs);
};

export const restoreResponsesFromData = (schema, data = {}, dataUnixMs = {}) => {
  const responses = {};

  traverseSchema(schema, (field, context) => {
    const baseKey = context.pathSegments.join("|");

    if (field.type === "checkboxes") {
      const values = [];
      (field.options || []).forEach((opt) => {
        const key = opt.label ? `${baseKey}|${opt.label}` : baseKey;
        if (data[key]) values.push(opt.label);
      });
      if (values.length) Object.assign(responses, { [field.id]: values });
    } else if (["radio", "select"].includes(field.type)) {
      let selected = null;
      (field.options || []).forEach((opt) => {
        const key = opt.label ? `${baseKey}|${opt.label}` : baseKey;
        if (data[key]) selected = opt.label;
      });
      if (selected) Object.assign(responses, { [field.id]: selected });
    } else {
      const normalized = normalizeTemporalValue(field, data[baseKey], dataUnixMs[baseKey]);
      if (normalized !== undefined && normalized !== null) {
        Object.assign(responses, { [field.id]: normalized });
      }
    }
  }, {
    getChildKeys: (field) => {
      const value = responses[field.id];
      if (field.type === "checkboxes" && Array.isArray(value)) {
        return value.filter(k => Object.prototype.hasOwnProperty.call(field.childrenByValue, k));
      } else if (["radio", "select"].includes(field.type) && typeof value === "string" && value) {
        return field.childrenByValue[value] ? [value] : [];
      }
      return [];
    }
  });

  return responses;
};

export const collectDefaultNowResponses = (schema, now = new Date(), options = {}) => {
  const defaults = {};
  const dateValue = formatUnixMsDate(now.getTime());
  const timeValue = formatUnixMsTime(now.getTime());
  const userName = typeof options?.userName === "string" ? options.userName : "";
  const userEmail = typeof options?.userEmail === "string" ? options.userEmail : "";

  traverseSchema(schema, (field) => {
    if (["date", "time"].includes(field?.type) && field?.defaultNow && field?.id) {
      defaults[field.id] = field.type === "date" ? dateValue : timeValue;
    }
    if (field?.type === "userName" && field?.defaultNow && field?.id && userName) {
      defaults[field.id] = userName;
    }
    if (field?.type === "email" && field?.defaultNow && field?.id && userEmail) {
      defaults[field.id] = userEmail;
    }
  });

  return defaults;
};

export const hasDirtyChanges = (a, b) => {
  return !deepEqual(a || {}, b || {});
};



================================================
FILE: builder/src/utils/settings.js
================================================
/**
 * settings オブジェクトから theme プロパティを除外する
 * @param {object} settings
 * @returns {object}
 */
export const omitThemeSetting = (settings) => {
  if (!settings || typeof settings !== "object") return {};
  const { theme, ...rest } = settings;
  return rest;
};



================================================
FILE: builder/src/utils/spreadsheet.js
================================================
export const normalizeSpreadsheetId = (input = "") => {
  const s = String(input).trim();
  if (/^https?:\/\//i.test(s)) {
    const idMatch = s.match(/\/d\/([a-zA-Z0-9-_]+)/);
    return idMatch?.[1] || s.match(/[?&]key=([a-zA-Z0-9-_]+)/)?.[1] || s;
  }
  return s;
};



================================================
FILE: gas/README.md
================================================
# GAS Web アプリケーション

生成したフォーム HTML からの POST を受け取り、Google スプレッドシートへ回答を追記する Apps Script プロジェクトです。`clasp` と `deploy.sh` を利用してデプロイできます。

## ディレクトリ構成

- `appsscript.json` – プロジェクトのマニフェスト
- `Code.gs` – `doGet/doPost` エントリポイントと CORS / API ルーティング
- `model.gs` – リクエストボディのパースと初期バリデーション
- `sheets.gs` – スプレッドシート行の作成・ヘッダー管理
- `forms.gs` – フォーム一覧/作成/更新/削除 API
- `drive.gs` – Google Drive のファイル操作
- `properties.gs` – スクリプト/ユーザープロパティ操作
- `settings.gs` – ユーザー設定の保存/取得
- `scripts/bundle.js` – `gas/*.gs` を `dist/Bundle.gs` に結合するスクリプト

## 初期セットアップ

1. Google Apps Script で新規プロジェクトを作成し、`scriptId` を取得します。
2. リポジトリ直下で `.clasp.json` を設定し、`rootDir` を `dist/` に指定します（現状の設定も `dist`）。
3. `npm install` で `@google/clasp` を取得（または `npm install --global @google/clasp`）
4. `npm run clasp:login`
5. `clasp push` でスクリプトファイルをアップロード（`dist/` 配下が対象）

## スプレッドシートの指定

POST ボディ、もしくはクエリパラメータで以下を指定してください。

- `spreadsheetId` – 保存先スプレッドシート ID（必須）
- `sheetName` – シート名（省略時は `Data`）

新しいシート名が指定された場合、存在しなければ自動で作成されます。

## デプロイ

`deploy.sh` が `builder` ビルド → `gas/scripts/bundle.js` → `dist/` 生成 → `clasp push/deploy` を一括実行します。

```
./deploy.sh
```

手動で行う場合:

```
npm run builder:build
node gas/scripts/bundle.js
clasp push
clasp deploy --description "Nested Form Builder"
```

デプロイ後に表示される WebApp URL をビルダーの設定パネルに入力してください。

## 返却レスポンス

成功時に以下の JSON を返します。

```json
{
  "ok": true,
  "spreadsheetUrl": "https://docs.google.com/spreadsheets/d/xxxx",
  "sheetName": "Data",
  "rowNumber": 5,
  "id": "r_1700000000000_xxxxxxxx"
}
```

エラー時は `ok: false` と `error` メッセージを含む JSON を返します。



================================================
FILE: gas/appsscript.json
================================================
{
  "timeZone": "Asia/Tokyo",
  "exceptionLogging": "STACKDRIVER",
  "runtimeVersion": "V8",
  "webapp": {
    "executeAs": "USER_ACCESSING",
    "access": "ANYONE"
  },
  "executionApi": {
    "access": "ANYONE"
  },
  "oauthScopes": [
    "https://www.googleapis.com/auth/spreadsheets",
    "https://www.googleapis.com/auth/drive",
    "https://www.googleapis.com/auth/userinfo.email",
    "https://www.googleapis.com/auth/userinfo.profile"
  ],
  "dependencies": {
    "enabledAdvancedServices": [
      {
        "userSymbol": "People",
        "serviceId": "peopleapi",
        "version": "v1"
      }
    ]
  }
}



================================================
FILE: gas/Code.gs
================================================
function doGet(e) {
  const html = HtmlService.createHtmlOutputFromFile("Index");
  const webAppUrl = ScriptApp.getService().getUrl();
  let htmlContent = html.getContent();

  const formParam = e?.parameter?.form ? String(e.parameter.form) : "";
  const adminkeyParam = e?.parameter?.adminkey ? String(e.parameter.adminkey) : "";
  const userEmail = Session.getActiveUser().getEmail() || "";

  const authResult = DetermineAccess_(formParam, adminkeyParam, userEmail);
  const userName = ResolveActiveUserDisplayName_();
  const adminEmail = GetAdminEmail_();
  const propertyStoreMode = Nfb_getPropertyStoreMode_();
  const adminSettingsEnabled = Nfb_isAdminSettingsEnabled_();

  const injectedScript = `<script>
    window.__GAS_WEBAPP_URL__ = "${EscapeForInlineScript_(webAppUrl)}";
    window.__IS_ADMIN__ = ${authResult.isAdmin};
    window.__FORM_ID__ = "${EscapeForInlineScript_(authResult.formId)}";
    window.__AUTH_ERROR__ = "${EscapeForInlineScript_(authResult.authError)}";
    window.__USER_EMAIL__ = "${EscapeForInlineScript_(userEmail)}";
    window.__USER_NAME__ = "${EscapeForInlineScript_(userName)}";
    window.__ADMIN_EMAIL__ = "${EscapeForInlineScript_(adminEmail)}";
    window.__PROPERTY_STORE_MODE__ = "${EscapeForInlineScript_(propertyStoreMode)}";
    window.__ADMIN_SETTINGS_ENABLED__ = ${adminSettingsEnabled};
  </script>`;

  htmlContent = htmlContent.replace('</head>', injectedScript + '</head>');

  return HtmlService.createHtmlOutput(htmlContent)
    .setTitle("Nested Form Builder")
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

function ResolveActiveUserDisplayName_() {
  try {
    const person = People.People.get("people/me", { personFields: "names" });
    if (!person?.names || !person.names.length) return "";
    const displayName = person.names[0]?.displayName;
    return displayName ? String(displayName).trim() : "";
  } catch (err) {
    return "";
  }
}

function EscapeForInlineScript_(value) {
  return String(value ?? "")
    .replace(/\\/g, "\\\\")
    .replace(/"/g, '\\"')
    .replace(/\r/g, "\\r")
    .replace(/\n/g, "\\n")
    .replace(/<\/script/gi, "<\\/script");
}

function doPost(e) {
  return handleCors_(e, () => {
    const ctx = Model_parseRequest_(e);
    const action = ctx.raw?.action || "save";
    const adminSettingsEnabled = Nfb_isAdminSettingsEnabled_();

    const adminKeyParam = ctx.raw?.authKey ? String(ctx.raw.authKey) : "";
    const userEmail = Session.getActiveUser().getEmail() || "";
    const isAdmin = adminSettingsEnabled ? IsAdmin_(adminKeyParam, userEmail) : false;

    const formAdminOnlyActions = ["forms_create", "forms_update", "forms_delete", "forms_import", "forms_archive"];
    const adminSettingsActions = ["admin_key_get", "admin_key_set", "admin_email_get", "admin_email_set"];

    try {
      if (!adminSettingsEnabled && adminSettingsActions.includes(action)) {
        return JsonForbidden_("管理者設定は現在のプロパティ保存モードでは利用できません");
      }

      if (adminSettingsEnabled && (formAdminOnlyActions.includes(action) || adminSettingsActions.includes(action)) && !isAdmin) {
        return JsonForbidden_("管理者権限が必要です");
      }

      let payload;
      switch (action) {
        case "admin_key_get": payload = { ok: true, adminKey: GetAdminKey_() }; break;
        case "admin_key_set": payload = SetAdminKey_(ctx.raw?.adminKey ?? ""); break;
        case "admin_email_get": payload = { ok: true, adminEmail: GetAdminEmail_() }; break;
        case "admin_email_set": payload = SetAdminEmail_(ctx.raw?.adminEmail ?? ""); break;
        case "forms_list": payload = FormsApi_List_(ctx); break;
        case "forms_get": payload = FormsApi_Get_(ctx); break;
        case "forms_create": payload = FormsApi_Create_(ctx); break;
        case "forms_import": payload = FormsApi_Import_(ctx); break;
        case "forms_update": payload = FormsApi_Update_(ctx); break;
        case "forms_delete": payload = FormsApi_Delete_(ctx); break;
        case "forms_archive": payload = FormsApi_SetArchived_(ctx); break;
        case "delete":
          if (RequireSpreadsheetId_(ctx)) return JsonBadRequest_(RequireSpreadsheetId_(ctx).error);
          payload = DeleteRecord_(ctx); break;
        case "list":
          if (RequireSpreadsheetId_(ctx)) return JsonBadRequest_(RequireSpreadsheetId_(ctx).error);
          payload = ListRecords_(ctx); break;
        case "get":
          if (RequireSpreadsheetId_(ctx)) return JsonBadRequest_(RequireSpreadsheetId_(ctx).error);
          payload = GetRecord_(ctx); break;
        default:
          if (RequireSpreadsheetId_(ctx)) return JsonBadRequest_(RequireSpreadsheetId_(ctx).error);
          payload = SubmitResponses_(ctx); break;
      }
      return JsonOutput_(payload, 200);
    } catch (err) {
      return JsonInternalError_(err);
    }
  });
}

function saveResponses(payload) {
  return nfbSafeCall_(() => {
    const ctx = Model_fromScriptRunPayload_(payload);
    const ssErr = RequireSpreadsheetId_(ctx);
    if (ssErr) return ssErr;
    return SubmitResponses_(ctx);
  });
}

function deleteRecord(payload) {
  return nfbSafeCall_(() => {
    const ctx = Model_fromScriptRunPayload_(payload);
    const ssErr = RequireSpreadsheetId_(ctx) || RequireRecordId_(ctx);
    if (ssErr) return ssErr;
    return DeleteRecord_(ctx);
  });
}

function getRecord(payload) {
  return nfbSafeCall_(() => {
    const ctx = Model_fromScriptRunPayload_(payload);
    const ssErr = RequireSpreadsheetId_(ctx) || RequireRecordId_(ctx);
    if (ssErr) return ssErr;
    return GetRecord_(ctx);
  });
}

function nfbExportSearchResults(payload) {
  return nfbSafeCall_(() => {
    if (!payload || !payload.headerRows || !payload.headerRows.length) {
      return { ok: false, error: "headerRows is required" };
    }
    if (!Array.isArray(payload.rows)) {
      return { ok: false, error: "rows must be an array" };
    }
    return Sheets_exportResultMatrixToNewSpreadsheet_(payload.spreadsheetTitle || "", payload.headerRows, payload.rows, payload.themeColors || null);
  });
}

function nfbAppendExportRows(payload) {
  return nfbSafeCall_(() => {
    if (!payload || !payload.spreadsheetId) {
      return { ok: false, error: "spreadsheetId is required" };
    }
    if (!Array.isArray(payload.rows)) {
      return { ok: false, error: "rows must be an array" };
    }
    return Sheets_appendRowsToSpreadsheet_(payload.spreadsheetId, payload.rows, payload.themeColors || null, payload.headerCount || 0, payload.rowOffset || 0);
  });
}

function listRecords(payload) {
  return nfbSafeCall_(() => {
    const ctx = Model_fromScriptRunPayload_(payload);
    const ssErr = RequireSpreadsheetId_(ctx);
    if (ssErr) return ssErr;
    const result = ListRecords_(ctx);
    if (result?.records) result.records = result.records.map(SerializeRecord_);
    return result;
  });
}

function SerializeValue_(value) {
  if (value == null) return "";
  if (value instanceof Date) return value.toISOString();
  if (typeof value === "object") return JSON.stringify(value);
  return String(value);
}

function SerializeDateLike_(value, options = {}) {
  const date = Sheets_parseDateLikeToJstDate_(value, options.allowSerialNumber);
  return date ? { iso: date.toISOString(), unixMs: Sheets_toUnixMs_(date) } : { iso: SerializeValue_(value), unixMs: null };
}

function SerializeRecord_(record) {
  const serializedData = {};
  const serializedDataUnixMs = {};

  if (record.data && typeof record.data === "object") {
    Object.entries(record.data).forEach(([key, value]) => {
      const dateInfo = SerializeDateLike_(value);
      serializedData[key] = dateInfo.iso;
      if (dateInfo.unixMs !== null) serializedDataUnixMs[key] = dateInfo.unixMs;
    });
  }

  const createdInfo = SerializeDateLike_(record.createdAt, { allowSerialNumber: true });
  const modifiedInfo = SerializeDateLike_(record.modifiedAt, { allowSerialNumber: true });

  return {
    id: String(record.id || ""),
    "No.": record["No."] ?? "",
    modifiedBy: record.modifiedBy || "",
    createdBy: record.createdBy || "",
    createdAt: createdInfo.unixMs ?? createdInfo.iso,
    modifiedAt: modifiedInfo.unixMs ?? modifiedInfo.iso,
    createdAtUnixMs: createdInfo.unixMs,
    modifiedAtUnixMs: modifiedInfo.unixMs,
    data: serializedData,
    dataUnixMs: serializedDataUnixMs
  };
}

function SubmitResponses_(ctx) {
  let sheet;
  try {
    sheet = Sheets_getOrCreateSheet_(ctx.spreadsheetId, ctx.sheetName);
  } catch (err) {
    return { ok: false, error: Sheets_translateOpenError_(err, ctx.spreadsheetId) };
  }
  const result = Sheets_upsertRecordById_(sheet, ctx.order, ctx);
  return {
    ok: true,
    spreadsheetUrl: `https://docs.google.com/spreadsheets/d/${ctx.spreadsheetId}`,
    sheetName: ctx.sheetName,
    rowNumber: result.row,
    id: result.id,
  };
}

function DeleteRecord_(ctx) {
  const idErr = RequireRecordId_(ctx);
  if (idErr) return idErr;
  let sheet;
  try {
    sheet = Sheets_getOrCreateSheet_(ctx.spreadsheetId, ctx.sheetName);
  } catch (err) {
    return { ok: false, error: Sheets_translateOpenError_(err, ctx.spreadsheetId) };
  }
  const result = Sheets_deleteRecordById_(sheet, ctx.id);
  if (!result.ok) return result;
  return { ok: true, id: ctx.id, deletedRow: result.row };
}

function GetRecord_(ctx) {
  const idErr = RequireRecordId_(ctx);
  if (idErr) return idErr;
  let sheet;
  try {
    sheet = Sheets_getOrCreateSheet_(ctx.spreadsheetId, ctx.sheetName);
  } catch (err) {
    return { ok: false, error: Sheets_translateOpenError_(err, ctx.spreadsheetId) };
  }
  const result = Sheets_getRecordById_(sheet, ctx.id, ctx.rowIndexHint);
  if (!result?.ok) return result || { ok: false, error: "Record not found" };
  return { ok: true, record: result.record ? SerializeRecord_(result.record) : null, rowIndex: result.rowIndex };
}

function ListRecords_(ctx) {
  let sheet;
  try {
    sheet = Sheets_getOrCreateSheet_(ctx.spreadsheetId, ctx.sheetName);
  } catch (err) {
    return { ok: false, error: Sheets_translateOpenError_(err, ctx.spreadsheetId) };
  }
  let temporalTypeMap = null;
  const formId = ctx?.raw?.formId;
  if (formId) {
    try {
      const form = Forms_getForm_(formId);
      if (form?.schema) temporalTypeMap = Sheets_collectTemporalPathMap_(form.schema);
    } catch (err) {
      Logger.log(`[ListRecords_] Failed to load form schema for temporal formats: ${err}`);
    }
  }
  const records = Sheets_getAllRecords_(sheet, temporalTypeMap);
  return { ok: true, records, count: records.length, headerMatrix: Sheets_readHeaderMatrix_(sheet) };
}

function handleCors_(e, handler) {
  const origin = e?.headers?.origin || "*";
  if (e?.method === "OPTIONS") return Cors_applyHeaders_(ContentService.createTextOutput(""), origin, true);
  return Cors_applyHeaders_(handler(), origin, false);
}

function Cors_applyHeaders_(output, origin, isPreflight) {
  output.setHeader("Access-Control-Allow-Origin", origin || "*");
  output.setHeader("Access-Control-Allow-Credentials", "true");
  if (isPreflight) {
    output.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
    output.setHeader("Access-Control-Allow-Headers", "Content-Type");
    output.setHeader("Access-Control-Max-Age", "3600");
  }
  return output;
}

function FormsApi_List_(ctx) {
  const result = nfbListForms({ includeArchived: !!ctx.raw?.includeArchived });
  if (!result?.ok) return { ok: false, error: result?.error || "フォーム一覧の取得に失敗しました" };
  return { ok: true, forms: result.forms || [], count: (result.forms || []).length, loadFailures: result.loadFailures || [] };
}

function FormsApi_Get_(ctx) {
  if (!ctx.raw?.formId) return { ok: false, error: "フォームIDが指定されていません" };
  const result = nfbGetForm(ctx.raw.formId);
  if (!result?.ok || !result.form) return { ok: false, error: result?.error || "フォームの取得に失敗しました" };
  return { ok: true, form: result.form };
}

function FormsApi_Create_(ctx) {
  if (!ctx.raw?.formData?.id) return { ok: false, error: "フォームデータが不正です" };
  const result = nfbSaveForm({ form: ctx.raw.formData, targetUrl: ctx.raw.saveUrl || null });
  if (!result?.ok) return { ok: false, error: result?.error || "フォームの作成に失敗しました" };
  return { ok: true, form: result.form, fileUrl: result.fileUrl || null };
}

function FormsApi_Import_(ctx) {
  if (!ctx.raw?.fileUrl) return { ok: false, error: "ファイルURLが指定されていません" };
  const parsed = Forms_parseGoogleDriveUrl_(ctx.raw.fileUrl);
  if (parsed?.type !== "file" || !parsed.id) return { ok: false, error: "無効なファイルURLです" };

  let formData;
  try {
    const file = DriveApp.getFileById(parsed.id);
    formData = JSON.parse(file.getBlob().getDataAsString());
    formData.driveFileUrl = formData.driveFileUrl || file.getUrl();
  } catch (error) {
    return { ok: false, error: `フォームデータの取得に失敗しました: ${nfbErrorToString_(error)}` };
  }
  if (!formData?.id) return { ok: false, error: "フォームデータが不正です（idが必要です）" };

  const result = nfbSaveForm({ form: formData });
  if (!result?.ok) return { ok: false, error: result?.error || "フォームのインポートに失敗しました" };
  return { ok: true, form: result.form, fileUrl: result.fileUrl || null };
}

function FormsApi_Update_(ctx) {
  if (!ctx.raw?.formId || !ctx.raw?.updates) return { ok: false, error: "フォームIDまたは更新内容が指定されていません" };
  const currentResult = nfbGetForm(ctx.raw.formId);
  if (!currentResult?.ok || !currentResult.form) return { ok: false, error: currentResult?.error || "フォームが見つかりません" };

  const nextForm = { ...currentResult.form, ...ctx.raw.updates, id: ctx.raw.formId, createdAt: currentResult.form.createdAt, createdAtUnixMs: currentResult.form.createdAtUnixMs };
  const saveResult = nfbSaveForm({ form: nextForm });
  if (!saveResult?.ok) return { ok: false, error: saveResult?.error || "フォームの更新に失敗しました" };
  return { ok: true, form: saveResult.form };
}

function FormsApi_Delete_(ctx) {
  if (!ctx.raw?.formId) return { ok: false, error: "フォームIDが指定されていません" };
  const result = nfbDeleteForm(ctx.raw.formId);
  if (!result?.ok) return { ok: false, error: result?.error || "フォームの削除に失敗しました" };
  return { ok: true, message: "フォームを削除しました", formId: ctx.raw.formId };
}

function FormsApi_SetArchived_(ctx) {
  if (!ctx.raw?.formId || ctx.raw?.archived === undefined) return { ok: false, error: "フォームIDまたはアーカイブ状態が指定されていません" };
  const archivedFlag = ["true", true, 1, "1"].includes(ctx.raw.archived);
  const result = archivedFlag ? nfbArchiveForm(ctx.raw.formId) : nfbUnarchiveForm(ctx.raw.formId);
  if (!result?.ok) return { ok: false, error: result?.error || "フォームの更新に失敗しました" };
  return { ok: true, form: result.form || null };
}



================================================
FILE: gas/constants.gs
================================================
// 管理者設定関連
var NFB_ADMIN_KEY = "ADMIN_KEY";
var NFB_ADMIN_EMAIL = "ADMIN_EMAIL";
var NFB_RESTRICT_TO_FORM_ONLY = "RESTRICT_TO_FORM_ONLY";
var NFB_PROPERTY_STORE_MODE = "__NFB_PROPERTY_STORE_MODE__";
var NFB_PROPERTY_STORE_MODE_SCRIPT = "script";
var NFB_PROPERTY_STORE_MODE_USER = "user";

// フォーム管理関連（Google Drive）
var FORMS_FOLDER_NAME = "Nested Form Builder - Forms";
var FORMS_PROPERTY_KEY = "nfb.forms.mapping"; 
var FORMS_PROPERTY_VERSION = 2; 

// API/バッチ処理関連
var NFB_DRIVE_API_BATCH_SIZE = 100;

// スプレッドシート・ヘッダー関連
var NFB_HEADER_DEPTH = 11;
var NFB_FIXED_HEADER_PATHS = [["id"], ["No."], ["createdAt"], ["modifiedAt"], ["createdBy"], ["modifiedBy"]];
var NFB_DEFAULT_SHEET_NAME = "Data";

// 日時処理関連
var NFB_TZ = "Asia/Tokyo";
var NFB_MS_PER_DAY = 24 * 60 * 60 * 1000;
var NFB_SHEETS_EPOCH_MS = new Date(1899, 11, 30, 0, 0, 0).getTime();



================================================
FILE: gas/drive.gs
================================================
/**
 * drive.gs
 * Google Drive連携機能
 */

/**
 * Google DriveのURLからテーマCSSを取得
 * @param {string} url - Google DriveのファイルURL
 * @return {Object} { ok: true, css: string, fileName: string, fileUrl: string }
 */
function nfbImportThemeFromDrive(url) {
  return nfbSafeCall_(function() {
    if (!url || typeof url !== "string") {
      throw new Error("Google Drive URLが指定されていません");
    }

    var fileId = ExtractFileIdFromUrl_(url);
    if (!fileId) {
      throw new Error("無効なGoogle DriveファイルURLです");
    }

    var file;
    try {
      file = DriveApp.getFileById(fileId);
    } catch (accessError) {
      throw new Error("ファイルへのアクセスに失敗しました: " + nfbErrorToString_(accessError));
    }

    var css = file.getBlob().getDataAsString();
    if (!css) {
      throw new Error("テーマファイルが空です");
    }

    return {
      ok: true,
      css: css,
      fileName: file.getName(),
      fileUrl: file.getUrl(),
    };
  });
}



================================================
FILE: gas/errors.gs
================================================
const nfbErrorToString_ = (err) => err?.message || String(err);
const nfbFail_ = (err) => ({ ok: false, error: nfbErrorToString_(err) });
const nfbSafeCall_ = (fn) => { try { return fn(); } catch (err) { return nfbFail_(err); } };

const JsonOutput_ = (payload, status) => {
  const output = ContentService.createTextOutput(JSON.stringify(payload || {})).setMimeType(ContentService.MimeType.JSON);
  if (typeof status === "number" && output.setStatusCode) output.setStatusCode(status);
  return output;
};

const JsonBadRequest_ = (message) => JsonOutput_({ ok: false, error: message }, 400);
const JsonForbidden_ = (message = "forbidden") => JsonOutput_({ ok: false, error: message }, 403);
const JsonInternalError_ = (err) => JsonOutput_({ ok: false, error: nfbErrorToString_(err) }, 500);

const RequireSpreadsheetId_ = (ctx) => ctx?.spreadsheetId ? null : nfbFail_("スプレッドシートIDが設定されていません。フォーム設定を確認してください。");
const RequireRecordId_ = (ctx) => ctx?.id ? null : nfbFail_("レコードIDが指定されていません");

function Sheets_translateOpenError_(err, spreadsheetId) {
  var msg = String(err && err.message ? err.message : err);
  if (/not found/i.test(msg) || /no item/i.test(msg)) {
    return "スプレッドシートが見つかりません (ID: " + spreadsheetId + ")";
  }
  if (/permission/i.test(msg) || /access/i.test(msg) || /You do not have/i.test(msg)) {
    return "スプレッドシートへのアクセス権限がありません (ID: " + spreadsheetId + ")";
  }
  return "スプレッドシートを開けませんでした: " + msg;
}



================================================
FILE: gas/formsCrud.gs
================================================
// Split from forms.gs



function Forms_getForm_(formId) {
  if (!formId) return null;

  var mapping = Forms_getMapping_();
  var mappingEntry = mapping[formId] || {};
  var fileId = mappingEntry.fileId;
  var driveFileUrlFromMap = mappingEntry.driveFileUrl;

  // URLのみ保持されている場合はそこからIDを抽出
  if (!fileId && driveFileUrlFromMap) {
    var parsedFromUrl = Forms_parseGoogleDriveUrl_(driveFileUrlFromMap);
    if (parsedFromUrl.type === "file") {
      fileId = parsedFromUrl.id;
    }
  }

  if (!fileId) return null;

  try {
    var file = DriveApp.getFileById(fileId);
    var content = file.getBlob().getDataAsString();
    var form = JSON.parse(content);

    // idはファイルに含めていないためマッピングから復元
    form.id = formId;

    // driveFileUrlがない場合はマッピング/ファイルから補完
    if (!form.driveFileUrl) {
      form.driveFileUrl = driveFileUrlFromMap || file.getUrl();
    }

    return form;
  } catch (err) {
    Logger.log("[Forms_getForm_] Error loading form " + formId + ": " + err);
    return null;
  }
}

/**
 * フォームを削除（Driveファイルは削除せず、紐付けのみ解除）
 * @param {string} formId
 * @return {Object} { ok: true }
 */

function Forms_listForms_(options) {
  var startTime = new Date().getTime();
  var includeArchived = !!(options && options.includeArchived);

  var mappingStartTime = new Date().getTime();
  var mapping = Forms_getMapping_();
  var mappingEndTime = new Date().getTime();
  var mappingDuration = mappingEndTime - mappingStartTime;

  Logger.log("[Forms_listForms_] Retrieved mapping: " + JSON.stringify(mapping));
  Logger.log("[Forms_listForms_] Total forms in mapping: " + Object.keys(mapping).length);
  Logger.log("[Forms_listForms_] Mapping retrieval took: " + mappingDuration + "ms");

  var forms = [];
  var loadFailures = [];

  // マッピングからfileIdリストを構築
  var fileIdMap = {}; // { fileId: formId }
  var formIdToMappingEntry = {}; // { formId: mappingEntry }

  for (var formId in mapping) {
    if (!mapping.hasOwnProperty(formId)) continue;
    var mappingEntry = mapping[formId] || {};
    var fileId = mappingEntry.fileId;
    var driveFileUrlFromMap = mappingEntry.driveFileUrl;

    if (!fileId && driveFileUrlFromMap) {
      var parsedFromUrl = Forms_parseGoogleDriveUrl_(driveFileUrlFromMap);
      if (parsedFromUrl.type === "file") {
        fileId = parsedFromUrl.id;
      }
    }

    if (fileId) {
      fileIdMap[fileId] = formId;
      formIdToMappingEntry[formId] = mappingEntry;
    } else {
      // fileIdがない場合はエラーとして記録
      loadFailures.push({
        id: formId,
        fileId: null,
        fileName: null,
        driveFileUrl: driveFileUrlFromMap || null,
        errorStage: "fileId",
        errorMessage: "プロパティサービスにファイルIDが登録されていません",
        lastTriedAt: new Date().toISOString(),
      });
    }
  }

  var fileIds = Object.keys(fileIdMap);
  Logger.log("[Forms_listForms_] Processing " + fileIds.length + " files with batch requests");

  // Drive API v3 バッチリクエスト（最大100件ずつ）
  var BATCH_SIZE = NFB_DRIVE_API_BATCH_SIZE;
  var batchStartTime = new Date().getTime();
  var totalBatchTime = 0;

  for (var i = 0; i < fileIds.length; i += BATCH_SIZE) {
    var batchFileIds = fileIds.slice(i, i + BATCH_SIZE);
    var batchStart = new Date().getTime();

    // バッチリクエストで複数ファイルのメタデータとコンテンツを取得
    try {
      var batchResults = Forms_batchGetFiles_(batchFileIds);
      var batchEnd = new Date().getTime();
      totalBatchTime += (batchEnd - batchStart);

      Logger.log("[Forms_listForms_] Batch " + (Math.floor(i / BATCH_SIZE) + 1) + " completed in " + (batchEnd - batchStart) + "ms (" + batchFileIds.length + " files)");

      // バッチ結果を処理
      for (var j = 0; j < batchResults.length; j++) {
        var result = batchResults[j];
        var fileId = result.fileId;
        var formId = fileIdMap[fileId];
        var mappingEntry = formIdToMappingEntry[formId];

        if (result.error) {
          // エラーケース
          loadFailures.push({
            id: formId,
            fileId: fileId,
            fileName: result.fileName || null,
            driveFileUrl: mappingEntry.driveFileUrl || Forms_buildDriveFileUrlFromId_(fileId),
            errorStage: result.errorStage || "unknown",
            errorMessage: result.error,
            lastTriedAt: new Date().toISOString(),
          });
        } else {
          // 成功ケース
          try {
            var form = JSON.parse(result.content);
            form.id = formId;

            // driveFileUrlがない場合はマッピング/ファイルから補完
            if (!form.driveFileUrl) {
              form.driveFileUrl = mappingEntry.driveFileUrl || result.fileUrl;
            }

            // createdAt/modifiedAt の Unix ms を付与
            var createdAtSerial = Sheets_toUnixMs_(form.createdAt, true);
            var modifiedAtSerial = Sheets_toUnixMs_(form.modifiedAt, true);
            if (createdAtSerial !== null) form.createdAt = createdAtSerial;
            if (modifiedAtSerial !== null) form.modifiedAt = modifiedAtSerial;
            form.createdAtUnixMs = createdAtSerial;
            form.modifiedAtUnixMs = modifiedAtSerial;

            // アーカイブフィルタリング
            if (!includeArchived && form.archived) {
              Logger.log("[Forms_listForms_] Skipping archived form: " + formId);
              continue;
            }

            forms.push(form);
          } catch (parseErr) {
            loadFailures.push({
              id: formId,
              fileId: fileId,
              fileName: result.fileName,
              driveFileUrl: mappingEntry.driveFileUrl || result.fileUrl,
              errorStage: "parse",
              errorMessage: parseErr && parseErr.message ? parseErr.message : String(parseErr),
              lastTriedAt: new Date().toISOString(),
            });
          }
        }
      }
    } catch (batchErr) {
      Logger.log("[Forms_listForms_] Batch request failed: " + batchErr);
      // バッチ全体が失敗した場合は個別にフォールバック
      for (var k = 0; k < batchFileIds.length; k++) {
        var fbFileId = batchFileIds[k];
        var fbFormId = fileIdMap[fbFileId];
        loadFailures.push({
          id: fbFormId,
          fileId: fbFileId,
          fileName: null,
          driveFileUrl: formIdToMappingEntry[fbFormId].driveFileUrl || Forms_buildDriveFileUrlFromId_(fbFileId),
          errorStage: "batch",
          errorMessage: batchErr && batchErr.message ? batchErr.message : String(batchErr),
          lastTriedAt: new Date().toISOString(),
        });
      }
    }
  }

  var endTime = new Date().getTime();
  var totalDuration = endTime - startTime;

  Logger.log("[Forms_listForms_] === Performance Summary ===");
  Logger.log("[Forms_listForms_] Total duration: " + totalDuration + "ms");
  Logger.log("[Forms_listForms_] Mapping retrieval: " + mappingDuration + "ms (" + Math.round(mappingDuration / totalDuration * 100) + "%)");
  Logger.log("[Forms_listForms_] Batch requests: " + totalBatchTime + "ms (" + Math.round(totalBatchTime / totalDuration * 100) + "%)");
  Logger.log("[Forms_listForms_] Average per form: " + Math.round(totalDuration / fileIds.length) + "ms");
  Logger.log("[Forms_listForms_] Returning " + forms.length + " forms (loadFailures=" + loadFailures.length + ")");

  return {
    forms: forms,
    loadFailures: loadFailures,
  };
}

/**
 * Drive API v3を使用して複数ファイルを一括取得
 * @param {Array<string>} fileIds - ファイルIDの配列
 * @return {Array<Object>} 結果の配列 [{ fileId, fileName, fileUrl, content, error, errorStage }]
 */

function Forms_batchGetFiles_(fileIds) {
  var results = [];

  // Drive API v3のbatch requestを使用
  var boundary = "batch_boundary_" + new Date().getTime();
  var batchBody = [];

  for (var i = 0; i < fileIds.length; i++) {
    var fileId = fileIds[i];
    batchBody.push("--" + boundary);
    batchBody.push("Content-Type: application/http");
    batchBody.push("");
    batchBody.push("GET /drive/v3/files/" + fileId + "?fields=id,name,webViewLink&alt=json");
    batchBody.push("");
  }
  batchBody.push("--" + boundary + "--");

  var batchPayload = batchBody.join("\r\n");

  try {
    var response = UrlFetchApp.fetch("https://www.googleapis.com/batch/drive/v3", {
      method: "post",
      contentType: "multipart/mixed; boundary=" + boundary,
      headers: {
        Authorization: "Bearer " + ScriptApp.getOAuthToken(),
      },
      payload: batchPayload,
      muteHttpExceptions: true,
    });

    var responseText = response.getContentText();
    var responseParts = responseText.split("--batch");

    // バッチレスポンスをパース
    var fileMetadataMap = {}; // { fileId: { name, webViewLink } }
    for (var j = 0; j < responseParts.length; j++) {
      var part = responseParts[j];
      if (!part || part.trim() === "" || part.trim() === "--") continue;

      // JSONペイロードを抽出
      var jsonMatch = part.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        try {
          var metadata = JSON.parse(jsonMatch[0]);
          if (metadata.id) {
            fileMetadataMap[metadata.id] = {
              name: metadata.name,
              webViewLink: metadata.webViewLink,
            };
          }
        } catch (parseErr) {
          Logger.log("[Forms_batchGetFiles_] Failed to parse batch response part: " + parseErr);
        }
      }
    }

    // メタデータ取得後、各ファイルのコンテンツを取得（DriveApp使用）
    for (var k = 0; k < fileIds.length; k++) {
      var fid = fileIds[k];
      var meta = fileMetadataMap[fid];

      if (!meta) {
        results.push({
          fileId: fid,
          error: "File not found in batch response",
          errorStage: "batch",
        });
        continue;
      }

      try {
        var file = DriveApp.getFileById(fid);
        var content = file.getBlob().getDataAsString();
        results.push({
          fileId: fid,
          fileName: meta.name,
          fileUrl: meta.webViewLink,
          content: content,
        });
      } catch (readErr) {
        results.push({
          fileId: fid,
          fileName: meta.name,
          fileUrl: meta.webViewLink,
          error: readErr && readErr.message ? readErr.message : String(readErr),
          errorStage: "read",
        });
      }
    }
  } catch (batchErr) {
    Logger.log("[Forms_batchGetFiles_] Batch API call failed: " + batchErr);
    // バッチ全体が失敗した場合は個別フォールバック
    for (var m = 0; m < fileIds.length; m++) {
      var fbId = fileIds[m];
      try {
        var fbFile = DriveApp.getFileById(fbId);
        var fbContent = fbFile.getBlob().getDataAsString();
        results.push({
          fileId: fbId,
          fileName: fbFile.getName(),
          fileUrl: fbFile.getUrl(),
          content: fbContent,
        });
      } catch (fbErr) {
        results.push({
          fileId: fbId,
          error: fbErr && fbErr.message ? fbErr.message : String(fbErr),
          errorStage: "fallback",
        });
      }
    }
  }

  return results;
}

/**
 * 特定フォームを取得
 * @param {string} formId
 * @return {Object|null} フォームオブジェクトまたはnull
 */

function Forms_deleteForm_(formId) {
  if (!formId) {
    throw new Error("Form ID is required");
  }

  var mapping = Forms_getMapping_();
  delete mapping[formId];
  Forms_saveMapping_(mapping);

  return { ok: true };
}

/**
 * 複数フォームを削除（Driveファイルは削除せず、紐付けのみ解除）
 * @param {Array<string>} formIds
 * @return {Object} { ok: boolean, deleted: number, errors: Array }
 */

function Forms_deleteForms_(formIds) {
  if (!formIds || !formIds.length) {
    throw new Error("Form IDs are required");
  }

  var ids = Array.isArray(formIds) ? formIds.slice() : [formIds];
  var mapping = Forms_getMapping_();
  var deleted = 0;

  ids.forEach(function(formId) {
    if (!formId) return;

    if (mapping.hasOwnProperty(formId)) {
      delete mapping[formId];
      deleted += 1;
    }
  });

  Forms_saveMapping_(mapping);

  return {
    ok: true,
    deleted: deleted,
    errors: []
  };
}

/**
 * フォームのアーカイブ状態を変更
 * @param {string} formId
 * @param {boolean} archived
 * @return {Object} { ok: true, form }
 */

function Forms_setFormArchivedState_(formId, archived) {
  var form = Forms_getForm_(formId);
  if (!form) {
    throw new Error("Form not found: " + formId);
  }

  form.archived = !!archived;
  var nowSerial = Sheets_dateToSerial_(new Date());
  form.modifiedAt = nowSerial;
  form.modifiedAtUnixMs = nowSerial;

  return Forms_saveForm_(form);
}

/**
 * 複数フォームのアーカイブ状態を一括変更
 * @param {Array<string>} formIds
 * @param {boolean} archived
 * @return {Object} { ok: boolean, updated: number, errors: Array, forms: Array }
 */

function Forms_setFormsArchivedState_(formIds, archived) {
  if (!formIds || !formIds.length) {
    throw new Error("Form IDs are required");
  }

  var ids = Array.isArray(formIds) ? formIds.slice() : [formIds];
  var errors = [];
  var updated = 0;
  var updatedForms = [];
  var nowSerial = Sheets_dateToSerial_(new Date());

  ids.forEach(function(formId) {
    if (!formId) return;

    try {
      var form = Forms_getForm_(formId);
      if (!form) {
        errors.push({ formId: formId, error: "Form not found" });
        return;
      }

      form.archived = !!archived;
      form.modifiedAt = nowSerial;
      form.modifiedAtUnixMs = nowSerial;

      var result = Forms_saveForm_(form);
      if (result && result.ok) {
        updated += 1;
        updatedForms.push(result.form);
      } else {
        errors.push({ formId: formId, error: "Save failed" });
      }
    } catch (err) {
      Logger.log("[Forms_setFormsArchivedState_] Error updating archive state for form " + formId + ": " + err);
      errors.push({ formId: formId, error: err.message || String(err) });
    }
  });

  return {
    ok: errors.length === 0,
    updated: updated,
    errors: errors,
    forms: updatedForms
  };
}

// ========================================
// Public API Functions (google.script.run経由で呼び出し可能)
// ========================================

/**
 * フォーム一覧を取得
 */




================================================
FILE: gas/formsImport.gs
================================================
// Split from forms.gs



function Forms_importFromDrive_(url) {
  if (!url || typeof url !== "string") {
    throw new Error("URLが必要です");
  }

  var parsed = Forms_parseGoogleDriveUrl_(url);
  if (!parsed.type) {
    throw new Error("無効なGoogle Drive URLです");
  }

  var mapping = Forms_getMapping_();
  var forms = [];
  var skipped = 0;
  var parseFailed = 0;
  var totalFiles = 0;

  // 重複検出用
  var existingDriveFileUrls = [];
  var existingFileIds = [];
  for (var fid in mapping) {
    if (!mapping.hasOwnProperty(fid)) continue;
    var entry = mapping[fid];
    if (entry && entry.driveFileUrl) {
      existingDriveFileUrls.push(entry.driveFileUrl);
    }
    if (entry && entry.fileId) {
      existingFileIds.push(entry.fileId);
    }
  }

  if (parsed.type === "file") {
    // ファイルの場合：URL重複チェック
    try {
      var file = DriveApp.getFileById(parsed.id);
      var fileName = file.getName();
      var fileUrl = file.getUrl();

      if (existingFileIds.indexOf(parsed.id) !== -1) {
        throw new Error("このファイルは既にプロパティサービスに登録されています");
      }
      if (existingDriveFileUrls.indexOf(fileUrl) !== -1) {
        throw new Error("このファイルは既にプロパティサービスに登録されています");
      }

      var content = file.getBlob().getDataAsString();
      var formData = JSON.parse(content);
      var normalizedFormData = Forms_normalizeImportedFormData_(formData);
      if (!normalizedFormData) {
        throw new Error("フォーム形式として無効なJSONです: " + fileName);
      }

      // fileId / fileUrl を付与して返す（コピーなしで元ファイルを管理するため）
      forms.push({ form: normalizedFormData, fileId: parsed.id, fileUrl: fileUrl });
    } catch (err) {
      throw new Error("ファイルの読み込みに失敗しました: " + err.message);
    }
  } else if (parsed.type === "folder") {
    // フォルダの場合：フォルダ内の.jsonファイルを全て読み込む
    try {
      var folder = DriveApp.getFolderById(parsed.id);
      // MIME type に依存せず、拡張子が .json のファイルを全件対象にする
      var files = folder.getFiles();

      while (files.hasNext()) {
        var file = files.next();
        var fileName = file.getName();
        var fileId = file.getId();
        var fileUrlInFolder = file.getUrl();

        // 拡張子またはMIMEタイプでJSONと判断できるファイルのみ処理
        var fileMimeType = file.getMimeType();
        var isJsonByExt = fileName.toLowerCase().endsWith(".json");
        var isJsonByMime = fileMimeType === "application/json" || fileMimeType === "text/plain";
        if (!isJsonByExt && !isJsonByMime) {
          continue;
        }

        totalFiles += 1;

        // driveFileUrl / fileId が既に登録済みかチェック
        if (existingDriveFileUrls.indexOf(fileUrlInFolder) !== -1 || existingFileIds.indexOf(fileId) !== -1) {
          skipped += 1;
          Logger.log("[Forms_importFromDrive_] Skipped (already registered driveFileUrl/fileId): " + fileName);
          continue;
        }

        try {
          var content = file.getBlob().getDataAsString();
          var formData = JSON.parse(content);
          var normalizedFormData = Forms_normalizeImportedFormData_(formData);
          if (!normalizedFormData) {
            Logger.log("[Forms_importFromDrive_] Invalid form data in file: " + fileName);
            parseFailed += 1;
            continue;
          }

          // fileId / fileUrl を付与して返す（コピーなしで元ファイルを管理するため）
          forms.push({ form: normalizedFormData, fileId: fileId, fileUrl: fileUrlInFolder });
        } catch (parseErr) {
          Logger.log("[Forms_importFromDrive_] Failed to parse JSON file: " + fileName + " - " + parseErr.message);
          parseFailed += 1;
          continue;
        }
      }
    } catch (err) {
      throw new Error("フォルダの読み込みに失敗しました: " + err.message);
    }
  }

  return {
    ok: true,
    forms: forms,
    skipped: skipped,
    parseFailed: parseFailed || 0,
    totalFiles: totalFiles || 0,
  };
}

/**
 * Google DriveからフォームをインポートするAPI
 * @param {string} url - Google DriveのURL（ファイルまたはフォルダ）
 * @return {Object} { ok: true, forms: Array, skipped: number }
 */

function Forms_registerImportedForm_(payload) {
  if (!payload || !payload.form || !payload.fileId) {
    throw new Error("form と fileId が必要です");
  }

  var form = Forms_normalizeImportedFormData_(payload.form);
  if (!form) {
    throw new Error("フォームJSONが有効な形式ではありません");
  }
  var fileId = payload.fileId;
  var fileUrl = payload.fileUrl || ("https://drive.google.com/file/d/" + fileId + "/view");

  // マッピングに登録（ファイルのコピーは作らない）
  var mapping = Forms_getMapping_();
  var formId = form.id ? String(form.id) : "";
  if (formId && mapping[formId] && mapping[formId].fileId && mapping[formId].fileId !== fileId) {
    Logger.log("[Forms_registerImportedForm_] Existing form id conflict. Assigning new id: " + formId);
    formId = "";
  }
  if (!formId) {
    formId = Forms_generateFormId_(mapping);
  }
  form.id = formId;
  form.driveFileUrl = fileUrl;

  mapping[formId] = { fileId: fileId, driveFileUrl: fileUrl };
  Forms_saveMapping_(mapping);

  // AddFormUrl_ にも登録（?form=xxx でアクセス可能にする）
  try {
    AddFormUrl_(formId, fileUrl);
  } catch (err) {
    Logger.log("[Forms_registerImportedForm_] AddFormUrl_ failed (non-critical): " + err);
  }

  return { ok: true, form: form, fileId: fileId, fileUrl: fileUrl };
}

/**
 * インポートフォーム登録API（コピーなし）
 * @param {Object} payload - { form: Object, fileId: string, fileUrl: string }
 * @return {Object} { ok: true, form, fileId, fileUrl }
 */




================================================
FILE: gas/formsMappingStore.gs
================================================
// Split from forms.gs



function Forms_getActiveProps_() {
  return Nfb_getActiveProperties_();
}

function Forms_parseMappingJson_(json, label) {
  if (!json) return {};
  try {
    var parsed = JSON.parse(json) || {};
    if (parsed && typeof parsed === "object" && parsed.mapping) {
      return parsed.mapping;
    }
    return parsed;
  } catch (err) {
    Logger.log("[Forms_parseMappingJson_] Failed to parse " + label + ": " + err);
    return {};
  }
}

/**
 * Google DriveのURLからIDを抽出
 * @param {string} url - Google DriveのURL
 * @return {Object} { type: "file"|"folder"|null, id: string|null }
 */

function Forms_getMapping_() {
  var props = Forms_getActiveProps_();
  var rawJson = props.getProperty(FORMS_PROPERTY_KEY);
  var mode = Nfb_getPropertyStoreMode_();
  Logger.log("[Forms_getMapping_] Raw JSON (" + mode + "): " + rawJson);

  var mapping = Forms_parseMappingJson_(rawJson, mode);
  var normalized = Forms_normalizeMapping_(mapping);

  Logger.log("[Forms_getMapping_] Returning mapping: " + JSON.stringify(normalized));
  return normalized;
}

function Forms_normalizeMappingValue_(value) {
  var fileId = null;
  var driveFileUrl = null;

  if (value && typeof value === "object") {
    fileId = value.fileId || null;
    driveFileUrl = value.driveFileUrl || null;
  } else if (typeof value === "string") {
    if (value.indexOf("/file/") !== -1 || value.indexOf("drive.google.com") !== -1) {
      driveFileUrl = value;
      var parsed = Forms_parseGoogleDriveUrl_(value);
      if (parsed.type === "file") {
        fileId = parsed.id;
      }
    } else {
      fileId = value;
    }
  }

  if (!driveFileUrl && fileId) {
    driveFileUrl = Forms_buildDriveFileUrlFromId_(fileId);
  }

  return { fileId: fileId, driveFileUrl: driveFileUrl };
}

/**
 * マッピング全体を正規化
 * @param {Object} mapping
 * @returns {Object} 正規化済みマッピング
 */

function Forms_normalizeMapping_(mapping) {
  var normalized = {};
  for (var formId in mapping) {
    if (!mapping.hasOwnProperty(formId)) continue;
    normalized[formId] = Forms_normalizeMappingValue_(mapping[formId]);
  }
  return normalized;
}

/**
 * スキーマからIDを除去（options/children含む）
 * @param {Array} schema
 * @return {Array}
 */

function Forms_saveMapping_(mapping) {
  var normalized = Forms_normalizeMapping_(mapping || {});
  var mappingStr = JSON.stringify({ version: FORMS_PROPERTY_VERSION, mapping: normalized });
  Logger.log("[Forms_saveMapping_] Saving mapping: " + mappingStr);

  var props = Forms_getActiveProps_();
  props.setProperty(FORMS_PROPERTY_KEY, mappingStr);

  Logger.log("[Forms_saveMapping_] Saved successfully. Total forms: " + Object.keys(normalized || {}).length);
}

/**
 * formId配列を正規化（重複・空値を除外）
 * @param {Array<string>|string} formIds
 * @return {Array<string>}
 */

function Forms_normalizeFormIds_(formIds) {
  var source = Array.isArray(formIds) ? formIds : [formIds];
  var seen = {};
  var normalized = [];

  for (var i = 0; i < source.length; i++) {
    var rawId = source[i];
    if (!rawId) continue;
    var formId = String(rawId);
    if (seen[formId]) continue;
    seen[formId] = true;
    normalized.push(formId);
  }

  return normalized;
}

/**
 * フォーム保存用フォルダを取得または作成
 * @return {Folder}
 */

function Forms_buildDriveFileUrlFromId_(fileId) {
  if (!fileId) return null;
  return "https://drive.google.com/file/d/" + fileId + "/view";
}

/**
 * マッピング値を正規化（v1: fileId文字列, v2: { fileId, driveFileUrl }）
 * @param {*} value
 * @returns {{fileId: string|null, driveFileUrl: string|null}}
 */

function Forms_stripSchemaIds_(schema) {
  if (!schema || !schema.map) return [];

  var stripArray = function(arr) {
    return (arr || []).map(function(field) {
      var base = {};
      for (var key in field) {
        if (!field.hasOwnProperty(key)) continue;
        if (key === "id") continue; // フィールドIDは外部配布不要
        base[key] = field[key];
      }

      // optionsのIDを除去
      if (base.options && Array.isArray(base.options)) {
        base.options = base.options.map(function(opt) {
          var optBase = {};
          for (var optKey in opt) {
            if (!opt.hasOwnProperty(optKey)) continue;
            if (optKey === "id") continue;
            optBase[optKey] = opt[optKey];
          }
          return optBase;
        });
      }

      // childrenByValue のIDを除去
      if (base.childrenByValue && typeof base.childrenByValue === "object") {
        var fixed = {};
        for (var val in base.childrenByValue) {
          if (!base.childrenByValue.hasOwnProperty(val)) continue;
          fixed[val] = stripArray(base.childrenByValue[val]);
        }
        base.childrenByValue = fixed;
      }

      // 一時UI状態は保存対象外
      delete base._savedChoiceState;
      delete base._savedStyleSettings;
      delete base._savedChildrenForChoice;
      delete base._savedDisplayModeForChoice;

      return base;
    });
  };

  return stripArray(schema);
}

/**
 * プロパティサービスにフォームマッピングを保存
 * @param {Object} mapping - formId -> fileId のマッピング
 */




================================================
FILE: gas/formsParsing.gs
================================================
// Split from forms.gs



function Forms_parseGoogleDriveUrl_(url) {
  if (!url || typeof url !== "string") {
    return { type: null, id: null };
  }

  var trimmed = url.trim();
  if (!trimmed) {
    return { type: null, id: null };
  }

  // ファイルURL: https://drive.google.com/file/d/{fileId}/view
  var fileMatch = trimmed.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
  if (fileMatch) {
    return { type: "file", id: fileMatch[1] };
  }

  // フォルダURL: https://drive.google.com/drive/folders/{folderId}
  var folderMatch = trimmed.match(/\/folders\/([a-zA-Z0-9_-]+)/);
  if (folderMatch) {
    return { type: "folder", id: folderMatch[1] };
  }

  // open?id= 形式: https://drive.google.com/open?id={id}
  var openMatch = trimmed.match(/[?&]id=([a-zA-Z0-9_-]+)/);
  if (openMatch) {
    // ファイルかフォルダか判定が必要
    try {
      var item = DriveApp.getFileById(openMatch[1]);
      return { type: "file", id: openMatch[1] };
    } catch (e) {
      try {
        var folder = DriveApp.getFolderById(openMatch[1]);
        return { type: "folder", id: openMatch[1] };
      } catch (e2) {
        return { type: null, id: null };
      }
    }
  }

  // IDのみが渡された場合も試す
  if (/^[a-zA-Z0-9_-]+$/.test(trimmed)) {
    try {
      var testFile = DriveApp.getFileById(trimmed);
      return { type: "file", id: trimmed };
    } catch (e) {
      try {
        var testFolder = DriveApp.getFolderById(trimmed);
        return { type: "folder", id: trimmed };
      } catch (e2) {
        return { type: null, id: null };
      }
    }
  }

  return { type: null, id: null };
}

function Forms_generateFormId_(mapping) {
  var chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  var nextId = "";
  do {
    var randomChars = "";
    for (var i = 0; i < 8; i++) {
      randomChars += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    nextId = "f_" + new Date().getTime() + "_" + randomChars;
  } while (mapping && mapping[nextId]);
  return nextId;
}

function Forms_normalizeImportedFormData_(rawForm) {
  if (!rawForm || typeof rawForm !== "object" || Array.isArray(rawForm)) {
    return null;
  }
  if (!Array.isArray(rawForm.schema)) {
    return null;
  }

  var normalized = {};
  for (var key in rawForm) {
    if (!rawForm.hasOwnProperty(key)) continue;
    normalized[key] = rawForm[key];
  }

  var settings = rawForm.settings;
  if (!settings || typeof settings !== "object" || Array.isArray(settings)) {
    settings = {};
  } else {
    var copiedSettings = {};
    for (var settingsKey in settings) {
      if (!settings.hasOwnProperty(settingsKey)) continue;
      copiedSettings[settingsKey] = settings[settingsKey];
    }
    settings = copiedSettings;
  }

  if (!settings.formTitle && typeof rawForm.name === "string" && rawForm.name.trim()) {
    settings.formTitle = rawForm.name.trim();
  }

  normalized.settings = settings;
  return normalized;
}

/**
 * スプレッドシートまたはフォルダの指定を解決（ID/URLを受け取る）
 * @param {string} input
 * @return {{ type: "spreadsheet"|"folder"|null, id: string|null }}
 */

function Forms_parseSpreadsheetTarget_(input) {
  if (!input || typeof input !== "string") {
    return { type: null, id: null };
  }

  var trimmed = input.trim();
  if (!trimmed) {
    return { type: null, id: null };
  }

  var sheetMatch = trimmed.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
  if (sheetMatch) {
    return { type: "spreadsheet", id: sheetMatch[1] };
  }

  var folderMatch = trimmed.match(/\/drive\/folders\/([a-zA-Z0-9_-]+)/);
  if (folderMatch) {
    return { type: "folder", id: folderMatch[1] };
  }

  var fileMatch = trimmed.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
  if (fileMatch) {
    return Forms_resolveSpreadsheetIdOrFolder_(fileMatch[1]);
  }

  var openMatch = trimmed.match(/[?&]id=([a-zA-Z0-9_-]+)/);
  if (openMatch) {
    return Forms_resolveSpreadsheetIdOrFolder_(openMatch[1]);
  }

  if (/^[a-zA-Z0-9_-]{15,}$/.test(trimmed)) {
    return Forms_resolveSpreadsheetIdOrFolder_(trimmed);
  }

  return { type: null, id: null };
}

/**
 * IDがスプレッドシート/フォルダのどちらかを判定
 * @param {string} id
 * @return {{ type: "spreadsheet"|"folder"|null, id: string|null }}
 */

function Forms_resolveSpreadsheetIdOrFolder_(id) {
  if (!id) {
    return { type: null, id: null };
  }

  try {
    SpreadsheetApp.openById(id);
    return { type: "spreadsheet", id: id };
  } catch (e) {
    // ignore and try folder
  }

  try {
    DriveApp.getFolderById(id);
    return { type: "folder", id: id };
  } catch (e2) {
    // ignore
  }

  return { type: null, id: null };
}

/**
 * スプレッドシート名を生成
 * @param {Object} form
 * @return {string}
 */

function Forms_computeContentHash_(form) {
  // ハッシュ計算用にタイムスタンプとURL以外の内容を抽出
  var hashContent = {
    id: form.id || "",
    description: form.description || "",
    schema: form.schema || [],
    settings: form.settings || {},
    importantFields: form.importantFields || [],
    displayFieldSettings: form.displayFieldSettings || [],
    archived: !!form.archived,
    schemaVersion: form.schemaVersion || 1,
  };

  var contentStr = JSON.stringify(hashContent);
  var rawHash = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, contentStr);

  // バイト配列を16進数文字列に変換
  var hexHash = rawHash.map(function(byte) {
    var hex = (byte < 0 ? byte + 256 : byte).toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }).join("");

  // 先頭16文字を返す（ファイル名として扱いやすい長さに）
  return hexHash.substring(0, 16);
}




================================================
FILE: gas/formsPublicApi.gs
================================================
// Split from forms.gs



function nfbListForms(options) {
  return nfbSafeCall_(function() {
    var result = Forms_listForms_(options || {});
    return {
      ok: true,
      forms: result.forms || [],
      loadFailures: result.loadFailures || [],
    };
  });
}

/**
 * 特定フォームを取得
 */

function nfbGetForm(formId) {
  return nfbSafeCall_(function() {
    var form = Forms_getForm_(formId);
    if (!form) {
      return {
        ok: false,
        error: "Form not found",
      };
    }
    return {
      ok: true,
      form: form,
    };
  });
}

/**
 * フォームを保存（新規作成または更新）
 * @param {Object} payload - { form: Object, targetUrl: string, saveMode: string }
 */

function nfbSaveForm(payload) {
  return nfbSafeCall_(function() {
    var form = payload.form || payload;
    var targetUrl = payload.targetUrl || null;
    var saveMode = payload.saveMode || "auto";
    var result = Forms_saveForm_(form, targetUrl, saveMode);
    Logger.log("[nfbSaveForm] Result before return: " + JSON.stringify(result));
    Logger.log("[nfbSaveForm] Result.debugRawJsonBefore: " + result.debugRawJsonBefore);
    Logger.log("[nfbSaveForm] Result.debugRawJsonAfter: " + result.debugRawJsonAfter);
    Logger.log("[nfbSaveForm] Result.debugMappingStr: " + result.debugMappingStr);
    return result;
  });
}

/**
 * フォームを削除
 */

function nfbDeleteForm(formId) {
  return nfbSafeCall_(function() {
    return Forms_deleteForm_(formId);
  });
}

/**
 * 複数フォームを削除（まとめてプロパティ更新）
 */

function nfbDeleteForms(formIds) {
  return nfbSafeCall_(function() {
    return Forms_deleteForms_(formIds);
  });
}

/**
 * フォームをアーカイブ
 */

function nfbArchiveForm(formId) {
  return nfbSafeCall_(function() {
    return Forms_setFormArchivedState_(formId, true);
  });
}

/**
 * フォームのアーカイブを解除
 */

function nfbUnarchiveForm(formId) {
  return nfbSafeCall_(function() {
    return Forms_setFormArchivedState_(formId, false);
  });
}

/**
 * 複数フォームをまとめてアーカイブ
 * @param {Array<string>} formIds
 * @return {Object} { ok: boolean, updated: number, errors: Array, forms: Array }
 */

function nfbArchiveForms(formIds) {
  return nfbSafeCall_(function() {
    return Forms_setFormsArchivedState_(formIds, true);
  });
}

/**
 * 複数フォームのアーカイブをまとめて解除
 * @param {Array<string>} formIds
 * @return {Object} { ok: boolean, updated: number, errors: Array, forms: Array }
 */

function nfbUnarchiveForms(formIds) {
  return nfbSafeCall_(function() {
    return Forms_setFormsArchivedState_(formIds, false);
  });
}

/**
 * スプレッドシートの存在・権限を検証する
 * @param {string} spreadsheetIdOrUrl
 * @return {Object} { ok, spreadsheetId, title, canEdit, canView, sheetNames }
 */

function nfbValidateSpreadsheet(spreadsheetIdOrUrl) {
  return nfbSafeCall_(function() {
    if (!spreadsheetIdOrUrl) {
      return { ok: false, error: "Spreadsheet URL/ID is required" };
    }

    var parsed = Forms_parseSpreadsheetTarget_(String(spreadsheetIdOrUrl));
    if (!parsed.type) {
      return { ok: false, error: "無効なスプレッドシートURL/IDです" };
    }

    var userEmail = Session.getEffectiveUser().getEmail();

    if (parsed.type === "folder") {
      var folder = DriveApp.getFolderById(parsed.id);
      var canEdit = false;
      var canView = true;
      try {
        var editors = folder.getEditors();
        for (var i = 0; i < editors.length; i++) {
          if (editors[i].getEmail() === userEmail) {
            canEdit = true;
            break;
          }
        }
        if (!canEdit) {
          canEdit = folder.getOwner().getEmail() === userEmail || folder.getSharingPermission() === DriveApp.Permission.EDIT;
        }
      } catch (permErr) {
        Logger.log("[nfbValidateSpreadsheet] folder permission check failed: " + permErr);
      }

      return {
        ok: true,
        spreadsheetId: "",
        title: folder.getName(),
        sheetNames: [],
        canEdit: canEdit,
        canView: canView,
        isFolder: true,
        folderId: parsed.id,
      };
    }

    var spreadsheetId = parsed.id;
    var ss = SpreadsheetApp.openById(spreadsheetId);
    var sheets = ss.getSheets();
    var file = DriveApp.getFileById(spreadsheetId);

    var canEditSheet = false;
    var canViewSheet = true; // openByIdが成功した時点で閲覧は可
    try {
      var editorsSheet = file.getEditors();
      for (var j = 0; j < editorsSheet.length; j++) {
        if (editorsSheet[j].getEmail() === userEmail) {
          canEditSheet = true;
          break;
        }
      }
      if (!canEditSheet) {
        canEditSheet = file.getOwner().getEmail() === userEmail || file.getSharingPermission() === DriveApp.Permission.EDIT;
      }
    } catch (permErrSheet) {
      Logger.log("[nfbValidateSpreadsheet] permission check failed: " + permErrSheet);
    }

    return {
      ok: true,
      spreadsheetId: spreadsheetId,
      title: ss.getName(),
      sheetNames: sheets.map(function(sheet) { return sheet.getName(); }),
      canEdit: canEditSheet,
      canView: canViewSheet,
      isFolder: false,
    };
  });
}

/**
 * Google DriveのURL（ファイルまたはフォルダ）からフォームをインポート
 * @param {string} url - Google DriveのURL
 * @return {Object} { ok: true, forms: Array, skipped: number }
 */

function nfbImportFormsFromDrive(url) {
  return nfbSafeCall_(function() {
    return Forms_importFromDrive_(url);
  });
}

/**
 * インポートしたフォームをコピーなしでマッピングに登録する
 * @param {Object} payload - { form: Object, fileId: string, fileUrl: string }
 * @return {Object} { ok: true, form, fileId, fileUrl }
 */

function nfbRegisterImportedForm(payload) {
  return nfbSafeCall_(function() {
    return Forms_registerImportedForm_(payload);
  });
}

/**
 * デバッグ用：Forms_getMapping_()を直接呼び出してその結果を返す
 * @return {Object} { ok: true, mapping: Object }
 */

function nfbDebugCallGetMapping() {
  return nfbSafeCall_(function() {
    var mapping = Forms_getMapping_();
    return {
      ok: true,
      mapping: mapping,
      totalForms: Object.keys(mapping).length,
    };
  });
}

/**
 * デバッグ用：PropertiesServiceのマッピングを取得
 * @return {Object} { ok: true, mapping: Object, rawJson: string }
 */

function nfbDebugGetMapping() {
  return nfbSafeCall_(function() {
    var props = Forms_getActiveProps_();
    var mode = Nfb_getPropertyStoreMode_();
    var rawJson = props.getProperty(FORMS_PROPERTY_KEY);
    var mapping = Forms_parseMappingJson_(rawJson, mode);
    var legacyInfo = { hasLegacy: false, legacyCount: 0, migratedCount: 0 };

    return {
      ok: true,
      propertyStoreMode: mode,
      mapping: mapping,
      rawJson: rawJson,
      totalForms: Object.keys(mapping).length,
      legacyInfo: legacyInfo,
    };
  });
}

/**
 * フォーム内容からハッシュ値を計算（同じ内容なら同じハッシュ）
 * タイムスタンプとdriveFileUrlを除いた内容でハッシュを計算
 * @param {Object} form - フォームオブジェクト
 * @return {string} ハッシュ値（16進数、先頭16文字）
 */




================================================
FILE: gas/formsStorage.gs
================================================
// Split from forms.gs



function Forms_buildSpreadsheetName_(form) {
  var base = "";
  if (form && form.settings && form.settings.formTitle) {
    base = String(form.settings.formTitle || "");
  }
  if (!base && form && form.id) {
    base = "form_" + form.id;
  }
  base = String(base || "Nested Form Builder");
  base = base.replace(/[\r\n]/g, " ").replace(/\//g, "-").trim();
  if (!base) {
    base = "Nested Form Builder";
  }
  var name = "NFB Responses - " + base;
  if (name.length > 120) {
    name = name.substring(0, 120);
  }
  return name;
}

/**
 * スプレッドシートを新規作成
 * @param {string} name
 * @param {string|null} folderId
 * @return {{ spreadsheetId: string, spreadsheetUrl: string }}
 */

function Forms_createSpreadsheet_(name, folderId) {
  var ss = SpreadsheetApp.create(name || "NFB Responses");
  var spreadsheetId = ss.getId();

  if (folderId) {
    var folder = DriveApp.getFolderById(folderId);
    var file = DriveApp.getFileById(spreadsheetId);
    folder.addFile(file);
    try {
      DriveApp.getRootFolder().removeFile(file);
    } catch (err) {
      Logger.log("[Forms_createSpreadsheet_] Root remove failed: " + err);
    }
  }

  return {
    spreadsheetId: spreadsheetId,
    spreadsheetUrl: ss.getUrl()
  };
}

/**
 * スプレッドシート設定を解決（空/フォルダ指定は新規作成）
 * @param {Object} settings
 * @param {Object} form
 * @return {{ settings: Object, created: boolean, spreadsheetId: string|null, spreadsheetUrl: string|null }}
 */

function Forms_resolveSpreadsheetSetting_(settings, form) {
  var nextSettings = (settings && typeof settings === "object") ? JSON.parse(JSON.stringify(settings)) : {};
  var rawInput = String(nextSettings.spreadsheetId || "").trim();

  if (!rawInput) {
    var createdRoot = Forms_createSpreadsheet_(Forms_buildSpreadsheetName_(form), null);
    nextSettings.spreadsheetId = createdRoot.spreadsheetUrl;
    return {
      settings: nextSettings,
      created: true,
      spreadsheetId: createdRoot.spreadsheetId,
      spreadsheetUrl: createdRoot.spreadsheetUrl
    };
  }

  var parsed = Forms_parseSpreadsheetTarget_(rawInput);
  if (!parsed.type) {
    throw new Error("無効なスプレッドシートURL/IDです");
  }

  if (parsed.type === "folder") {
    var createdFolder = Forms_createSpreadsheet_(Forms_buildSpreadsheetName_(form), parsed.id);
    nextSettings.spreadsheetId = createdFolder.spreadsheetUrl;
    return {
      settings: nextSettings,
      created: true,
      spreadsheetId: createdFolder.spreadsheetId,
      spreadsheetUrl: createdFolder.spreadsheetUrl
    };
  }

  // spreadsheet
  try {
    SpreadsheetApp.openById(parsed.id);
  } catch (err) {
    throw new Error("スプレッドシートにアクセスできません: " + (err && err.message ? err.message : String(err)));
  }

  nextSettings.spreadsheetId = rawInput;
  return {
    settings: nextSettings,
    created: false,
    spreadsheetId: parsed.id,
    spreadsheetUrl: "https://docs.google.com/spreadsheets/d/" + parsed.id + "/edit"
  };
}

/**
 * プロパティサービスから全フォームマッピングを取得
 * @return {Object} formId -> fileId のマッピング
 */

function Forms_getOrCreateFolder_() {
  var folders = DriveApp.getFoldersByName(FORMS_FOLDER_NAME);
  if (folders.hasNext()) {
    return folders.next();
  }
  return DriveApp.createFolder(FORMS_FOLDER_NAME);
}

/**
 * フォームをGoogle Driveに保存（新規作成または更新）
 * @param {Object} form - フォームオブジェクト
 * @param {string} targetUrl - 保存先URL（オプション）
 * @param {string} saveMode - 保存モード（auto|overwrite_existing|copy_to_root|copy_to_folder）
 * @return {Object} { ok: true, fileId, fileUrl, form }
 */

function Forms_saveForm_(form, targetUrl, saveMode) {
  if (!form || !form.id) {
    throw new Error("Form ID is required");
  }

  var requestedSaveMode = saveMode || "auto";
  Logger.log("[Forms_saveForm_] Starting save for formId: " + form.id + ", requestedSaveMode: " + requestedSaveMode);

  // DEBUG: 現在のプロパティ保存先を直接読んで確認
  var activeProps = Forms_getActiveProps_();
  var propertyStoreMode = Nfb_getPropertyStoreMode_();
  var rawJsonBeforeGetMapping = activeProps.getProperty(FORMS_PROPERTY_KEY);
  Logger.log("[Forms_saveForm_] DEBUG: Raw JSON from PropertiesService (" + propertyStoreMode + ") BEFORE Forms_getMapping_: " + rawJsonBeforeGetMapping);

  var mapping = Forms_getMapping_();
  Logger.log("[Forms_saveForm_] Current mapping before save: " + JSON.stringify(mapping));

  // DEBUG: もう一度PropertiesServiceを直接読んで確認
  var rawJsonAfterGetMapping = activeProps.getProperty(FORMS_PROPERTY_KEY);
  Logger.log("[Forms_saveForm_] DEBUG: Raw JSON from PropertiesService (" + propertyStoreMode + ") AFTER Forms_getMapping_: " + rawJsonAfterGetMapping);

  var mappingEntry = mapping[form.id] || {};
  var existingFileId = mappingEntry.fileId;
  Logger.log("[Forms_saveForm_] Existing fileId for this form: " + existingFileId);

  var file;
  var fileId = null;
  var nowDate = new Date();
  var nowSerial = Sheets_dateToSerial_(nowDate);
  var createdAtSerial = Sheets_toUnixMs_(form.createdAt, true);
  if (createdAtSerial === null) {
    createdAtSerial = nowSerial;
  }

  // スプレッドシート設定を解決（空/フォルダ指定は新規作成）
  var settingsResult = Forms_resolveSpreadsheetSetting_(form.settings || {}, form);
  if (settingsResult && settingsResult.created) {
    Logger.log("[Forms_saveForm_] Created spreadsheet: " + settingsResult.spreadsheetUrl);
  }
  var settingsForSave = (settingsResult && settingsResult.settings) ? settingsResult.settings : (form.settings || {});

  // 仮のフォームオブジェクトを作成（driveFileUrlなし）
  var formWithTimestamp = {
    id: form.id,
    description: form.description || "",
    schema: form.schema || [],
    settings: settingsForSave,
    schemaHash: form.schemaHash || "",
    importantFields: form.importantFields || [],
    displayFieldSettings: form.displayFieldSettings || [],
    createdAt: createdAtSerial,
    modifiedAt: nowSerial,
    createdAtUnixMs: createdAtSerial,
    modifiedAtUnixMs: nowSerial,
    archived: !!form.archived,
    schemaVersion: form.schemaVersion || 1,
  };

  var content = JSON.stringify(formWithTimestamp, null, 2);
  var formTitle = (form.settings && form.settings.formTitle) || form.description || form.id;
  var safeTitle = String(formTitle).replace(/[\\/:*?"<>|]/g, "_").substring(0, 100);
  var fileName = safeTitle + ".json";

  var parsedTarget = null;
  if (targetUrl) {
    parsedTarget = Forms_parseGoogleDriveUrl_(targetUrl);
    if (!parsedTarget.type) {
      throw new Error("[save-stage=parse-target] 無効なGoogle Drive URLです. formId=" + form.id + ", saveMode=" + requestedSaveMode);
    }
  }

  var effectiveSaveMode = requestedSaveMode;
  if (effectiveSaveMode === "auto") {
    if (parsedTarget && parsedTarget.type === "folder") {
      effectiveSaveMode = "copy_to_folder";
    } else if (parsedTarget && parsedTarget.type === "file") {
      effectiveSaveMode = "overwrite_existing";
    } else if (existingFileId) {
      effectiveSaveMode = "overwrite_existing";
    } else {
      effectiveSaveMode = "copy_to_root";
    }
  }

  if (effectiveSaveMode === "overwrite_existing") {
    var overwriteFileId = null;
    if (parsedTarget && parsedTarget.type === "file") {
      overwriteFileId = parsedTarget.id;
    } else if (existingFileId) {
      overwriteFileId = existingFileId;
    }

    if (!overwriteFileId) {
      throw new Error("[save-stage=resolve-overwrite-target] 上書き保存先のファイルIDを解決できません. formId=" + form.id + ", saveMode=" + effectiveSaveMode);
    }

    try {
      file = DriveApp.getFileById(overwriteFileId);
    } catch (errOpenFile) {
      throw new Error("[save-stage=open-file] ファイルにアクセスできません. formId=" + form.id + ", fileId=" + overwriteFileId + ", saveMode=" + effectiveSaveMode + ", error=" + (errOpenFile && errOpenFile.message ? errOpenFile.message : String(errOpenFile)));
    }

    try {
      file.setContent(content);
      fileId = overwriteFileId;
    } catch (errWriteFile) {
      throw new Error("[save-stage=write-file] ファイル更新に失敗しました. formId=" + form.id + ", fileId=" + overwriteFileId + ", saveMode=" + effectiveSaveMode + ", error=" + (errWriteFile && errWriteFile.message ? errWriteFile.message : String(errWriteFile)));
    }
  } else if (effectiveSaveMode === "copy_to_folder") {
    if (!parsedTarget || parsedTarget.type !== "folder") {
      throw new Error("[save-stage=resolve-folder-target] copy_to_folder にはフォルダURLが必要です. formId=" + form.id + ", saveMode=" + effectiveSaveMode);
    }

    try {
      var folder = DriveApp.getFolderById(parsedTarget.id);
      file = folder.createFile(fileName, content, MimeType.PLAIN_TEXT);
      fileId = file.getId();
    } catch (errCreateInFolder) {
      throw new Error("[save-stage=create-in-folder] 指定フォルダへの保存に失敗しました. formId=" + form.id + ", folderId=" + parsedTarget.id + ", saveMode=" + effectiveSaveMode + ", error=" + (errCreateInFolder && errCreateInFolder.message ? errCreateInFolder.message : String(errCreateInFolder)));
    }
  } else if (effectiveSaveMode === "copy_to_root") {
    try {
      file = DriveApp.createFile(fileName, content, MimeType.PLAIN_TEXT);
      fileId = file.getId();
    } catch (errCreateInRoot) {
      throw new Error("[save-stage=create-in-root] マイドライブ直下への保存に失敗しました. formId=" + form.id + ", saveMode=" + effectiveSaveMode + ", error=" + (errCreateInRoot && errCreateInRoot.message ? errCreateInRoot.message : String(errCreateInRoot)));
    }
  } else {
    throw new Error("[save-stage=resolve-mode] 未知のsaveModeです: " + effectiveSaveMode + ", formId=" + form.id);
  }

  if (!file && fileId) {
    try {
      file = DriveApp.getFileById(fileId);
    } catch (errReload) {
      throw new Error("[save-stage=reload-file] 保存後ファイルの再取得に失敗しました. formId=" + form.id + ", fileId=" + fileId + ", saveMode=" + effectiveSaveMode + ", error=" + (errReload && errReload.message ? errReload.message : String(errReload)));
    }
  }

  var fileUrl = null;
  try {
    fileUrl = file.getUrl();
  } catch (errGetUrl) {
    throw new Error("[save-stage=get-url] ファイルURLの取得に失敗しました. formId=" + form.id + ", fileId=" + fileId + ", saveMode=" + effectiveSaveMode + ", error=" + (errGetUrl && errGetUrl.message ? errGetUrl.message : String(errGetUrl)));
  }
  formWithTimestamp.driveFileUrl = fileUrl;

  // ダウンロード用ファイル内容からIDを除外（外部配布用にID非表示）
  var formForFile = {};
  for (var key in formWithTimestamp) {
    if (!formWithTimestamp.hasOwnProperty(key)) continue;
    if (key === "id") continue;
    if (key === "schema") {
      formForFile.schema = Forms_stripSchemaIds_(formWithTimestamp.schema);
    } else {
      formForFile[key] = formWithTimestamp[key];
    }
  }
  formForFile.driveFileUrl = fileUrl;

  // driveFileUrlを含めて再度ファイルに書き込み（IDなし）
  try {
    file.setContent(JSON.stringify(formForFile, null, 2));
  } catch (errWriteFinal) {
    throw new Error("[save-stage=final-write] driveFileUrl反映書き込みに失敗しました. formId=" + form.id + ", fileId=" + fileId + ", saveMode=" + effectiveSaveMode + ", error=" + (errWriteFinal && errWriteFinal.message ? errWriteFinal.message : String(errWriteFinal)));
  }

  // マッピングを更新
  mapping[form.id] = { fileId: fileId, driveFileUrl: fileUrl };
  Logger.log("[Forms_saveForm_] Updated mapping, about to save: " + JSON.stringify(mapping));
  Forms_saveMapping_(mapping);
  Logger.log("[Forms_saveForm_] Mapping saved. FormId: " + form.id + ", FileId: " + fileId + ", saveMode: " + effectiveSaveMode);

  // 認証用URLマップにも登録（?form=xxx でアクセス可能にする）
  try {
    AddFormUrl_(form.id, fileUrl);
  } catch (err) {
    Logger.log("[Forms_saveForm_] AddFormUrl_ failed (non-critical): " + err);
  }

  return {
    ok: true,
    fileId: fileId,
    fileUrl: fileUrl,
    saveMode: effectiveSaveMode,
    form: formWithTimestamp,
    debugRawJsonBefore: rawJsonBeforeGetMapping,
    debugRawJsonAfter: rawJsonAfterGetMapping,
    debugMappingStr: JSON.stringify(mapping),
  };
}

/**
 * 全フォームを取得（Drive API v3 バッチリクエスト最適化版）
 * @param {Object} options - { includeArchived: boolean }
 * @return {Array} フォーム配列
 */




================================================
FILE: gas/model.gs
================================================
function Model_normalizeContext_(body = {}, params = {}) {
  const responses = (body.responses && typeof body.responses === "object") ? body.responses : {};
  const order = (Array.isArray(body.order) && body.order.length) ? body.order : Object.keys(responses);
  const rowIndexHint = typeof body.rowIndexHint === "number" ? body.rowIndexHint : (typeof params.rowIndexHint === "number" ? params.rowIndexHint : null);

  return {
    version: body.version || 1,
    formTitle: body.formTitle || "",
    schemaHash: body.schemaHash || "",
    spreadsheetId: params.spreadsheetId || body.spreadsheetId || "",
    sheetName: params.sheetName || body.sheetName || NFB_DEFAULT_SHEET_NAME,
    id: body.id || params.id || "",
    responses,
    order,
    rowIndexHint,
    raw: body,
  };
}

function Model_parseRequest_(e) {
  let body = {};
  if (e?.postData?.contents) {
    try {
      body = JSON.parse(e.postData.contents);
    } catch (err) {
      Logger.log(`[Model_parseRequest_] JSON parse error: ${nfbErrorToString_(err)}`);
    }
  }
  const params = e?.parameter || {};
  return Model_normalizeContext_(body, params);
}

const Model_fromScriptRunPayload_ = (payload) => Model_normalizeContext_(payload || {}, {});



================================================
FILE: gas/properties.gs
================================================
const Nfb_getPropertyStoreMode_ = () => {
  const rawMode = String(NFB_PROPERTY_STORE_MODE || "").trim().toLowerCase();
  return rawMode === NFB_PROPERTY_STORE_MODE_SCRIPT ? NFB_PROPERTY_STORE_MODE_SCRIPT : NFB_PROPERTY_STORE_MODE_USER;
};

const Nfb_getActiveProperties_ = () => Nfb_getPropertyStoreMode_() === NFB_PROPERTY_STORE_MODE_USER ? PropertiesService.getUserProperties() : PropertiesService.getScriptProperties();
const Nfb_isAdminSettingsEnabled_ = () => Nfb_getPropertyStoreMode_() === NFB_PROPERTY_STORE_MODE_SCRIPT;

const ExtractFileIdFromUrl_ = (url) => {
  if (!url || typeof url !== "string") return null;
  const parsed = Forms_parseGoogleDriveUrl_(url);
  return parsed.type === "file" ? parsed.id : null;
};

const GetFormUrls_ = () => {
  try {
    if (typeof Forms_getMapping_ !== "function") return {};
    const mapping = Forms_getMapping_() || {};
    const urlMap = {};
    Object.entries(mapping).forEach(([formId, entry]) => {
      let fileUrl = entry?.driveFileUrl || null;
      if (!fileUrl && entry?.fileId) {
        fileUrl = typeof Forms_buildDriveFileUrlFromId_ === "function"
          ? Forms_buildDriveFileUrlFromId_(entry.fileId)
          : `https://drive.google.com/file/d/${entry.fileId}/view`;
      }
      if (fileUrl) urlMap[formId] = fileUrl;
    });
    return urlMap;
  } catch (error) {
    Logger.log(`[GetFormUrls_] Error: ${nfbErrorToString_(error)}`);
    return {};
  }
};

const SaveFormUrls_ = (urlMap = {}) => {
  try {
    if (typeof Forms_getMapping_ !== "function" || typeof Forms_saveMapping_ !== "function") throw new Error("Forms mapping functions are unavailable");
    const mapping = Forms_getMapping_() || {};
    Object.entries(urlMap).forEach(([formId, fileUrl]) => {
      if (!fileUrl) return;
      mapping[formId] = { fileId: ExtractFileIdFromUrl_(fileUrl) || mapping[formId]?.fileId || null, driveFileUrl: fileUrl };
    });
    Forms_saveMapping_(mapping);
  } catch (error) {
    throw new Error(`フォームURLマップの保存に失敗しました: ${nfbErrorToString_(error)}`);
  }
};

const AddFormUrl_ = (formId, fileUrl) => {
  try {
    if (!formId || !fileUrl) throw new Error("フォームIDまたはファイルURLが指定されていません");
    const fileId = ExtractFileIdFromUrl_(fileUrl);
    if (!fileId) throw new Error("無効なGoogle DriveファイルURLです");
    try { DriveApp.getFileById(fileId); } catch (e) { throw new Error(`ファイルへのアクセス権限がありません: ${nfbErrorToString_(e)}`); }

    const mapping = Forms_getMapping_() || {};
    mapping[formId] = { fileId: fileId || mapping[formId]?.fileId || null, driveFileUrl: fileUrl };
    Forms_saveMapping_(mapping);
    return { ok: true, message: "フォームURLを追加しました", formId, fileUrl, fileId };
  } catch (error) {
    throw new Error(`フォームURLの追加に失敗しました: ${nfbErrorToString_(error)}`);
  }
};

const GetFormUrl_ = (formId) => {
  try {
    if (!formId || typeof Forms_getMapping_ !== "function") return null;
    const entry = Forms_getMapping_()?.[formId];
    if (entry?.driveFileUrl) return entry.driveFileUrl;
    if (entry?.fileId) return typeof Forms_buildDriveFileUrlFromId_ === "function" ? Forms_buildDriveFileUrlFromId_(entry.fileId) : `https://drive.google.com/file/d/${entry.fileId}/view`;
    return null;
  } catch (error) {
    Logger.log(`[GetFormUrl_] Error: ${nfbErrorToString_(error)}`);
    return null;
  }
};



================================================
FILE: gas/settings.gs
================================================
// ========================================
// 管理者キー関連 (Script Properties)
// ========================================

/**
 * 管理者設定が無効なときは例外を投げる
 */
function EnsureAdminSettingsEnabled_() {
  if (!Nfb_isAdminSettingsEnabled_()) {
    throw new Error("管理者設定は現在のプロパティ保存モードでは利用できません");
  }
}

/**
 * 管理者設定はscript propertiesで管理する
 * @return {GoogleAppsScript.Properties.Properties}
 */
function GetAdminProps_() {
  return PropertiesService.getScriptProperties();
}

/**
 * 管理者キーを取得する
 * @return {string} 管理者キー（未設定の場合は空文字）
 */
function GetAdminKey_() {
  if (!Nfb_isAdminSettingsEnabled_()) {
    return "";
  }
  var props = GetAdminProps_();
  return props.getProperty(NFB_ADMIN_KEY) || "";
}

/**
 * 管理者キーを設定する
 * @param {string} newKey - 新しい管理者キー（空文字で認証無効化）
 * @return {Object} 結果オブジェクト
 */
function SetAdminKey_(newKey) {
  EnsureAdminSettingsEnabled_();
  var props = GetAdminProps_();
  var key = String(newKey || "");
  props.setProperty(NFB_ADMIN_KEY, key);
  return { ok: true, adminKey: key };
}

/**
 * メールアドレスを比較用に正規化する
 * @param {string} value
 * @return {string}
 */
function NormalizeEmail_(value) {
  return String(value || "").trim().toLowerCase();
}

/**
 * 管理者メール設定値（";"区切り）を配列化して返す
 * @param {string} raw
 * @return {string[]}
 */
function ParseAdminEmails_(raw) {
  var text = String(raw || "");
  if (!text) return [];
  var seen = {};
  var result = [];
  var parts = text.split(";");
  for (var i = 0; i < parts.length; i += 1) {
    var normalized = NormalizeEmail_(parts[i]);
    if (!normalized) continue;
    if (seen[normalized]) continue;
    seen[normalized] = true;
    result.push(normalized);
  }
  return result;
}

/**
 * 管理者メール（";"区切り）を取得する
 * @return {string}
 */
function GetAdminEmail_() {
  if (!Nfb_isAdminSettingsEnabled_()) {
    return "";
  }
  var props = GetAdminProps_();
  return props.getProperty(NFB_ADMIN_EMAIL) || "";
}

/**
 * 管理者メール（";"区切り）を設定する
 * @param {string} newEmail - 新しい管理者メール（空文字で制限解除）
 * @return {Object}
 */
function SetAdminEmail_(newEmail) {
  EnsureAdminSettingsEnabled_();
  var emails = ParseAdminEmails_(newEmail);
  // メールリストが空でない場合は、現在のユーザーが含まれているか確認する
  // （誤って誰も管理者画面に入れなくなることを防ぐ）
  if (emails.length > 0) {
    var currentUserEmail = NormalizeEmail_(Session.getActiveUser().getEmail() || "");
    if (!currentUserEmail || emails.indexOf(currentUserEmail) === -1) {
      throw new Error(
        "現在のアカウント（" + (currentUserEmail || "不明") + "）が管理者リストに含まれていないため保存できません。" +
        "自分自身をロックアウトしないよう、現在のメールアドレスをリストに含めてください。"
      );
    }
  }
  var props = GetAdminProps_();
  var normalized = emails.join(";");
  props.setProperty(NFB_ADMIN_EMAIL, normalized);
  return { ok: true, adminEmail: normalized };
}

/**
 * 管理者メール制限に一致しているか判定する
 * @param {string} activeUserEmail
 * @return {boolean}
 */
function IsAdminEmailMatched_(activeUserEmail) {
  if (!Nfb_isAdminSettingsEnabled_()) {
    return false;
  }
  var adminEmails = ParseAdminEmails_(GetAdminEmail_());
  if (adminEmails.length === 0) {
    // 管理者メール未設定の場合は制限しない
    return true;
  }
  var normalizedUserEmail = NormalizeEmail_(activeUserEmail);
  if (!normalizedUserEmail) {
    return false;
  }
  return adminEmails.indexOf(normalizedUserEmail) !== -1;
}

/**
 * 管理者判定を行う
 * @param {string} adminKeyParam - URLのadminkeyパラメータ
 * @param {string} activeUserEmail - 現在ユーザーのメール
 * @return {boolean} 管理者の場合はtrue
 */
function IsAdmin_(adminKeyParam, activeUserEmail) {
  if (!Nfb_isAdminSettingsEnabled_()) {
    return false;
  }
  var adminKey = GetAdminKey_();
  if (adminKey !== "" && String(adminKeyParam || "") !== adminKey) {
    return false;
  }
  return IsAdminEmailMatched_(activeUserEmail);
}

/**
 * 個別フォーム限定フラグを取得する
 * @return {boolean}
 */
function GetRestrictToFormOnly_() {
  if (!Nfb_isAdminSettingsEnabled_()) return false;
  var props = GetAdminProps_();
  return props.getProperty(NFB_RESTRICT_TO_FORM_ONLY) === "true";
}

/**
 * 個別フォーム限定フラグを設定する
 * @param {*} value
 * @return {Object}
 */
function SetRestrictToFormOnly_(value) {
  EnsureAdminSettingsEnabled_();
  var props = GetAdminProps_();
  var flag = value === true || value === "true" || value === 1 || value === "1";
  props.setProperty(NFB_RESTRICT_TO_FORM_ONLY, flag ? "true" : "false");
  return { ok: true, restrictToFormOnly: flag };
}

/**
 * アクセス権限を判定する
 * @param {string} formParam - formパラメータ
 * @param {string} adminkeyParam - adminkeyパラメータ
 * @param {string} activeUserEmail - 現在ユーザーのメール
 * @return {{ isAdmin: boolean, formId: string, authError: string }}
 */
function DetermineAccess_(formParam, adminkeyParam, activeUserEmail) {
  // formパラメータがある場合（form優先）
  if (formParam) {
    // フォームの存在確認
    var fileUrl = GetFormUrl_(formParam);
    if (fileUrl) {
      // フォームが存在する → ユーザーモード
      return { isAdmin: false, formId: formParam, authError: "" };
    } else {
      // フォームが存在しない → エラー
      return { isAdmin: false, formId: "", authError: "form_not_found" };
    }
  }

  // userモード時は管理者設定を無効化し、常に通常モードで表示
  if (!Nfb_isAdminSettingsEnabled_()) {
    return { isAdmin: false, formId: "", authError: "" };
  }

  var restrictToFormOnly = GetRestrictToFormOnly_();
  var adminKey = GetAdminKey_();

  // formパラメータがない場合は管理者モード判定
  // 管理者キー設定済みの場合は一致が必須
  if (adminKey !== "" && adminkeyParam !== adminKey) {
    return { isAdmin: false, formId: "", authError: restrictToFormOnly ? "forbidden" : "" };
  }

  // 管理者メール設定済みの場合は一致が必須（大文字小文字は無視）
  if (!IsAdminEmailMatched_(activeUserEmail)) {
    return { isAdmin: false, formId: "", authError: restrictToFormOnly ? "forbidden" : "" };
  }

  return { isAdmin: true, formId: "", authError: "" };
}

/**
 * 管理者キーを取得するAPI（管理者専用）
 * @return {Object} 管理者キー情報
 */
function nfbGetAdminKey() {
  return nfbSafeCall_(function() {
    return { ok: true, adminKey: GetAdminKey_() };
  });
}

/**
 * 管理者キーを設定するAPI（管理者専用）
 * @param {string} newKey - 新しい管理者キー
 * @return {Object} 結果オブジェクト
 */
function nfbSetAdminKey(newKey) {
  return nfbSafeCall_(function() {
    return SetAdminKey_(newKey);
  });
}

/**
 * 管理者メールを取得するAPI
 * @return {Object}
 */
function nfbGetAdminEmail() {
  return nfbSafeCall_(function() {
    return { ok: true, adminEmail: GetAdminEmail_() };
  });
}

/**
 * 管理者メールを設定するAPI
 * @param {string} newEmail - 新しい管理者メール（";"区切り）
 * @return {Object}
 */
function nfbSetAdminEmail(newEmail) {
  return nfbSafeCall_(function() {
    return SetAdminEmail_(newEmail);
  });
}

/**
 * 個別フォーム限定フラグを取得するAPI
 * @return {Object}
 */
function nfbGetRestrictToFormOnly() {
  return nfbSafeCall_(function() {
    return { ok: true, restrictToFormOnly: GetRestrictToFormOnly_() };
  });
}

/**
 * 個別フォーム限定フラグを設定するAPI
 * @param {*} value
 * @return {Object}
 */
function nfbSetRestrictToFormOnly(value) {
  return nfbSafeCall_(function() {
    return SetRestrictToFormOnly_(value);
  });
}




================================================
FILE: gas/sheetsDatetime.gs
================================================
// Split from sheets.gs



function Sheets_isValidDate_(date) {
  return date instanceof Date && !isNaN(date.getTime());
}

function Sheets_serialToDate_(serial) {
  if (typeof serial !== "number" || !isFinite(serial)) return null;
  var ms = NFB_SHEETS_EPOCH_MS + serial * NFB_MS_PER_DAY;
  var d = new Date(ms);
  return Sheets_isValidDate_(d) ? d : null;
}

function Sheets_parseDateLikeToJstDate_(value, allowSerialNumber) {
  if (value === null || value === undefined) return null;
  if (Sheets_isValidDate_(value)) return value;

  if (allowSerialNumber) {
    if (typeof value === "number" && isFinite(value)) {
      return Sheets_serialToDate_(value);
    }
    if (typeof value === "string") {
      var numeric = value.trim();
      if (/^[-+]?\d+(?:\.\d+)?$/.test(numeric)) {
        var numericValue = parseFloat(numeric);
        if (isFinite(numericValue)) {
          return Sheets_serialToDate_(numericValue);
        }
      }
    }
  }

  if (typeof value !== "string") return null;
  var str = value.trim();
  if (!str) return null;

  // ISO 8601 (タイムゾーン付き/なし) はそのままDateへ
  if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(str)) {
    var isoDate = new Date(str);
    return Sheets_isValidDate_(isoDate) ? isoDate : null;
  }

  // YYYY-MM-DD[/ ]HH:mm[:ss]
  var dateTimeMatch = str.match(/^(\d{4})-(\d{2})-(\d{2})(?:[\/\s]+(\d{1,2}):(\d{2})(?::(\d{2}))?)$/);
  if (dateTimeMatch) {
    var parts = dateTimeMatch;
    var dt = new Date(
      parseInt(parts[1], 10),
      parseInt(parts[2], 10) - 1,
      parseInt(parts[3], 10),
      parseInt(parts[4], 10),
      parseInt(parts[5], 10),
      parts[6] ? parseInt(parts[6], 10) : 0
    );
    return Sheets_isValidDate_(dt) ? dt : null;
  }

  // YYYY-MM-DD
  var dateOnlyMatch = str.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (dateOnlyMatch) {
    var d = new Date(parseInt(dateOnlyMatch[1], 10), parseInt(dateOnlyMatch[2], 10) - 1, parseInt(dateOnlyMatch[3], 10), 0, 0, 0);
    return Sheets_isValidDate_(d) ? d : null;
  }

  // HH:mm[:ss] を基準日(1899-12-30)のJSTで扱う
  var timeOnlyMatch = str.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
  if (timeOnlyMatch) {
    var t = new Date(1899, 11, 30, parseInt(timeOnlyMatch[1], 10), parseInt(timeOnlyMatch[2], 10), timeOnlyMatch[3] ? parseInt(timeOnlyMatch[3], 10) : 0);
    return Sheets_isValidDate_(t) ? t : null;
  }

  return null;
}

function Sheets_isDateString_(value) {
  return /^\d{4}-\d{2}-\d{2}$/.test(value);
}

function Sheets_isTimeString_(value) {
  return /^\d{1,2}:\d{2}(?::\d{2})?$/.test(value);
}

function Sheets_detectTemporalColumnType_(values, columnIndex) {
  var hasValue = false;
  var allDate = true;
  var allTime = true;

  for (var i = 0; i < values.length; i++) {
    var cell = values[i][columnIndex];
    if (cell === null || cell === undefined || cell === "") continue;
    hasValue = true;

    if (cell instanceof Date) {
      if (!Sheets_isValidDate_(cell)) return null;
      var isBaseTime = cell.getFullYear() === 1899 && cell.getMonth() === 11 && cell.getDate() === 30;
      var isMidnight = cell.getHours() === 0 && cell.getMinutes() === 0 && cell.getSeconds() === 0;
      if (!isBaseTime) allTime = false;
      if (!isMidnight) allDate = false;
    } else if (typeof cell === "string") {
      var trimmed = cell.trim();
      if (!trimmed) continue;
      if (!Sheets_isDateString_(trimmed)) allDate = false;
      if (!Sheets_isTimeString_(trimmed)) allTime = false;
    } else {
      allDate = false;
      allTime = false;
    }

    if (!allDate && !allTime) return null;
  }

  if (!hasValue) return null;
  if (allTime) return "time";
  if (allDate) return "date";
  return null;
}

function Sheets_applyTemporalFormatToColumn_(sheet, columnIndex, values, dataRowCount, numberFormat) {
  var converted = [];
  for (var i = 0; i < dataRowCount; i++) {
    var cell = values[i][columnIndex];
    if (cell === null || cell === undefined || cell === "") {
      converted.push([""]);
      continue;
    }
    if (cell instanceof Date || (typeof cell === "number" && isFinite(cell))) {
      converted.push([cell]);
      continue;
    }
    var parsed = Sheets_parseDateLikeToJstDate_(cell);
    converted.push([parsed || cell]);
  }

  var range = sheet.getRange(NFB_HEADER_DEPTH + 1, columnIndex + 1, dataRowCount, 1);
  range.setValues(converted);
  range.setNumberFormat(numberFormat);
}

function Sheets_applyTemporalFormats_(sheet, columnPaths, values, dataRowCount, explicitTypeMap) {
  if (!dataRowCount) return;

  var keyToIndex = {};
  for (var i = 0; i < columnPaths.length; i++) {
    keyToIndex[columnPaths[i].key] = columnPaths[i].index;
  }

  var dateTimeFormat = "yyyy/MM/dd HH:mm:ss";
  var dateFormat = "yyyy/MM/dd";
  var timeFormat = "HH:mm";

  var createdAtIndex = keyToIndex["createdAt"];
  var modifiedAtIndex = keyToIndex["modifiedAt"];

  if (typeof createdAtIndex === "number") {
    Sheets_applyTemporalFormatToColumn_(sheet, createdAtIndex, values, dataRowCount, dateTimeFormat);
  }
  if (typeof modifiedAtIndex === "number") {
    Sheets_applyTemporalFormatToColumn_(sheet, modifiedAtIndex, values, dataRowCount, dateTimeFormat);
  }

  var reservedKeys = { "id": true, "No.": true, "createdAt": true, "modifiedAt": true, "createdBy": true, "modifiedBy": true };
  var hasExplicitMap = explicitTypeMap && typeof explicitTypeMap === "object";
  for (var j = 0; j < columnPaths.length; j++) {
    var colInfo = columnPaths[j];
    if (reservedKeys[colInfo.key]) continue;
    if (hasExplicitMap) {
      var explicitType = explicitTypeMap[colInfo.key];
      if (explicitType === "date") {
        Sheets_applyTemporalFormatToColumn_(sheet, colInfo.index, values, dataRowCount, dateFormat);
        continue;
      }
      if (explicitType === "time") {
        Sheets_applyTemporalFormatToColumn_(sheet, colInfo.index, values, dataRowCount, timeFormat);
        continue;
      }
    }
    var temporalType = Sheets_detectTemporalColumnType_(values, colInfo.index);
    if (temporalType === "date") {
      Sheets_applyTemporalFormatToColumn_(sheet, colInfo.index, values, dataRowCount, dateFormat);
    } else if (temporalType === "time") {
      Sheets_applyTemporalFormatToColumn_(sheet, colInfo.index, values, dataRowCount, timeFormat);
    }
  }
}

function Sheets_toDateOrOriginal_(value) {
  var parsed = Sheets_parseDateLikeToJstDate_(value);
  return parsed || value;
}

function Sheets_dateToSerial_(date) {
  if (!Sheets_isValidDate_(date)) return null;
  return (date.getTime() - NFB_SHEETS_EPOCH_MS) / NFB_MS_PER_DAY;
}

function Sheets_toUnixMs_(value, allowSerialNumber) {
  var d = Sheets_parseDateLikeToJstDate_(value, allowSerialNumber);
  return d ? Sheets_dateToSerial_(d) : null;
}




================================================
FILE: gas/sheetsExport.gs
================================================
// Split from sheets.gs



function Sheets_exportResultMatrixToNewSpreadsheet_(spreadsheetTitle, headerRows, rows, themeColors) {
  if (!headerRows || !headerRows.length) throw new Error("headerRows is required");
  if (!Array.isArray(rows)) throw new Error("rows must be an array");

  var normalizedHeaderRows = Array.isArray(headerRows) ? headerRows : [];
  var normalizedRows = Array.isArray(rows) ? rows : [];

  var maxColumns = 0;
  for (var i = 0; i < normalizedHeaderRows.length; i++) {
    var headerLength = Array.isArray(normalizedHeaderRows[i]) ? normalizedHeaderRows[i].length : 0;
    if (headerLength > maxColumns) maxColumns = headerLength;
  }
  for (var j = 0; j < normalizedRows.length; j++) {
    var rowLength = Array.isArray(normalizedRows[j]) ? normalizedRows[j].length : 0;
    if (rowLength > maxColumns) maxColumns = rowLength;
  }
  if (maxColumns <= 0) throw new Error("No columns to export");

  var normalizeRow = function(row) {
    var source = Array.isArray(row) ? row : [];
    var next = [];
    for (var idx = 0; idx < maxColumns; idx++) {
      var value = source[idx];
      if (value === null || value === undefined) {
        next.push("");
      } else {
        next.push(String(value));
      }
    }
    return next;
  };

  var exportRows = [];
  for (var h = 0; h < normalizedHeaderRows.length; h++) {
    exportRows.push(normalizeRow(normalizedHeaderRows[h]));
  }
  for (var r = 0; r < normalizedRows.length; r++) {
    exportRows.push(normalizeRow(normalizedRows[r]));
  }

  var now = new Date();
  var pad = function(n) { return n < 10 ? "0" + n : String(n); };
  var defaultTitle = "検索結果_" +
    now.getFullYear() + "-" +
    pad(now.getMonth() + 1) + "-" +
    pad(now.getDate()) + "_" +
    pad(now.getHours()) +
    pad(now.getMinutes()) +
    pad(now.getSeconds());
  var title = String(spreadsheetTitle || "").trim() || defaultTitle;

  var ss = SpreadsheetApp.create(title);
  var sheet = ss.getSheets()[0];
  Sheets_ensureColumnExists_(sheet, maxColumns);
  Sheets_ensureRowCapacity_(sheet, exportRows.length);

  if (exportRows.length > 0) {
    sheet.getRange(1, 1, exportRows.length, maxColumns).setValues(exportRows);
  }
  sheet.setFrozenRows(normalizedHeaderRows.length);

  var headerCount = normalizedHeaderRows.length;
  var dataRowCount = normalizedRows.length;
  var primary = (themeColors && themeColors.primary) || "#2f6fed";
  var primarySoft = (themeColors && themeColors.primarySoft) || "#dbeafe";
  var textColor = "#1a1a2e";
  var borderColor = (themeColors && themeColors.border) || "#e6e8f0";
  var surface = (themeColors && themeColors.surface) || "#ffffff";

  if (headerCount > 0 && maxColumns > 0) {
    var headerRange = sheet.getRange(1, 1, headerCount, maxColumns);
    headerRange.setBackground(primary)
               .setFontColor("#ffffff")
               .setFontWeight("bold");
    headerRange.setBorder(true, true, true, true, true, true,
      primary, SpreadsheetApp.BorderStyle.SOLID_MEDIUM);
  }

  if (dataRowCount > 0 && maxColumns > 0) {
    var bgColors = [];
    var fontColors = [];
    for (var s = 0; s < dataRowCount; s++) {
      var bg = (s % 2 === 0) ? surface : primarySoft;
      bgColors.push(new Array(maxColumns).fill(bg));
      fontColors.push(new Array(maxColumns).fill(textColor));
    }
    var dataRange = sheet.getRange(headerCount + 1, 1, dataRowCount, maxColumns);
    dataRange.setBackgrounds(bgColors).setFontColors(fontColors);
    dataRange.setBorder(true, true, true, true, true, true,
      borderColor, SpreadsheetApp.BorderStyle.SOLID);
  }

  return {
    ok: true,
    spreadsheetId: ss.getId(),
    spreadsheetName: ss.getName(),
    spreadsheetUrl: ss.getUrl(),
    exportedCount: normalizedRows.length,
    headerCount: normalizedHeaderRows.length
  };
}

function Sheets_appendRowsToSpreadsheet_(spreadsheetId, rows, themeColors, headerCount, rowOffset) {
  if (!spreadsheetId) throw new Error("spreadsheetId is required");
  if (!Array.isArray(rows) || rows.length === 0) {
    return { ok: true, appendedCount: 0 };
  }

  var ss = SpreadsheetApp.openById(spreadsheetId);
  var sheet = ss.getSheets()[0];
  var lastRow = sheet.getLastRow();
  var maxColumns = 0;
  for (var i = 0; i < rows.length; i++) {
    var rowLen = Array.isArray(rows[i]) ? rows[i].length : 0;
    if (rowLen > maxColumns) maxColumns = rowLen;
  }
  if (maxColumns <= 0) return { ok: true, appendedCount: 0 };

  Sheets_ensureColumnExists_(sheet, maxColumns);
  Sheets_ensureRowCapacity_(sheet, lastRow + rows.length);

  var normalizedRows = [];
  for (var j = 0; j < rows.length; j++) {
    var source = Array.isArray(rows[j]) ? rows[j] : [];
    var normalized = [];
    for (var k = 0; k < maxColumns; k++) {
      var value = source[k];
      if (value === null || value === undefined) {
        normalized.push("");
      } else {
        normalized.push(String(value));
      }
    }
    normalizedRows.push(normalized);
  }

  sheet.getRange(lastRow + 1, 1, normalizedRows.length, maxColumns).setValues(normalizedRows);

  var offset = typeof rowOffset === "number" ? rowOffset : 0;
  var primarySoft = (themeColors && themeColors.primarySoft) || "#dbeafe";
  var textColor = "#1a1a2e";
  var borderColor = (themeColors && themeColors.border) || "#e6e8f0";
  var surface = (themeColors && themeColors.surface) || "#ffffff";

  var bgColors = [];
  var fontColors = [];
  for (var m = 0; m < normalizedRows.length; m++) {
    var bg = ((offset + m) % 2 === 0) ? surface : primarySoft;
    bgColors.push(new Array(maxColumns).fill(bg));
    fontColors.push(new Array(maxColumns).fill(textColor));
  }
  var appendedRange = sheet.getRange(lastRow + 1, 1, normalizedRows.length, maxColumns);
  appendedRange.setBackgrounds(bgColors).setFontColors(fontColors);
  appendedRange.setBorder(true, true, true, true, true, true,
    borderColor, SpreadsheetApp.BorderStyle.SOLID);

  return { ok: true, appendedCount: normalizedRows.length };
}




================================================
FILE: gas/sheetsHeaders.gs
================================================
// Split from sheets.gs



function Sheets_getOrCreateSheet_(spreadsheetId, sheetName) {
  if (!spreadsheetId) throw new Error("spreadsheetId is required");

  var ss;
  try {
    ss = SpreadsheetApp.openById(spreadsheetId);
  } catch (err) {
    throw new Error(Sheets_translateOpenError_(err, spreadsheetId));
  }
  var resolvedSheetName = sheetName || NFB_DEFAULT_SHEET_NAME;
  var sheet = ss.getSheetByName(resolvedSheetName);
  return sheet || ss.insertSheet(resolvedSheetName);
}

function Sheets_generateRecordId_() {
  var timestamp = new Date().getTime();
  var randomChars = "";
  var chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  for (var i = 0; i < 8; i++) {
    randomChars += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return "r_" + timestamp + "_" + randomChars;
}

function Sheets_ensureRowCapacity_(sheet, minRows) {
  if (sheet.getMaxRows() < minRows) {
    sheet.insertRowsAfter(sheet.getMaxRows() || 1, minRows - sheet.getMaxRows());
  }
}

function Sheets_ensureColumnExists_(sheet, columnCount) {
  if (sheet.getMaxColumns() < columnCount) {
    sheet.insertColumnsAfter(sheet.getMaxColumns() || 1, columnCount - sheet.getMaxColumns());
  }
}

function Sheets_readHeaderMatrix_(sheet) {
  var lastColumn = sheet.getLastColumn();
  if (lastColumn === 0) {
    Sheets_ensureColumnExists_(sheet, 1);
    lastColumn = 1;
  }
  Sheets_ensureRowCapacity_(sheet, NFB_HEADER_DEPTH);
  var range = sheet.getRange(1, 1, NFB_HEADER_DEPTH, lastColumn);
  return range.getValues();
}

function Sheets_extractColumnPaths_(matrix) {
  var paths = [];
  if (!matrix || !matrix.length) return paths;
  for (var col = 0; col < matrix[0].length; col++) {
    var path = [];
    for (var row = 0; row < NFB_HEADER_DEPTH; row++) {
      var cell = (matrix[row] && matrix[row][col]) ? String(matrix[row][col]) : "";
      if (!cell) break;
      path.push(cell);
    }
    if (path.length) paths.push(path);
  }
  return paths;
}

function Sheets_pathKey_(path) {
  return path.join("|");
}

function Sheets_collectTemporalPathMap_(schema) {
  var map = {};

  var walk = function(fields, basePath) {
    if (!fields || !fields.length) return;

    for (var i = 0; i < fields.length; i++) {
      var field = fields[i];
      if (!field) continue;
      var label = field.label !== undefined && field.label !== null ? String(field.label) : "";
      if (!label) continue;
      var path = basePath ? basePath + "|" + label : label;

      if (field.type === "date" || field.type === "time") {
        map[path] = field.type;
      }

      if (field.childrenByValue && typeof field.childrenByValue === "object") {
        for (var key in field.childrenByValue) {
          if (!field.childrenByValue.hasOwnProperty(key)) continue;
          var childFields = field.childrenByValue[key];
          var optionLabel = String(key || "");
          var nextPath = optionLabel ? path + "|" + optionLabel : path;
          walk(childFields, nextPath);
        }
      }
    }
  };

  walk(Array.isArray(schema) ? schema : [], "");
  return map;
}

function Sheets_buildDesiredPaths_(order, existingPaths) {
  var desired = [];
  var seen = {};

  NFB_FIXED_HEADER_PATHS.forEach(function (path) {
    var key = Sheets_pathKey_(path);
    if (!seen[key]) {
      desired.push(path);
      seen[key] = true;
    }
  });

  (order || []).forEach(function (keyRaw) {
    var keyStr = String(keyRaw || "");
    if (!keyStr) return;
    var parts = keyStr.split("|")
      .map(function (part) { return String(part || "").trim(); })
      .filter(function (part) { return part; })
      .slice(0, NFB_HEADER_DEPTH);
    if (!parts.length) return;
    var key = Sheets_pathKey_(parts);
    if (!seen[key]) {
      desired.push(parts);
      seen[key] = true;
    }
  });

  (existingPaths || []).forEach(function (path) {
    var key = Sheets_pathKey_(path);
    if (!seen[key]) {
      desired.push(path);
      seen[key] = true;
    }
  });

  return desired;
}

function Sheets_findColumnByPath_(matrix, path) {
  if (!matrix || !matrix.length) return -1;
  var targetKey = Sheets_pathKey_(path);
  var paths = Sheets_extractColumnPaths_(matrix);
  for (var col = 0; col < paths.length; col++) {
    if (Sheets_pathKey_(paths[col]) === targetKey) {
      return col + 1;
    }
  }
  return -1;
}

function Sheets_writeHeaderPath_(sheet, columnIndex, path) {
  var values = [];
  for (var row = 0; row < NFB_HEADER_DEPTH; row++) {
    values.push([row < path.length ? path[row] : ""]);
  }
  sheet.getRange(1, columnIndex, NFB_HEADER_DEPTH, 1).setValues(values);
}

function Sheets_ensureHeaderMatrix_(sheet, order) {
  Sheets_ensureRowCapacity_(sheet, NFB_HEADER_DEPTH);
  if (sheet.getFrozenRows() !== NFB_HEADER_DEPTH) {
    sheet.setFrozenRows(NFB_HEADER_DEPTH);
  }

  // Move/insert columns will fail if any part of the column (not just header rows) is merged.
  // Unmerge the full used range up-front to avoid "結合したセルの一部だけを含む列は移動できません" errors.
  var maxCols = Math.max(sheet.getMaxColumns(), 1);
  var maxRows = Math.max(sheet.getMaxRows(), NFB_HEADER_DEPTH);
  sheet.getRange(1, 1, maxRows, maxCols).breakApart();

  var matrix = Sheets_readHeaderMatrix_(sheet);
  var existingPaths = Sheets_extractColumnPaths_(matrix);
  var desired = Sheets_buildDesiredPaths_(order, existingPaths);

  for (var i = 0; i < desired.length; i++) {
    var path = desired[i];
    var found = Sheets_findColumnByPath_(matrix, path);
    var targetIndex = i + 1;

    if (found === -1) {
      sheet.insertColumns(targetIndex, 1);
      Sheets_writeHeaderPath_(sheet, targetIndex, path);
      matrix = Sheets_readHeaderMatrix_(sheet);
    } else if (found !== targetIndex) {
      var range = sheet.getRange(1, found, sheet.getMaxRows(), 1);
      sheet.moveColumns(range, targetIndex);
      Sheets_writeHeaderPath_(sheet, targetIndex, path);
      matrix = Sheets_readHeaderMatrix_(sheet);
    } else {
      Sheets_writeHeaderPath_(sheet, targetIndex, path);
    }
  }

  return sheet.getRange(1, 1, NFB_HEADER_DEPTH, sheet.getLastColumn()).getValues();
}

function Sheets_buildHeaderKeyMap_(sheet) {
  var lastColumn = sheet.getLastColumn();
  if (!lastColumn) return {};
  var values = sheet.getRange(1, 1, NFB_HEADER_DEPTH, lastColumn).getValues();
  var paths = Sheets_extractColumnPaths_(values);
  var map = {};
  for (var col = 0; col < paths.length; col++) {
    map[Sheets_pathKey_(paths[col])] = col + 1;
  }
  return map;
}




================================================
FILE: gas/sheetsRecords.gs
================================================
// Split from sheets.gs



function Sheets_readColumnPaths_(sheet, lastColumn) {
  var headerMatrix = sheet.getRange(1, 1, NFB_HEADER_DEPTH, lastColumn).getValues();
  var columnPaths = [];
  for (var col = 0; col < lastColumn; col++) {
    var path = [];
    for (var row = 0; row < NFB_HEADER_DEPTH; row++) {
      var cell = headerMatrix[row][col] ? String(headerMatrix[row][col]) : "";
      if (!cell) break;
      path.push(cell);
    }
    if (path.length) {
      columnPaths.push({ index: col, path: path, key: Sheets_pathKey_(path) });
    }
  }
  return columnPaths;
}

function Sheets_buildRecordFromRow_(rowData, columnPaths) {
  var id = rowData[0] ? String(rowData[0]) : "";
  if (!id) return null;

  var record = {
    id: id,
    "No.": rowData[1] || "",
    createdAt: rowData[2] || "",
    modifiedAt: rowData[3] || "",
    createdBy: rowData[4] || "",
    modifiedBy: rowData[5] || "",
    createdAtUnixMs: Sheets_toUnixMs_(rowData[2], true),
    modifiedAtUnixMs: Sheets_toUnixMs_(rowData[3], true),
    data: {},
    dataUnixMs: {}
  };

  var reservedKeys = { "id": true, "No.": true, "createdAt": true, "modifiedAt": true, "createdBy": true, "modifiedBy": true };

  for (var j = 0; j < columnPaths.length; j++) {
    var colInfo = columnPaths[j];
    var value = rowData[colInfo.index];
    if (value != null && value !== "" && !reservedKeys[colInfo.key]) {
      record.data[colInfo.key] = value;
      var unix = Sheets_toUnixMs_(value);
      if (unix !== null) {
        record.dataUnixMs[colInfo.key] = unix;
      }
    }
  }

  return record;
}

function Sheets_getRecordById_(sheet, id, rowIndexHint) {
  if (!id) return { ok: false, error: "Record ID is required" };

  var lastRow = sheet.getLastRow();
  var lastColumn = sheet.getLastColumn();
  if (lastColumn === 0 || lastRow <= NFB_HEADER_DEPTH) {
    return { ok: false, error: "Record not found" };
  }

  var resolvedRowIndex = -1;

  // 0-basedのデータ行indexをヒントとして受け取り、先頭ヘッダー行を考慮して変換
  if (typeof rowIndexHint === "number" && rowIndexHint >= 0) {
    var candidate = NFB_HEADER_DEPTH + 1 + rowIndexHint;
    if (candidate <= lastRow) {
      var idCell = sheet.getRange(candidate, 1, 1, 1).getValues()[0][0];

      if (String(idCell) === String(id)) {
        resolvedRowIndex = candidate;
      }
    }
  }

  if (resolvedRowIndex === -1) {
    resolvedRowIndex = Sheets_findRowById_(sheet, id);
  }

  if (resolvedRowIndex === -1) {
    return { ok: false, error: "Record not found" };
  }

  var dataRowIndex = resolvedRowIndex - (NFB_HEADER_DEPTH + 1);

  var columnPaths = Sheets_readColumnPaths_(sheet, lastColumn);
  var rowData = sheet.getRange(resolvedRowIndex, 1, 1, lastColumn).getValues()[0];
  var record = Sheets_buildRecordFromRow_(rowData, columnPaths);
  if (!record) {
    return { ok: false, error: "Record not found" };
  }

  return { ok: true, record: record, rowIndex: dataRowIndex };
}

function Sheets_getAllRecords_(sheet, temporalTypeMap) {
  var lastRow = sheet.getLastRow();
  var lastColumn = sheet.getLastColumn();

  if (lastRow <= NFB_HEADER_DEPTH || lastColumn === 0) {
    return [];
  }

  var columnPaths = Sheets_readColumnPaths_(sheet, lastColumn);
  var dataRowCount = lastRow - NFB_HEADER_DEPTH;

  // スプレッドシート側でID列(2列目)で必ずソート
  if (dataRowCount > 0) {
    var sortRange = sheet.getRange(NFB_HEADER_DEPTH + 1, 1, dataRowCount, lastColumn);
    sortRange.sort({column: 2, ascending: true});
  }

  var dataRange = sheet.getRange(NFB_HEADER_DEPTH + 1, 1, dataRowCount, lastColumn).getValues();
  if (dataRowCount > 0) {
    Sheets_applyTemporalFormats_(sheet, columnPaths, dataRange, dataRowCount, temporalTypeMap);
  }

  var records = [];
  for (var i = 0; i < dataRange.length; i++) {
    var record = Sheets_buildRecordFromRow_(dataRange[i], columnPaths);
    if (record) records.push(record);
  }

  return records;
}




================================================
FILE: gas/sheetsRowOps.gs
================================================
// Split from sheets.gs



function Sheets_findRowById_(sheet, id) {
  if (!id) return -1;
  var lastRow = sheet.getLastRow();
  if (lastRow <= NFB_HEADER_DEPTH) return -1;
  var lookupRange = sheet.getRange(NFB_HEADER_DEPTH + 1, 1, lastRow - NFB_HEADER_DEPTH, 1).getValues();

  // 二分探索を試行（ID列がソート済みの場合に高速化）
  var binaryResult = Sheets_binarySearchById_(lookupRange, id);
  if (binaryResult !== -1) {
    return NFB_HEADER_DEPTH + 1 + binaryResult;
  }

  // フォールバック: 線形探索（後方互換性のため）
  for (var i = 0; i < lookupRange.length; i++) {
    if (String(lookupRange[i][0]) === String(id)) {
      return NFB_HEADER_DEPTH + 1 + i;
    }
  }
  return -1;
}

function Sheets_binarySearchById_(lookupRange, targetId) {
  if (!lookupRange || lookupRange.length === 0) return -1;

  var targetStr = String(targetId);
  var left = 0;
  var right = lookupRange.length - 1;

  // ソート済みかチェック（最初と最後を比較）
  var firstId = String(lookupRange[0][0]);
  var lastId = String(lookupRange[right][0]);

  // IDが "r_" で始まるタイムスタンプベースの形式かチェック
  if (!firstId.startsWith("r_") || !lastId.startsWith("r_")) {
    return -1; // 二分探索不可
  }

  // ソート順チェック（簡易版: 先頭 <= 末尾）
  if (firstId > lastId) {
    return -1; // ソートされていない
  }

  // 二分探索実行
  while (left <= right) {
    var mid = Math.floor((left + right) / 2);
    var midId = String(lookupRange[mid][0]);

    if (midId === targetStr) {
      return mid;
    } else if (midId < targetStr) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

function Sheets_prepareResponses_(ctx) {
  var responseKeys = (ctx.order && ctx.order.length)
    ? ctx.order
    : Object.keys(ctx.responses || {});

  var sortedResponses = {};
  for (var r = 0; r < responseKeys.length; r++) {
    var key = responseKeys[r];
    if (ctx.responses && Object.prototype.hasOwnProperty.call(ctx.responses, key)) {
      sortedResponses[key] = ctx.responses[key];
    }
  }
  ctx.responses = sortedResponses;
  ctx.order = responseKeys;
}

function Sheets_createNewRow_(sheet, id) {
  var nextId = (id && String(id)) || Sheets_generateRecordId_();
  var rowIndex = Math.max(sheet.getLastRow() + 1, NFB_HEADER_DEPTH + 1);

  Sheets_ensureRowCapacity_(sheet, rowIndex);
  var now = new Date();

  var maxNo = 0;
  var lastRow = sheet.getLastRow();
  if (lastRow > NFB_HEADER_DEPTH) {
    var noValues = sheet.getRange(NFB_HEADER_DEPTH + 1, 2, lastRow - NFB_HEADER_DEPTH, 1).getValues();
    for (var i = 0; i < noValues.length; i++) {
      var val = noValues[i][0];
      if (typeof val === 'number' && val > maxNo) {
        maxNo = val;
      }
    }
  }

  var nowSerial = Sheets_dateToSerial_(now);
  var email = Session.getActiveUser().getEmail() || "";

  sheet.getRange(rowIndex, 1).setValue(String(nextId));
  sheet.getRange(rowIndex, 2).setValue(String(maxNo + 1));
  sheet.getRange(rowIndex, 3).setValue(nowSerial);
  sheet.getRange(rowIndex, 4).setValue(nowSerial);
  sheet.getRange(rowIndex, 5).setValue(email);
  sheet.getRange(rowIndex, 6).setValue(email);

  return { rowIndex: rowIndex, id: nextId };
}

function Sheets_updateExistingRow_(sheet, rowIndex) {
  Sheets_ensureRowCapacity_(sheet, rowIndex);
  var nowSerial = Sheets_dateToSerial_(new Date());
  var email = Session.getActiveUser().getEmail() || "";
  sheet.getRange(rowIndex, 4).setValue(nowSerial);
  sheet.getRange(rowIndex, 5).setValue(email);
}

function Sheets_clearDataRow_(sheet, rowIndex, keyToColumn, reservedHeaderKeys) {
  for (var key in keyToColumn) {
    if (Object.prototype.hasOwnProperty.call(keyToColumn, key) && !reservedHeaderKeys[key]) {
      var columnIndex = keyToColumn[key];
      if (columnIndex) {
        sheet.getRange(rowIndex, columnIndex).setValue("");
      }
    }
  }
}

function Sheets_writeDataToRow_(sheet, rowIndex, orderKeys, responses, keyToColumn, reservedHeaderKeys) {
  for (var i = 0; i < orderKeys.length; i++) {
    var key = String(orderKeys[i] || "");
    if (!key || reservedHeaderKeys[key]) continue;
    var columnIndex = keyToColumn[key];
    if (!columnIndex) continue;
    var value = responses && Object.prototype.hasOwnProperty.call(responses, key) ? responses[key] : "";
    if (value === undefined || value === null) value = "";
    sheet.getRange(rowIndex, columnIndex).setValue(String(value));
  }
}

function Sheets_upsertRecordById_(sheet, order, ctx) {
  Sheets_prepareResponses_(ctx);
  Sheets_ensureHeaderMatrix_(sheet, ctx.order);
  var keyToColumn = Sheets_buildHeaderKeyMap_(sheet);

  var reservedHeaderKeys = {};
  NFB_FIXED_HEADER_PATHS.forEach(function(path) {
    reservedHeaderKeys[Sheets_pathKey_(path)] = true;
  });

  var rowIndex = Sheets_findRowById_(sheet, ctx.id);

  if (rowIndex === -1) {
    var newRow = Sheets_createNewRow_(sheet, ctx.id);
    rowIndex = newRow.rowIndex;
    ctx.id = newRow.id;
  } else {
    Sheets_updateExistingRow_(sheet, rowIndex);
    Sheets_clearDataRow_(sheet, rowIndex, keyToColumn, reservedHeaderKeys);
  }

  Sheets_writeDataToRow_(sheet, rowIndex, ctx.order, ctx.responses, keyToColumn, reservedHeaderKeys);

  return { row: rowIndex, id: ctx.id };
}

function Sheets_deleteRecordById_(sheet, id) {
  var rowIndex = Sheets_findRowById_(sheet, id);

  if (rowIndex === -1) {
    return { ok: false, error: "Record not found" };
  }

  sheet.deleteRow(rowIndex);
  return { ok: true, row: rowIndex, id: id };
}




================================================
FILE: gas/scripts/bundle.js
================================================
#!/usr/bin/env node

/**
 * GAS ファイル結合スクリプト
 *
 * gas/ フォルダ内の複数の .gs ファイルを1つの Bundle.gs に結合します。
 * 開発時は分割ファイルで作業し、デプロイ時に結合することで、
 * コードの見通しと実行効率を両立させます。
 */

const fs = require('fs');
const path = require('path');

// パス設定
const GAS_SOURCE_DIR = path.join(__dirname, '..');  // gas/scripts/.. → gas
const DIST_DIR = path.join(__dirname, '..', '..', 'dist');  // gas/scripts/../../dist → dist
const OUTPUT_FILE = path.join(DIST_DIR, 'Bundle.gs');

// 結合順序（依存関係順）
const FILE_ORDER = [
  'constants.gs',
  'errors.gs',      // エラーハンドリング・レスポンス共通
  'settings.gs',    // 定数・設定
  'properties.gs',  // プロパティサービス管理
  'drive.gs',       // Google Drive操作
  'formsParsing.gs',
  'formsMappingStore.gs',
  'formsStorage.gs',
  'formsCrud.gs',
  'formsImport.gs',
  'formsPublicApi.gs',
  'model.gs',       // モデル関数
  'sheetsDatetime.gs',
  'sheetsHeaders.gs',
  'sheetsRowOps.gs',
  'sheetsRecords.gs',
  'sheetsExport.gs',
  'Code.gs',        // メインエントリーポイント
];

/**
 * dist ディレクトリを作成
 */
function ensureDistDir() {
  if (!fs.existsSync(DIST_DIR)) {
    fs.mkdirSync(DIST_DIR, { recursive: true });
    console.log(`✅ Created directory: ${DIST_DIR}`);
  }
}

/**
 * GAS ファイルを結合
 */
function bundleGasFiles() {
  const bundledContent = [];

  // ヘッダーコメント
  bundledContent.push('/**');
  bundledContent.push(' * Nested Form Builder - GAS Bundle');
  bundledContent.push(` * Generated: ${new Date().toISOString()}`);
  bundledContent.push(' * DO NOT EDIT THIS FILE DIRECTLY');
  bundledContent.push(' * Edit source files in gas/ directory instead');
  bundledContent.push(' */');
  bundledContent.push('');

  // 各ファイルを順番に結合
  FILE_ORDER.forEach((fileName) => {
    const filePath = path.join(GAS_SOURCE_DIR, fileName);

    if (!fs.existsSync(filePath)) {
      console.warn(`⚠️  Warning: ${fileName} not found, skipping...`);
      return;
    }

    const content = fs.readFileSync(filePath, 'utf8');

    // ファイル区切りコメント
    bundledContent.push('// ' + '='.repeat(77));
    bundledContent.push(`// ${fileName}`);
    bundledContent.push('// ' + '='.repeat(77));
    bundledContent.push('');
    bundledContent.push(content.trim());
    bundledContent.push('');
  });

  // 出力
  const finalContent = bundledContent.join('\n');
  fs.writeFileSync(OUTPUT_FILE, finalContent, 'utf8');

  console.log(`✅ Bundle created: ${OUTPUT_FILE}`);
  console.log(`   Size: ${(finalContent.length / 1024).toFixed(2)} KB`);
  console.log(`   Files bundled: ${FILE_ORDER.length}`);
}

/**
 * メイン処理
 */
function main() {
  try {
    ensureDistDir();
    bundleGasFiles();
    console.log('🎉 GAS bundling completed successfully!');
  } catch (error) {
    console.error('❌ Error during bundling:', error.message);
    process.exit(1);
  }
}

// 実行
main();


